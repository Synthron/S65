ca65 V2.18 - Ubuntu 2.19-1
Main file   : main.s
Current file: main.s

000000r 1               .setcpu "65c02"
000000r 1               .debuginfo
000000r 1               
000000r 1               .include "macros.s"
000000r 2               ; ---------------------------------------------
000000r 2               ; Macro to write the String Pointer for the
000000r 2               ; PRINT_MSG function to Zero Page
000000r 2               ; ---------------------------------------------
000000r 2               .macro cpt addr
000000r 2                   lda #<addr   ; low byte
000000r 2                   sta $EC
000000r 2                   lda #>addr   ; high byte
000000r 2                   sta $ED
000000r 2               .endmacro
000000r 2               
000000r 1               .include "io.s"
000000r 2               ; IO Space base addresses
000000r 2               
000000r 2               TPI1   = $BF00
000000r 2               IDE1   = $BF08
000000r 2               LPT1   = $BF10
000000r 2               LPT2   = $BF12
000000r 2               VGA    = $BF14
000000r 2               PIA    = $BF1C
000000r 2               VIA1   = $BF20
000000r 2               VIA2   = $BF30
000000r 2               VIA3   = $BF40
000000r 2               ACIA1  = $BF50
000000r 2               ACIA2  = $BF54
000000r 2               ACIA3  = $BF58
000000r 2               ACIA4  = $BF5C
000000r 2               SID    = $BF60
000000r 2               IDE2   = $BF80
000000r 2               CFCARD = $BF88
000000r 2               RTC    = $BF90
000000r 2               
000000r 1               .include "pia.s"
000000r 2               ; PIA = LEDs
000000r 2               
000000r 2               PORTA_PIA = PIA + 0
000000r 2               CRA_PIA   = PIA + 1
000000r 2               PORTB_PIA = PIA + 2
000000r 2               CRB_PIA   = PIA + 3
000000r 2               
000000r 2               PIA_DDR   = $00 ; config value for DDR Register
000000r 2               PIA_PORT  = $04 ; config value for PORT Register
000000r 2               
000000r 2                   .segment "CODE"
000000r 2               
000000r 2               PIA_INIT:
000000r 2  A9 00            lda #PIA_DDR
000002r 2  8D 1D BF         sta CRA_PIA
000005r 2  8D 1F BF         sta CRB_PIA
000008r 2               
000008r 2  A9 FF            lda #$ff
00000Ar 2  8D 1C BF         sta PORTA_PIA
00000Dr 2  8D 1E BF         sta PORTB_PIA
000010r 2               
000010r 2  A9 04            lda #PIA_PORT
000012r 2  8D 1D BF         sta CRA_PIA
000015r 2  8D 1F BF         sta CRB_PIA
000018r 2  60               rts
000019r 2               
000019r 1               .include "via.s"
000019r 2               ;initialize VIA1 with IRQ and LCD
000019r 2               PORTB1   = VIA1 + 0
000019r 2               PORTA1   = VIA1 + 1
000019r 2               DDRB1    = VIA1 + 2
000019r 2               DDRA1    = VIA1 + 3
000019r 2               VIA1_PCR = VIA1 + 12
000019r 2               VIA1_IFR = VIA1 + 13
000019r 2               VIA1_IER = VIA1 + 14
000019r 2               ;initialize VIA2
000019r 2               PORTB2   = VIA2 + 0
000019r 2               PORTA2   = VIA2 + 1
000019r 2               DDRB2    = VIA2 + 2
000019r 2               DDRA2    = VIA2 + 3
000019r 2               VIA2_PCR = VIA2 + 12
000019r 2               VIA2_IFR = VIA2 + 13
000019r 2               VIA2_IER = VIA2 + 14
000019r 2               ;initialize VIA3
000019r 2               PORTB3   = VIA3 + 0
000019r 2               PORTA3   = VIA3 + 1
000019r 2               DDRB3    = VIA3 + 2
000019r 2               DDRA3    = VIA3 + 3
000019r 2               VIA3_PCR = VIA3 + 12
000019r 2               VIA3_IFR = VIA3 + 13
000019r 2               VIA3_IER = VIA3 + 14
000019r 2               ; PCR
000019r 2               ; bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
000019r 2               ; |    CB2     | CB1  |    CA2     | CA1
000019r 2               ;  1    1    0    0    1    1    0    0
000019r 2               ; set CB2 out low, CB1 negative edge, CA2 out low, CA1 negative edge
000019r 2               ; IER
000019r 2               ; bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
000019r 2               ; S/C   T1   T2  CB1  CB2  SHR  CA1  CA2
000019r 2               ; 1     0    0    1    0    0    0    0
000019r 2               ; IFR
000019r 2               ; bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
000019r 2               ; IRQ  TIM1 TIM2 CB1  CB2  SR   CA1  CA2
000019r 2               
000019r 2               .rodata
000000r 2               
000000r 2               
000000r 2               VIA1_Init:
000000r 2  A9 00            lda #0          ; Reset Port A
000002r 2  8D 21 BF         sta PORTA1
000005r 2  A9 FF            lda #$FF        ; Port A to output for LCD
000007r 2  8D 23 BF         sta DDRA1
00000Ar 2  A9 7F            lda #$7F         ; disable all interrupts
00000Cr 2  8D 2E BF         sta VIA1_IER
00000Fr 2  A9 CC            lda #$CC        ; Cx2 Out Low, Cx1 Interrupt falling edge
000011r 2  8D 2C BF         sta VIA1_PCR
000014r 2  A9 90            lda #$90        ; Enable Interrupt on CB1 active edge
000016r 2  8D 2E BF         sta VIA1_IER
000019r 2  60               rts
00001Ar 2               
00001Ar 2               VIA2_Init:
00001Ar 2  A9 00            lda #0          ; set all pins Input
00001Cr 2  8D 33 BF         sta DDRA2
00001Fr 2  8D 32 BF         sta DDRB2
000022r 2  A9 7F            lda #$7F        ; disable all interrupts
000024r 2  8D 3E BF         sta VIA2_IER
000027r 2  60               rts
000028r 2               
000028r 2               VIA3_Init:
000028r 2  A9 00            lda #0          ; set all pins Input
00002Ar 2  8D 43 BF         sta DDRA3
00002Dr 2  8D 42 BF         sta DDRB3
000030r 2  A9 7F            lda #$7F        ; disable all interrupts
000032r 2  8D 4E BF         sta VIA3_IER
000035r 2  60               rts
000036r 2               
000036r 2               
000036r 1               .include "tpi.s"
000036r 2               TPI1_PRA   = TPI1 + 0
000036r 2               TPI1_PRB   = TPI1 + 1
000036r 2               TPI1_PRC   = TPI1 + 2
000036r 2               TPI1_DDRA  = TPI1 + 3
000036r 2               TPI1_DDRB  = TPI1 + 4
000036r 2               TPI1_DDRC  = TPI1 + 5
000036r 2               TPI1_CR    = TPI1 + 6
000036r 2               TPI1_AIR   = TPI1 + 7
000036r 2               
000036r 2               IDE1_PRA   = IDE1 + 0
000036r 2               IDE1_PRB   = IDE1 + 1
000036r 2               IDE1_PRC   = IDE1 + 2
000036r 2               IDE1_DDRA  = IDE1 + 3
000036r 2               IDE1_DDRB  = IDE1 + 4
000036r 2               IDE1_DDRC  = IDE1 + 5
000036r 2               IDE1_CR    = IDE1 + 6
000036r 2               IDE1_AIR   = IDE1 + 7
000036r 2               
000036r 2               TPI_INIT:
000036r 2  A9 00            lda #0          ; reset Bank Registers
000038r 2  8D 03 BF         sta TPI1_DDRA
00003Br 2  8D 04 BF         sta TPI1_DDRB
00003Er 2  A9 FF            lda #$FF        ; set Bank Register Ports to output
000040r 2  8D 00 BF         sta TPI1_PRA
000043r 2  8D 01 BF         sta TPI1_PRB
000046r 2  A9 A1            lda #$A1     ; CB and CA low, no priority, Port C Interrupt Mode
000048r 2  8D 06 BF         sta TPI1_CR
00004Br 2  A9 1F            lda #$1F        ; enable all interrupts
00004Dr 2  8D 05 BF         sta TPI1_DDRC
000050r 2  60               rts
000051r 2               
000051r 2               IDE_INIT:
000051r 2  A9 00            lda #0          ; reset all pins
000053r 2  8D 0B BF         sta IDE1_DDRA
000056r 2  8D 0C BF         sta IDE1_DDRB
000059r 2  8D 0D BF         sta IDE1_DDRC
00005Cr 2  A9 FF            lda #$FF        ; set Register Ports to output
00005Er 2  8D 08 BF         sta IDE1_PRA
000061r 2  8D 09 BF         sta IDE1_PRB
000064r 2  8D 0A BF         sta IDE1_PRC
000067r 2  60               rts
000068r 2               
000068r 1               .include "acia.s"
000068r 2               ; Registers ACIA1
000068r 2               COM1_DATA  = ACIA1 + 0
000068r 2               COM1_STAT  = ACIA1 + 1
000068r 2               COM1_CMD   = ACIA1 + 2
000068r 2               COM1_CTRL  = ACIA1 + 3
000068r 2               ; Registers ACIA2
000068r 2               COM2_DATA  = ACIA2 + 0
000068r 2               COM2_STAT  = ACIA2 + 1
000068r 2               COM2_CMD   = ACIA2 + 2
000068r 2               COM2_CTRL  = ACIA2 + 3
000068r 2               ; Registers ACIA3
000068r 2               COM3_DATA  = ACIA3 + 0
000068r 2               COM3_STAT  = ACIA3 + 1
000068r 2               COM3_CMD   = ACIA3 + 2
000068r 2               COM3_CTRL  = ACIA3 + 3
000068r 2               ; Registers ACIA4
000068r 2               COM4_DATA  = ACIA4 + 0
000068r 2               COM4_STAT  = ACIA4 + 1
000068r 2               COM4_CMD   = ACIA4 + 2
000068r 2               COM4_CTRL  = ACIA4 + 3
000068r 2               
000068r 2               ; ZeroPage Variable for TxReady-Check
000068r 2               ZP_WAIT = $E2
000068r 2               
000068r 2               ; STAT-REG bits (MSB left): IRQ | /DSR | /DCD | TDRE | RDRF | OVRN | FE | PE
000068r 2               ; IRQ: goes High on Interrupt
000068r 2               ; DSR = Data Set Ready (Low = Ready)
000068r 2               ; DCD = Data Carrier Detect (Low = detected)
000068r 2               ; TDRE = Transmitter Data Register Empty (1 = Empty)
000068r 2               ; RDRF = Receiver Data Register Full (1 = Full)
000068r 2               ; OVRN = Overrun (1 = Overrun occurred)
000068r 2               ; FE = Framing Error (1 = Framing Error detected)
000068r 2               ; PE = Parity Error (1 = Parity Error detected)
000068r 2               ; OVRN, FE, PE do not trigger interrupts
000068r 2               ; RESET-Value 0b0--10000
000068r 2               
000068r 2               ; CTL-REG bits (MSB left): SBN | WL1-WL0 | RCS | SBR3-SBR0
000068r 2               ; SBN = Stop Bit Number (0 = 1bit, 1 = 2bit, 0 = 1.5bit for WL 5 no parity, 1 = 1bit for WL 8 + parity)
000068r 2               ; WL = Word Length (00 = 8, 01 = 7, 10 = 6, 11 = 5)
000068r 2               ; RCS = Receiver Clock Source (0 = External Receiver Clock, 1 = Baud Rate Generator)
000068r 2               ; SBR = Sleceted Baud Rate
000068r 2               ; common SBR values: 1000 = 1200, 1110 = 9600, 1111 = 19.200
000068r 2               ; RESET-Value 0b00000000
000068r 2               
000068r 2               ; CMD-REG bits (MSB left): PMC1-PMC0 | PME | REM | TIC1-TIC0 | IRD | DTR
000068r 2               ; PMC = Parity Mode Control (00=odd, 01=even, 10=mark transmitted- check disabled, 11=space transmitted- check disabled)
000068r 2               ; PME = Parity Mode Enabled (0 = no parity generated - check disabled, 1 = parity enabled)
000068r 2               ; REM = Receiver Echo Mode (0=normal, 1=echo bits 2 and 3)
000068r 2               ; TIC = Transmitter Interrupt Control (00 = RTS high-transmitter disabled, 01 = RTS low-transmit interrupt enabled, 10 = RTS low- transmit interrupt disabled, 11 = RTS low, transmit interrupt desabled - transmit break on TxD)
000068r 2               ; IRD = Receiver Interrupt Request Disabled (0 = IRQ enabled (receiver), 1 = IRQ disabled (receiver))
000068r 2               ; DTR = Data Terminal Ready (0 = not ready, 1 = ready) (Enables Transmitter + Receiver)
000068r 2               ; RESET-Value 0b00000000
000068r 2               
000068r 2               ; Initializations
000068r 2               COM1_INIT:
000068r 2  A9 00            lda #$0         ; soft reset
00006Ar 2  8D 51 BF         sta COM1_STAT
00006Dr 2  A9 89            lda #%10001001  ; Enable Receive Interrupt, diable parity, enable Tx and Rx
00006Fr 2  8D 52 BF         sta COM1_CMD
000072r 2               ;   lda #%00011111  ; setup 8N1 communication at 19200 Baud
000072r 2  A9 1E            lda #%00011110  ; setup 8N1 communication at 9600 Baud
000074r 2  8D 53 BF         sta COM1_CTRL
000077r 2  60               rts
000078r 2               
000078r 2               COM2_INIT:
000078r 2  A9 00            lda #$0         ; soft reset
00007Ar 2  8D 55 BF         sta COM2_STAT
00007Dr 2  A9 89            lda #%10001001  ; Enable Receive Interrupt, diable parity, enable Tx and Rx
00007Fr 2  8D 56 BF         sta COM2_CMD
000082r 2               ;   lda #%00011111  ; setup 8N1 communication at 19200 Baud
000082r 2  A9 1E            lda #%00011110  ; setup 8N1 communication at 9600 Baud
000084r 2  8D 57 BF         sta COM2_CTRL
000087r 2  60               rts
000088r 2               
000088r 2               COM3_INIT:
000088r 2  A9 00            lda #$0         ; soft reset
00008Ar 2  8D 59 BF         sta COM3_STAT
00008Dr 2  A9 89            lda #%10001001  ; Enable Receive Interrupt, diable parity, enable Tx and Rx
00008Fr 2  8D 5A BF         sta COM3_CMD
000092r 2               ;   lda #%00011111  ; setup 8N1 communication at 19200 Baud
000092r 2  A9 1E            lda #%00011110  ; setup 8N1 communication at 9600 Baud
000094r 2  8D 5B BF         sta COM3_CTRL
000097r 2  60               rts
000098r 2               
000098r 2               COM4_INIT:
000098r 2  A9 00            lda #$0         ; soft reset
00009Ar 2  8D 5D BF         sta COM4_STAT
00009Dr 2  A9 89            lda #%10001001  ; Enable Receive Interrupt, diable parity, enable Tx and Rx
00009Fr 2  8D 5E BF         sta COM4_CMD
0000A2r 2               ;   lda #%00011111  ; setup 8N1 communication at 19200 Baud
0000A2r 2  A9 1E            lda #%00011110  ; setup 8N1 communication at 9600 Baud
0000A4r 2  8D 5F BF         sta COM4_CTRL
0000A7r 2  60               rts
0000A8r 2               
0000A8r 2               .segment "KERNEL_RAM"
000000r 2               
000000r 2               COM1_TRANSMIT:
000000r 2  48               pha
000001r 2               TX1READY:           ; check if ready to send next byte
000001r 2  AD 51 BF         lda COM1_STAT
000004r 2  85 E2            sta ZP_WAIT
000006r 2  4F E2 F8         BBR4 ZP_WAIT,TX1READY
000009r 2  68               pla
00000Ar 2  8D 50 BF         sta COM1_DATA
00000Dr 2  60               rts
00000Er 2               
00000Er 2               COM2_TRANSMIT:
00000Er 2  48               pha
00000Fr 2               TX2READY:           ; check if ready to send next byte
00000Fr 2  AD 55 BF         lda COM2_STAT
000012r 2  85 E2            sta ZP_WAIT
000014r 2  4F E2 F8         BBR4 ZP_WAIT,TX2READY
000017r 2  68               pla
000018r 2  8D 54 BF         sta COM2_DATA
00001Br 2  60               rts
00001Cr 2               
00001Cr 2               COM3_TRANSMIT:
00001Cr 2  48               pha
00001Dr 2               TX3READY:           ; check if ready to send next byte
00001Dr 2  AD 59 BF         lda COM3_STAT
000020r 2  85 E2            sta ZP_WAIT
000022r 2  4F E2 F8         BBR4 ZP_WAIT,TX3READY
000025r 2  68               pla
000026r 2  8D 58 BF         sta COM3_DATA
000029r 2  60               rts
00002Ar 2               
00002Ar 2               COM4_TRANSMIT:
00002Ar 2  48               pha
00002Br 2               TX4READY:           ; check if ready to send next byte
00002Br 2  AD 5D BF         lda COM4_STAT
00002Er 2  85 E2            sta ZP_WAIT
000030r 2  4F E2 F8         BBR4 ZP_WAIT,TX4READY
000033r 2  68               pla
000034r 2  8D 5C BF         sta COM4_DATA
000037r 2  60               rts
000038r 2               
000038r 1               .include "sid.s"
000038r 2               ; voice 1
000038r 2               CH1_FREQ_LO = SID + 0
000038r 2               CH1_FREQ_HI = SID + 1
000038r 2               CH1_PW_LO   = SID + 2
000038r 2               CH1_PW_HI   = SID + 3
000038r 2               CH1_CTRL    = SID + 4
000038r 2               CH1_ATK_DCY = SID + 5
000038r 2               CH1_STN_RLS = SID + 6
000038r 2               ; voice 2
000038r 2               CH2_FREQ_LO = SID + 7
000038r 2               CH2_FREQ_HI = SID + 8
000038r 2               CH2_PW_LO   = SID + 9
000038r 2               CH2_PW_HI   = SID + 10
000038r 2               CH2_CTRL    = SID + 11
000038r 2               CH2_ATK_DCY = SID + 12
000038r 2               CH2_STN_RLS = SID + 13
000038r 2               ; voice 3
000038r 2               CH3_FREQ_LO = SID + 14
000038r 2               CH3_FREQ_HI = SID + 15
000038r 2               CH3_PW_LO   = SID + 16
000038r 2               CH3_PW_HI   = SID + 17
000038r 2               CH3_CTRL    = SID + 18
000038r 2               CH3_ATK_DCY = SID + 19
000038r 2               CH3_STN_RLS = SID + 20
000038r 2               ; filter
000038r 2               SID_FC_LO   = SID + 21
000038r 2               SID_FC_HI   = SID + 22
000038r 2               SID_RES_FIL = SID + 23
000038r 2               SID_MOD_VOL = SID + 24
000038r 2               ; misc
000038r 2               SID_POTX    = SID + 25
000038r 2               SID_POTY    = SID + 26
000038r 2               SID_OS3_RND = SID + 27
000038r 2               SID_ENV3    = SID + 28
000038r 2               
000038r 1               
000038r 1               .include "kernel.s"
000038r 2               ; Kernel Functions for S65xx Computer System
000038r 2               ; Author: Synthron
000038r 2               ;
000038r 2               ; Ringbuffer Input Code by Ben Eater
000038r 2               ;
000038r 2               ;
000038r 2               
000038r 2               READ_PTR = $EC
000038r 2               WRITE_PTR = $ED
000038r 2               
000038r 2               .segment "INPUT_BUF"
000000r 2               
000000r 2  xx xx xx xx  INPUT_BUFFER:   .res $100
000004r 2  xx xx xx xx  
000008r 2  xx xx xx xx  
000100r 2               
000100r 2               
000100r 2               .segment "KERNEL_RAM"
000038r 2               
000038r 2               ; ----------------------------f--------------------------------------------
000038r 2               ; Input Buffer Code
000038r 2               ; ------------------------------------------------------------------------
000038r 2               
000038r 2               ; Initialize the circular input buffer
000038r 2               ; Modifies: flags, A
000038r 2               INIT_BUFFER:
000038r 2  A5 EC            lda READ_PTR
00003Ar 2  85 ED            sta WRITE_PTR
00003Cr 2  60               rts
00003Dr 2               
00003Dr 2               ; Write a character (from the A register) to the circular input buffer
00003Dr 2               ; Modifies: flags, X
00003Dr 2               WRITE_BUFFER:
00003Dr 2  A6 ED            ldx WRITE_PTR
00003Fr 2  9D rr rr         sta INPUT_BUFFER,x
000042r 2  E6 ED            inc WRITE_PTR
000044r 2  60               rts
000045r 2               
000045r 2               ; Read a character from the circular input buffer and put it in the A register
000045r 2               ; Modifies: flags, A, X
000045r 2               READ_BUFFER:
000045r 2  A6 EC            ldx READ_PTR
000047r 2  BD rr rr         lda INPUT_BUFFER,x
00004Ar 2  E6 EC            inc READ_PTR
00004Cr 2  60               rts
00004Dr 2               
00004Dr 2               ; Return (in A) the number of unread bytes in the circular input buffer
00004Dr 2               ; Modifies: flags, A
00004Dr 2               BUFFER_SIZE:
00004Dr 2  A5 ED            lda WRITE_PTR
00004Fr 2  38               sec
000050r 2  E5 EC            sbc READ_PTR
000052r 2  60               RTS
000053r 2               
000053r 2               ; ------------------------------------------------------------------------
000053r 2               ; Data Storage Code
000053r 2               ; ------------------------------------------------------------------------
000053r 2               
000053r 2               LOAD:
000053r 2  60               rts
000054r 2               
000054r 2               SAVE:
000054r 2  60               rts
000055r 2               
000055r 2               ; ------------------------------------------------------------------------
000055r 2               ; COM1 Default Char In Out Code
000055r 2               ; ------------------------------------------------------------------------
000055r 2               
000055r 2               ; Input a character from the serial interface.
000055r 2               ; On return, carry flag indicates whether a key was pressed
000055r 2               ; If a key was pressed, the key value will be in the A register
000055r 2               ;
000055r 2               ; Modifies: flags, A
000055r 2               CHRIN:
000055r 2  DA               phx
000056r 2  20 rr rr         jsr     BUFFER_SIZE
000059r 2  F0 09            beq     @no_keypressed
00005Br 2  20 rr rr         jsr     READ_BUFFER
00005Er 2  20 rr rr         jsr     CHROUT                  ; echo
000061r 2  FA               plx
000062r 2  38               sec
000063r 2  60               rts
000064r 2               @no_keypressed:
000064r 2  FA               plx
000065r 2  18               clc
000066r 2  60               rts
000067r 2               
000067r 2               
000067r 2               ; Output a character (from the A register) to the serial interface.
000067r 2               ;
000067r 2               ; Modifies: flags
000067r 2               CHROUT:
000067r 2  20 rr rr         jsr COM1_TRANSMIT
00006Ar 2  60               rts
00006Br 2               
00006Br 2               ; Output a string (Pointer at ZP $EC $ED)
00006Br 2               ;
00006Br 2               ; Modifies: A, Y, flags
00006Br 2               PRINT_MSG:
00006Br 2  5A               phy
00006Cr 2  A0 00            ldy #0              ; prepare Y register
00006Er 2               PRINT_LOOP:
00006Er 2  B1 EC            lda ($EC),y      ; get string vector, y indexed
000070r 2  F0 07            beq @end
000072r 2  20 rr rr         jsr COM1_TRANSMIT
000075r 2  C8               iny
000076r 2  4C rr rr         jmp PRINT_LOOP
000079r 2               @end:
000079r 2  7A               ply
00007Ar 2  60               rts
00007Br 2               
00007Br 2               ; ------------------------------------------------------------------------
00007Br 2               ; Page Handling
00007Br 2               ; ------------------------------------------------------------------------
00007Br 2               
00007Br 2               ; switch ROM bank and start executing at $C000
00007Br 2               ; new ROM bank indicated in A register
00007Br 2               ;
00007Br 2               ; Modifies: A
00007Br 2               SW_ROMBANK:
00007Br 2  8D 01 BF         sta TPI1_PRB
00007Er 2  4C 00 C0         jmp $C000
000081r 2               
000081r 2               
000081r 1               
000081r 1               .segment "CODE"
000019r 1               RESET:
000019r 1  A2 FF            ldx #$FF            ; Reset Stack Pointer
00001Br 1  9A               txs
00001Cr 1               
00001Cr 1               BOOT:
00001Cr 1  20 rr rr         jsr TPI_INIT        ; initialize banks and interrupt
00001Fr 1  20 rr rr         jsr COM1_INIT       ; initialize COM1 Serial
000022r 1  20 rr rr         jsr PIA_INIT        ; initialize LED port
000025r 1  58               cli                 ; clear interrupt disable flag
000026r 1               
000026r 1               ; print Boot Messagr
000026r 1  A9 rr 85 EC      cpt BOOT_MSG
00002Ar 1  A9 rr 85 ED  
00002Er 1  20 rr rr         jsr PRINT_MSG
000031r 1               
000031r 1               ; print Kernel Transfer Messagr
000031r 1  A9 rr 85 EC      cpt BOOT_TKERN
000035r 1  A9 rr 85 ED  
000039r 1  20 rr rr         jsr PRINT_MSG
00003Cr 1               
00003Cr 1               
00003Cr 1  A2 rr            ldx #<EHBASIC_TABLE_END
00003Er 1               PREPRAM:
00003Er 1  BD rr rr         lda EHBASIC_TABLE_START,x
000041r 1  9D 00 08         sta ccflag,x
000044r 1  CA               dex
000045r 1  F0 F7            beq PREPRAM
000047r 1               
000047r 1               ;
000047r 1               ; Transfer Kernel Code from ROM to RAM
000047r 1               ; Kernel in ROM is Page Aligned, so whole pages will be copied,
000047r 1               ; regardless whether useful or not
000047r 1               ;
000047r 1               CPY_KERNEL:
000047r 1  A9 00            lda #$00            ; Kernel sits at C000 in ROM, get start address
000049r 1  85 00            sta $00
00004Br 1  A9 C0            lda #$C0
00004Dr 1  85 01            sta $01
00004Fr 1  A9 00            lda #0              ; Copy Kernel code to RAM starting at 0300
000051r 1  85 02            sta $02
000053r 1  A9 03            lda #3
000055r 1  85 03            sta $03
000057r 1  A2 03            ldx #3              ; load last kernel page into X, current assumption is only one page
000059r 1  A0 00            ldy #0              ; reset Y
00005Br 1               CPY_KERNEL_LOOP:
00005Br 1  B1 00            lda ($00),y         ; iterate through KERNEL page and copy into RAM
00005Dr 1  91 02            sta ($02),y
00005Fr 1  C8               iny
000060r 1  D0 F9            bne CPY_KERNEL_LOOP ; check if Y had rollover (256 bytes copied, Y back to 0)
000062r 1  E4 03            cpx $03             ; check if last page reached
000064r 1  F0 07            beq @end            ; done when Zero Flag Set (X = value)
000066r 1  E6 03            inc $03             ; else increment destination page pointer
000068r 1  E6 01            inc $01             ; as well as source page pointer
00006Ar 1  4C rr rr         jmp CPY_KERNEL_LOOP ; start copying next page
00006Dr 1               @end:
00006Dr 1               
00006Dr 1               ; print Kernel Transfer done
00006Dr 1  A9 rr 85 EC      cpt MSG_DONE
000071r 1  A9 rr 85 ED  
000075r 1  20 rr rr         jsr PRINT_MSG
000078r 1               
000078r 1               ; print WozMon Start Message
000078r 1  A9 rr 85 EC      cpt MSG_MONITOR
00007Cr 1  A9 rr 85 ED  
000080r 1  20 rr rr         jsr PRINT_MSG
000083r 1               
000083r 1               MAIN_LOOP:
000083r 1  4C rr rr         jmp RESET_MONITOR
000086r 1  4C rr rr         jmp MAIN_LOOP
000089r 1               
000089r 1               .segment "KERNEL_RAM"
000081r 1               
000081r 1               ISR:
000081r 1                   ; for now just assume COM1 is the only Interrupt Source
000081r 1                   ; Other sources will be added later and checked during ISR runtime
000081r 1  48               pha
000082r 1  DA               phx
000083r 1  AD 51 BF         lda COM1_STAT       ; clear IRQ from ACIA
000086r 1  AD 07 BF         lda TPI1_AIR        ; clear IRQ from TPI
000089r 1  AD 50 BF         lda COM1_DATA       ; get received character
00008Cr 1  20 rr rr         jsr WRITE_BUFFER    ; write character into Input buffer
00008Fr 1  FA               plx
000090r 1  68               pla
000091r 1  40               rti
000092r 1               NMI:
000092r 1  40               rti
000093r 1               
000093r 1               .segment "JP_TBLE"
000000r 1               
000000r 1               LBL_XX00:               ; start EhBASIC
000000r 1  A9 01            lda #1
000002r 1  4C rr rr         jmp SW_ROMBANK
000005r 1               LBL_XX05:               ; start MS BASIC CDM2
000005r 1  A9 02            lda #2
000007r 1  4C rr rr         jmp SW_ROMBANK
00000Ar 1               
00000Ar 1               .include "wozmon.s"
00000Ar 2               ; Port from Ben Eater
00000Ar 2               ; configured to work side by side with ehBASIC
00000Ar 2               ;
00000Ar 2               ; Adjusted ZP variables from $24-$2B to $E4-$EB
00000Ar 2               ; adjusted comically large tab spaces
00000Ar 2               
00000Ar 2               
00000Ar 2               XAML    = $E4           ; Last "opened" location Low
00000Ar 2               XAMH    = $E5           ; Last "opened" location High
00000Ar 2               STL     = $E6           ; Store address Low
00000Ar 2               STH     = $E7           ; Store address High
00000Ar 2               L       = $E8           ; Hex value parsing Low
00000Ar 2               H       = $E9           ; Hex value parsing High
00000Ar 2               YSAV    = $EA           ; Used to see if hex value is given
00000Ar 2               MODE    = $EB           ; $00=XAM, $7F=STOR, $AE=BLOCK XAM
00000Ar 2               
00000Ar 2               IN      = $0200         ; Input buffer
00000Ar 2               
00000Ar 2               .segment "MONITOR"
000000r 2               
000000r 2               RESET_MONITOR:
000000r 2  D8               CLD                 ; Clear decimal arithmetic mode.
000001r 2               ;    LDA #$1F            ; 8-N-1, 19200 bps
000001r 2               ;    LDY #$89            ; No parity, no echo, rx interrupts.
000001r 2               
000001r 2               NOTCR:
000001r 2  C9 08            CMP #$08            ; Backspace key?
000003r 2  F0 13            BEQ BACKSPACE       ; Yes.
000005r 2  C9 1B            CMP #$1B            ; ESC?
000007r 2  F0 03            BEQ ESCAPE          ; Yes.
000009r 2  C8               INY                 ; Advance text index.
00000Ar 2  10 0F            BPL NEXTCHAR        ; Auto ESC if line longer than 127.
00000Cr 2               
00000Cr 2               ESCAPE:
00000Cr 2               ;    LDA #$5C            ; "\".
00000Cr 2               ;    JSR ECHO            ; Output it.
00000Cr 2               
00000Cr 2               GETLINE:
00000Cr 2  A9 0D            LDA #$0D            ; Send CR
00000Er 2  20 rr rr         JSR ECHO
000011r 2  A9 0A            LDA #$0A            ; Send LF
000013r 2  20 rr rr         JSR ECHO
000016r 2               
000016r 2  A0 01            LDY #$01            ; Initialize text index.
000018r 2               BACKSPACE:
000018r 2  88               DEY                 ; Back up text index.
000019r 2  30 F1            BMI GETLINE         ; Beyond start of line, reinitialize.
00001Br 2               
00001Br 2               NEXTCHAR:
00001Br 2  20 rr rr         JSR CHRIN
00001Er 2  90 FB            BCC NEXTCHAR
000020r 2  99 00 02         STA IN,Y            ; Add to text buffer.
000023r 2  C9 0D            CMP #$0D            ; CR?
000025r 2  D0 DA            BNE NOTCR           ; No.
000027r 2               
000027r 2  A0 FF            LDY #$FF            ; Reset text index.
000029r 2  A9 00            LDA #$00            ; For XAM mode.
00002Br 2  AA               TAX                 ; X=0.
00002Cr 2               SETBLOCK:
00002Cr 2  0A               ASL
00002Dr 2               SETSTOR:
00002Dr 2  0A               ASL                 ; Leaves $7B if setting STOR mode.
00002Er 2               SETMODE:
00002Er 2  85 EB            STA MODE            ; $00 = XAM, $74 = STOR, $B8 = BLOK XAM.
000030r 2               BLSKIP:
000030r 2  C8               INY                 ; Advance text index.
000031r 2               NEXTITEM:
000031r 2  B9 00 02         LDA IN,Y            ; Get character.
000034r 2  C9 0D            CMP #$0D            ; CR?
000036r 2  F0 D4            BEQ GETLINE         ; Yes, done this line.
000038r 2  C9 2E            CMP #$2E            ; "."?
00003Ar 2  90 F4            BCC BLSKIP          ; Skip delimiter.
00003Cr 2  F0 EE            BEQ SETBLOCK        ; Set BLOCK XAM mode.
00003Er 2  C9 3A            CMP #$3A            ; ":"?
000040r 2  F0 EB            BEQ SETSTOR         ; Yes, set STOR mode.
000042r 2  C9 52            CMP #$52            ; "R"?
000044r 2  F0 3B            BEQ RUNPROG         ; Yes, run user program.
000046r 2  86 E8            STX L               ; $00 -> L.
000048r 2  86 E9            STX H               ;    and H.
00004Ar 2  84 EA            STY YSAV            ; Save Y for comparison
00004Cr 2               
00004Cr 2               NEXTHEX:
00004Cr 2  B9 00 02         LDA IN,Y            ; Get character for hex test.
00004Fr 2  49 30            EOR #$30            ; Map digits to $0-9.
000051r 2  C9 0A            CMP #$0A            ; Digit?
000053r 2  90 06            BCC DIG             ; Yes.
000055r 2  69 88            ADC #$88            ; Map letter "A"-"F" to $FA-FF.
000057r 2  C9 FA            CMP #$FA            ; Hex letter?
000059r 2  90 11            BCC NOTHEX          ; No, character not hex.
00005Br 2               DIG:
00005Br 2  0A               ASL
00005Cr 2  0A               ASL                 ; Hex digit to MSD of A.
00005Dr 2  0A               ASL
00005Er 2  0A               ASL
00005Fr 2               
00005Fr 2  A2 04            LDX #$04            ; Shift count.
000061r 2               HEXSHIFT:
000061r 2  0A               ASL                 ; Hex digit left, MSB to carry.
000062r 2  26 E8            ROL L               ; Rotate into LSD.
000064r 2  26 E9            ROL H               ; Rotate into MSD's.
000066r 2  CA               DEX                 ; Done 4 shifts?
000067r 2  D0 F8            BNE HEXSHIFT        ; No, loop.
000069r 2  C8               INY                 ; Advance text index.
00006Ar 2  D0 E0            BNE NEXTHEX         ; Always taken. Check next character for hex.
00006Cr 2               
00006Cr 2               NOTHEX:
00006Cr 2  C4 EA            CPY YSAV            ; Check if L, H empty (no hex digits).
00006Er 2  F0 9C            BEQ ESCAPE          ; Yes, generate ESC sequence.
000070r 2               
000070r 2  24 EB            BIT MODE            ; Test MODE byte.
000072r 2  50 10            BVC NOTSTOR         ; B6=0 is STOR, 1 is XAM and BLOCK XAM.
000074r 2               
000074r 2  A5 E8            LDA L               ; LSD's of hex data.
000076r 2  81 E6            STA (STL,X)         ; Store current 'store index'.
000078r 2  E6 E6            INC STL             ; Increment store index.
00007Ar 2  D0 B5            BNE NEXTITEM        ; Get next item (no carry).
00007Cr 2  E6 E7            INC STH             ; Add carry to 'store index' high order.
00007Er 2               TONEXTITEM:
00007Er 2  4C rr rr         JMP NEXTITEM        ; Get next command item.
000081r 2               
000081r 2               RUNPROG:
000081r 2  6C E4 00         JMP (XAML)          ; Run at current XAM index.
000084r 2               
000084r 2               NOTSTOR:
000084r 2  30 30            BMI XAMNEXT         ; B7 = 0 for XAM, 1 for BLOCK XAM.
000086r 2               
000086r 2  A2 02            LDX #$02            ; Byte count.
000088r 2               SETADR:
000088r 2  B5 E7            LDA L-1,X           ; Copy hex data to
00008Ar 2  95 E5            STA STL-1,X         ;  'store index'.
00008Cr 2  95 E3            STA XAML-1,X        ; And to 'XAM index'.
00008Er 2  CA               DEX                 ; Next of 2 bytes.
00008Fr 2  D0 F7            BNE SETADR          ; Loop unless X = 0.
000091r 2               
000091r 2               NXTPRNT:
000091r 2  D0 19            BNE PRDATA          ; NE means no address to print.
000093r 2  A9 0D            LDA #$0D            ; CR.
000095r 2  20 rr rr         JSR ECHO            ; Output it.
000098r 2  A9 0A            LDA #$0A            ; LF.
00009Ar 2  20 rr rr         JSR ECHO            ; Output it.
00009Dr 2  A5 E5            LDA XAMH            ; 'Examine index' high-order byte.
00009Fr 2  20 rr rr         JSR PRBYTE          ; Output it in hex format.
0000A2r 2  A5 E4            LDA XAML            ; Low-order 'examine index' byte.
0000A4r 2  20 rr rr         JSR PRBYTE          ; Output it in hex format.
0000A7r 2  A9 3A            LDA #$3A            ; ":".
0000A9r 2  20 rr rr         JSR ECHO            ; Output it.
0000ACr 2               
0000ACr 2               PRDATA:
0000ACr 2  A9 20            LDA #$20            ; Blank.
0000AEr 2  20 rr rr         JSR ECHO            ; Output it.
0000B1r 2  A1 E4            LDA (XAML,X)        ; Get data byte at 'examine index'.
0000B3r 2  20 rr rr         JSR PRBYTE          ; Output it in hex format.
0000B6r 2               XAMNEXT:
0000B6r 2  86 EB            STX MODE            ; 0 -> MODE (XAM mode).
0000B8r 2  A5 E4            LDA XAML
0000BAr 2  C5 E8            CMP L               ; Compare 'examine index' to hex data.
0000BCr 2  A5 E5            LDA XAMH
0000BEr 2  E5 E9            SBC H
0000C0r 2  B0 BC            BCS TONEXTITEM      ; Not less, so no more data to output.
0000C2r 2               
0000C2r 2  E6 E4            INC XAML
0000C4r 2  D0 02            BNE MOD8CHK         ; Increment 'examine index'.
0000C6r 2  E6 E5            INC XAMH
0000C8r 2               
0000C8r 2               MOD8CHK:
0000C8r 2  A5 E4            LDA XAML            ; Check low-order 'examine index' byte
0000CAr 2  29 07            AND #$07            ; For MOD 8 = 0
0000CCr 2  10 C3            BPL NXTPRNT         ; Always taken.
0000CEr 2               
0000CEr 2               PRBYTE:
0000CEr 2  48               PHA                 ; Save A for LSD.
0000CFr 2  4A               LSR
0000D0r 2  4A               LSR
0000D1r 2  4A               LSR                 ; MSD to LSD position.
0000D2r 2  4A               LSR
0000D3r 2  20 rr rr         JSR PRHEX           ; Output hex digit.
0000D6r 2  68               PLA                 ; Restore A.
0000D7r 2               
0000D7r 2               PRHEX:
0000D7r 2  29 0F            AND #$0F            ; Mask LSD for hex print.
0000D9r 2  09 30            ORA #$30            ; Add "0".
0000DBr 2  C9 3A            CMP #$3A            ; Digit?
0000DDr 2  90 02            BCC ECHO            ; Yes, output it.
0000DFr 2  69 06            ADC #$06            ; Add offset for letter.
0000E1r 2               
0000E1r 2               ECHO:
0000E1r 2  20 rr rr         JSR COM1_TRANSMIT   ; Output character
0000E4r 2  60               RTS                 ; Return.
0000E5r 2               
0000E5r 1               
0000E5r 1               .segment "RODATA"
0000A8r 1               
0000A8r 1  48 65 6C 6C  HELLO_WORLD: .asciiz "Hello World\n"
0000ACr 1  6F 20 57 6F  
0000B0r 1  72 6C 64 5C  
0000B6r 1  57 65 6C 63  BOOT_MSG:    .asciiz "Welcome to the S65xx Computer System!\n\n"
0000BAr 1  6F 6D 65 20  
0000BEr 1  74 6F 20 74  
0000E0r 1  54 72 61 6E  BOOT_TKERN:  .asciiz "Transfer KERNEL to RAM... "
0000E4r 1  73 66 65 72  
0000E8r 1  20 4B 45 52  
0000FBr 1  53 74 61 72  MSG_MONITOR: .asciiz "Starting up WozMon:\n"
0000FFr 1  74 69 6E 67  
000103r 1  20 75 70 20  
000111r 1  64 6F 6E 65  MSG_DONE:    .asciiz "done!\n"
000115r 1  21 5C 6E 00  
000119r 1               
000119r 1               EHBASIC_TABLE_START:
000119r 1  00               .byte 0             ; dummy bytes for padding
00011Ar 1  00               .byte 0
00011Br 1  00               .byte 0
00011Cr 1  00 C0            .word $C000         ; Control-C function vector, currently restart BASIC
00011Er 1  rr rr            .word CHRIN         ; Character In function pointer
000120r 1  rr rr            .word CHROUT        ; Character Out function pointer
000122r 1  00 C0            .word $C000         ; LOAD function pointer, currently restart BASIC
000124r 1  00 C0            .word $C000         ; SAVE function pointer, currently restart BASIC
000126r 1               EHBASIC_TABLE_END:
000126r 1               
000126r 1               .segment "VECTORS"
000000r 1  rr rr        .word NMI
000002r 1  rr rr        .word RESET
000004r 1  rr rr        .word ISR
000006r 1               
000006r 1               .segment "EHBASIC"
000000r 1               ; input vector          $0805 $0806
000000r 1               ; output vector         $0807 $0808
000000r 1               ; load vector           $0809 $080A
000000r 1               ; save vector           $080B $080C
000000r 1               .include "ehbasic.s"
000000r 2               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.23
000000r 2               
000000r 2               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 2               
000000r 2               ; 2.00      new revision numbers start here
000000r 2               ; 2.01      fixed LCASE$() and UCASE$()
000000r 2               ; 2.02      new get value routine done
000000r 2               ; 2.03      changed RND() to galoise method
000000r 2               ; 2.04      fixed SPC()
000000r 2               ; 2.05      new get value routine fixed
000000r 2               ; 2.06      changed USR() code
000000r 2               ; 2.07      fixed STR$()
000000r 2               ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09      fixed RND()
000000r 2               ; 2.10      integrated missed changes from an earlier version
000000r 2               ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21      fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22      fixed RND() breaking the get byte routine
000000r 2               ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
000000r 2               ;              (bugsnquirks.txt notes 2, 4 and 5)
000000r 2               ;              tabs converted to spaces, tabwidth=6
000000r 2               ; 2.22p2    fixed can't continue error on 1st statement after direct mode
000000r 2               ;              changed INPUT to throw "break in line ##" on empty line input
000000r 2               ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
000000r 2               ;              fix provided by github user mgcaret
000000r 2               ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
000000r 2               ;              fixed FALSE stored to a variable after a string compare
000000r 2               ;                 is > 0 and < 1E-16
000000r 2               ;              added additional stack floor protection for background interrupts
000000r 2               ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
000000r 2               ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
000000r 2               ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
000000r 2               ;              sanity check for RAM top allows values below RAM base
000000r 2               ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
000000r 2               ;              1-7 coresponds to the bug# in the thread
000000r 2               ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
000000r 2               ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
000000r 2               ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
000000r 2               ;      5.5     garbage collection may cause an overlap with temporary strings
000000r 2               ;      5.6     floating point multiply rounding bug
000000r 2               ;      5.7     VAL() may cause string variables to be trashed
000000r 2               ; 2.23      S65xx Port by Synthron
000000r 2               ;             - refactor to compile with ca65
000000r 2               ;             - port to S65xx Computer System
000000r 2               ;             (cleanup ZP space)
000000r 2               ;             - Investigate and simplify Decssp1 addresses?
000000r 2               
000000r 2               ; zero page use ..
000000r 2               
000000r 2               ; the following locations are bulk initialized from StrTab at LAB_GMEM
000000r 2               LAB_WARM          = $00       ; BASIC warm start entry point
000000r 2               Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
000000r 2               Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp            = $0A       ; USR function JMP address
000000r 2               Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
000000r 2               Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
000000r 2               Nullct            = $0D       ; nulls output after each line
000000r 2               TPos              = $0E       ; BASIC terminal position byte
000000r 2               TWidth            = $0F       ; BASIC terminal width byte
000000r 2               Iclim             = $10       ; input column limit
000000r 2               Itempl            = $11       ; temporary integer low byte
000000r 2               Itemph            = Itempl+1  ; temporary integer high byte
000000r 2               ; end bulk initialize from StrTab at LAB_GMEM
000000r 2               
000000r 2               nums_1            = Itempl    ; number to bin/hex string convert MSB
000000r 2               nums_2            = nums_1+1  ; number to bin/hex string convert
000000r 2               nums_3            = nums_1+2  ; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc             = $5B       ; search character
000000r 2               Temp3             = Srchc     ; temp byte used in number routines
000000r 2               Scnquo            = $5C       ; scan-between-quotes flag
000000r 2               Asrch             = Scnquo    ; alt search character
000000r 2               
000000r 2               XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr             = $5D       ; input buffer pointer
000000r 2               Dimcnt            = Ibptr     ; # of dimensions
000000r 2               Tindx             = Ibptr     ; token index
000000r 2               
000000r 2               Defdim            = $5E       ; default DIM flag
000000r 2               Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
000000r 2               Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd            = $60       ; garbage collected flag
000000r 2               Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag             = $63       ; comparison evaluation flag
000000r 2               
000000r 2               TabSiz            = $64       ; TAB step size (was input flag)
000000r 2               
000000r 2               next_s            = $65       ; next descriptor stack address
000000r 2               
000000r 2                                             ; these two bytes form a word pointer to the item
000000r 2                                             ; currently on top of the descriptor stack
000000r 2               last_sl           = $66       ; last descriptor stack address low byte
000000r 2               last_sh           = $67       ; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk            = $68       ; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ;                 = $70       ; End of descriptor stack
000000r 2               
000000r 2               ut1_pl            = $71       ; utility pointer 1 low byte
000000r 2               ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
000000r 2               ut2_pl            = $73       ; utility pointer 2 low byte
000000r 2               ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2            = ut1_pl    ; temp byte for block move
000000r 2               
000000r 2               FACt_1            = $75       ; FAC temp mantissa1
000000r 2               FACt_2            = FACt_1+1  ; FAC temp mantissa2
000000r 2               FACt_3            = FACt_2+1  ; FAC temp mantissa3
000000r 2               
000000r 2               dims_l            = FACt_2    ; array dimension size low byte
000000r 2               dims_h            = FACt_3    ; array dimension size high byte
000000r 2               
000000r 2               TempB             = $78       ; temp page 0 byte
000000r 2               
000000r 2               Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
000000r 2               Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
000000r 2               Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
000000r 2               Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
000000r 2               Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
000000r 2               Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
000000r 2               Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
000000r 2               Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
000000r 2               Sstorl            = $81       ; string storage low byte     (String storage (moving down))
000000r 2               Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
000000r 2               Sutill            = $83       ; string utility ptr low byte
000000r 2               Sutilh            = Sutill+1  ; string utility ptr high byte
000000r 2               Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
000000r 2               Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
000000r 2               Clinel            = $87       ; current line low byte       (Basic line number)
000000r 2               Clineh            = Clinel+1  ; current line high byte      (Basic line number)
000000r 2               Blinel            = $89       ; break line low byte         (Previous Basic line number)
000000r 2               Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
000000r 2               
000000r 2               Cpntrl            = $8B       ; continue pointer low byte
000000r 2               Cpntrh            = Cpntrl+1  ; continue pointer high byte
000000r 2               
000000r 2               Dlinel            = $8D       ; current DATA line low byte
000000r 2               Dlineh            = Dlinel+1  ; current DATA line high byte
000000r 2               
000000r 2               Dptrl             = $8F       ; DATA pointer low byte
000000r 2               Dptrh             = Dptrl+1   ; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl            = $91       ; read pointer low byte
000000r 2               Rdptrh            = Rdptrl+1  ; read pointer high byte
000000r 2               
000000r 2               Varnm1            = $93       ; current var name 1st byte
000000r 2               Varnm2            = Varnm1+1  ; current var name 2nd byte
000000r 2               
000000r 2               Cvaral            = $95       ; current var address low byte
000000r 2               Cvarah            = Cvaral+1  ; current var address high byte
000000r 2               
000000r 2               Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
000000r 2               Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1             = Frnxtl    ; temp line index
000000r 2               
000000r 2               Lvarpl            = Frnxtl    ; let var pointer low byte
000000r 2               Lvarph            = Frnxth    ; let var pointer high byte
000000r 2               
000000r 2               prstk             = $99       ; precedence stacked flag
000000r 2               
000000r 2               comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
000000r 2                                             ; bit 2 set if >
000000r 2                                             ; bit 1 set if =
000000r 2                                             ; bit 0 set if <
000000r 2               
000000r 2               func_l            = $9C       ; function pointer low byte
000000r 2               func_h            = func_l+1  ; function pointer high byte
000000r 2               
000000r 2               garb_l            = func_l    ; garbage collection working pointer low byte
000000r 2               garb_h            = func_h    ; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l            = $9E       ; string descriptor_2 pointer low byte
000000r 2               des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step            = $A0       ; garbage collect step size
000000r 2               
000000r 2               Fnxjmp            = $A1       ; jump vector for functions
000000r 2               Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
000000r 2               Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
000000r 2               
000000r 2               g_indx            = Fnxjpl    ; garbage collect temp index
000000r 2               
000000r 2               FAC2_r            = $A3       ; FAC2 rounding byte
000000r 2               
000000r 2               Adatal            = $A4       ; array data pointer low byte
000000r 2               Adatah            = Adatal+1  ; array data pointer high  byte
000000r 2               
000000r 2               Nbendl            = Adatal    ; new block end pointer low byte
000000r 2               Nbendh            = Adatah    ; new block end pointer high  byte
000000r 2               
000000r 2               Obendl            = $A6       ; old block end pointer low byte
000000r 2               Obendh            = Obendl+1  ; old block end pointer high  byte
000000r 2               
000000r 2               numexp            = $A8       ; string to float number exponent count
000000r 2               expcnt            = $A9       ; string to float exponent count
000000r 2               
000000r 2               numbit            = numexp    ; bit count for array element calculations
000000r 2               
000000r 2               numdpf            = $AA       ; string to float decimal point flag
000000r 2               expneg            = $AB       ; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl            = numdpf    ; array start pointer low byte
000000r 2               Astrth            = expneg    ; array start pointer high  byte
000000r 2               
000000r 2               Histrl            = numdpf    ; highest string low byte
000000r 2               Histrh            = expneg    ; highest string high  byte
000000r 2               
000000r 2               Baslnl            = numdpf    ; BASIC search line pointer low byte
000000r 2               Baslnh            = expneg    ; BASIC search line pointer high  byte
000000r 2               
000000r 2               Fvar_l            = numdpf    ; find/found variable pointer low byte
000000r 2               Fvar_h            = expneg    ; find/found variable pointer high  byte
000000r 2               
000000r 2               Ostrtl            = numdpf    ; old block start pointer low byte
000000r 2               Ostrth            = expneg    ; old block start pointer high  byte
000000r 2               
000000r 2               Vrschl            = numdpf    ; variable search pointer low byte
000000r 2               Vrschh            = expneg    ; variable search pointer high  byte
000000r 2               
000000r 2               FAC1_e            = $AC       ; FAC1 exponent
000000r 2               FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
000000r 2               FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
000000r 2               FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
000000r 2               FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln            = FAC1_e    ; string length
000000r 2               str_pl            = FAC1_1    ; string pointer low byte
000000r 2               str_ph            = FAC1_2    ; string pointer high byte
000000r 2               
000000r 2               des_pl            = FAC1_2    ; string descriptor pointer low byte
000000r 2               des_ph            = FAC1_3    ; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l            = FAC1_3    ; MID$ string temp length byte
000000r 2               
000000r 2               negnum            = $B1       ; string to float eval -ve flag
000000r 2               numcon            = $B1       ; series evaluation constant count
000000r 2               
000000r 2               FAC1_o            = $B2       ; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e            = $B3       ; FAC2 exponent
000000r 2               FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
000000r 2               FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
000000r 2               FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
000000r 2               FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r            = $B9       ; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l           = FAC_sc    ; string start pointer low byte
000000r 2               ssptr_h           = FAC1_r    ; string start pointer high byte
000000r 2               
000000r 2               sdescr            = FAC_sc    ; string descriptor pointer
000000r 2               
000000r 2               csidx             = $BA       ; line crunch save index
000000r 2               Asptl             = csidx     ; array size/pointer low byte
000000r 2               Aspth             = $BB       ; array size/pointer high byte
000000r 2               
000000r 2               Btmpl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Btmph             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Cptrh             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Sendh             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
000000r 2               LAB_IGBY          = $BC       ; get next BASIC byte subroutine
000000r 2               
000000r 2               LAB_GBYT          = $C2       ; get current BASIC byte subroutine
000000r 2               Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               ;                 = $D7       ; end of get BASIC char subroutine
000000r 2               ; end bulk initialize from LAB_2CEE at LAB_2D4E
000000r 2               
000000r 2               Rbyte4            = $D8       ; extra PRNG byte
000000r 2               Rbyte1            = Rbyte4+1  ; most significant PRNG byte
000000r 2               Rbyte2            = Rbyte4+2  ; middle PRNG byte
000000r 2               Rbyte3            = Rbyte4+3  ; least significant PRNG byte
000000r 2               
000000r 2               NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
000000r 2                                             ; bit function
000000r 2                                             ; === ========
000000r 2                                             ; 7   interrupt enabled
000000r 2                                             ; 6   interrupt setup
000000r 2                                             ; 5   interrupt happened
000000r 2               ;                 = $DD       ; NMI handler addr low byte
000000r 2               ;                 = $DE       ; NMI handler addr high byte
000000r 2               IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
000000r 2               ;                 = $E0       ; IRQ handler addr low byte
000000r 2               ;                 = $E1       ; IRQ handler addr high byte
000000r 2               
000000r 2               ; *** removed unused comments for $DE-$E1
000000r 2               
000000r 2               ;                 = $E2       ; unused
000000r 2               ;                 = $E3       ; unused
000000r 2               ;                 = $E4       ; unused
000000r 2               ;                 = $E5       ; unused
000000r 2               ;                 = $E6       ; unused
000000r 2               ;                 = $E7       ; unused
000000r 2               ;                 = $E8       ; unused
000000r 2               ;                 = $E9       ; unused
000000r 2               ;                 = $EA       ; unused
000000r 2               ;                 = $EB       ; unused
000000r 2               ;                 = $EC       ; unused
000000r 2               ;                 = $ED       ; unused
000000r 2               ;                 = $EE       ; unused
000000r 2               
000000r 2               Decss             = $EF       ; number to decimal string start
000000r 2               Decssp1           = Decss+1   ; number to decimal string start
000000r 2               
000000r 2               ;                 = $FF       ; decimal string end
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END            = $80             ; END token
000000r 2               TK_FOR            = TK_END+1        ; FOR token
000000r 2               TK_NEXT           = TK_FOR+1        ; NEXT token
000000r 2               TK_DATA           = TK_NEXT+1       ; DATA token
000000r 2               TK_INPUT          = TK_DATA+1       ; INPUT token
000000r 2               TK_DIM            = TK_INPUT+1      ; DIM token
000000r 2               TK_READ           = TK_DIM+1        ; READ token
000000r 2               TK_LET            = TK_READ+1       ; LET token
000000r 2               TK_DEC            = TK_LET+1        ; DEC token
000000r 2               TK_GOTO           = TK_DEC+1        ; GOTO token
000000r 2               TK_RUN            = TK_GOTO+1       ; RUN token
000000r 2               TK_IF             = TK_RUN+1        ; IF token
000000r 2               TK_RESTORE        = TK_IF+1         ; RESTORE token
000000r 2               TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
000000r 2               TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
000000r 2               TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
000000r 2               TK_RETURN         = TK_RETNMI+1     ; RETURN token
000000r 2               TK_REM            = TK_RETURN+1     ; REM token
000000r 2               TK_STOP           = TK_REM+1        ; STOP token
000000r 2               TK_ON             = TK_STOP+1       ; ON token
000000r 2               TK_NULL           = TK_ON+1         ; NULL token
000000r 2               TK_INC            = TK_NULL+1       ; INC token
000000r 2               TK_WAIT           = TK_INC+1        ; WAIT token
000000r 2               TK_LOAD           = TK_WAIT+1       ; LOAD token
000000r 2               TK_SAVE           = TK_LOAD+1       ; SAVE token
000000r 2               TK_DEF            = TK_SAVE+1       ; DEF token
000000r 2               TK_POKE           = TK_DEF+1        ; POKE token
000000r 2               TK_DOKE           = TK_POKE+1       ; DOKE token
000000r 2               TK_CALL           = TK_DOKE+1       ; CALL token
000000r 2               TK_DO             = TK_CALL+1       ; DO token
000000r 2               TK_LOOP           = TK_DO+1         ; LOOP token
000000r 2               TK_PRINT          = TK_LOOP+1       ; PRINT token
000000r 2               TK_CONT           = TK_PRINT+1      ; CONT token
000000r 2               TK_LIST           = TK_CONT+1       ; LIST token
000000r 2               TK_CLEAR          = TK_LIST+1       ; CLEAR token
000000r 2               TK_NEW            = TK_CLEAR+1      ; NEW token
000000r 2               TK_WIDTH          = TK_NEW+1        ; WIDTH token
000000r 2               TK_GET            = TK_WIDTH+1      ; GET token
000000r 2               TK_SWAP           = TK_GET+1        ; SWAP token
000000r 2               TK_BITSET         = TK_SWAP+1       ; BITSET token
000000r 2               TK_BITCLR         = TK_BITSET+1     ; BITCLR token
000000r 2               TK_IRQ            = TK_BITCLR+1     ; IRQ token
000000r 2               TK_NMI            = TK_IRQ+1        ; NMI token
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB            = TK_NMI+1        ; TAB token
000000r 2               TK_ELSE           = TK_TAB+1        ; ELSE token
000000r 2               TK_TO             = TK_ELSE+1       ; TO token
000000r 2               TK_FN             = TK_TO+1         ; FN token
000000r 2               TK_SPC            = TK_FN+1         ; SPC token
000000r 2               TK_THEN           = TK_SPC+1        ; THEN token
000000r 2               TK_NOT            = TK_THEN+1       ; NOT token
000000r 2               TK_STEP           = TK_NOT+1        ; STEP token
000000r 2               TK_UNTIL          = TK_STEP+1       ; UNTIL token
000000r 2               TK_WHILE          = TK_UNTIL+1      ; WHILE token
000000r 2               TK_OFF            = TK_WHILE+1      ; OFF token
000000r 2               
000000r 2               ; opperator tokens
000000r 2               
000000r 2               TK_PLUS           = TK_OFF+1        ; + token
000000r 2               TK_MINUS          = TK_PLUS+1       ; - token
000000r 2               TK_MUL            = TK_MINUS+1      ; * token
000000r 2               TK_DIV            = TK_MUL+1        ; / token
000000r 2               TK_POWER          = TK_DIV+1        ; ^ token
000000r 2               TK_AND            = TK_POWER+1      ; AND token
000000r 2               TK_EOR            = TK_AND+1        ; EOR token
000000r 2               TK_OR             = TK_EOR+1        ; OR token
000000r 2               TK_RSHIFT         = TK_OR+1         ; RSHIFT token
000000r 2               TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
000000r 2               TK_GT             = TK_LSHIFT+1     ; > token
000000r 2               TK_EQUAL          = TK_GT+1         ; = token
000000r 2               TK_LT             = TK_EQUAL+1      ; < token
000000r 2               
000000r 2               ; functions tokens
000000r 2               
000000r 2               TK_SGN            = TK_LT+1         ; SGN token
000000r 2               TK_INT            = TK_SGN+1        ; INT token
000000r 2               TK_ABS            = TK_INT+1        ; ABS token
000000r 2               TK_USR            = TK_ABS+1        ; USR token
000000r 2               TK_FRE            = TK_USR+1        ; FRE token
000000r 2               TK_POS            = TK_FRE+1        ; POS token
000000r 2               TK_SQR            = TK_POS+1        ; SQR token
000000r 2               TK_RND            = TK_SQR+1        ; RND token
000000r 2               TK_LOG            = TK_RND+1        ; LOG token
000000r 2               TK_EXP            = TK_LOG+1        ; EXP token
000000r 2               TK_COS            = TK_EXP+1        ; COS token
000000r 2               TK_SIN            = TK_COS+1        ; SIN token
000000r 2               TK_TAN            = TK_SIN+1        ; TAN token
000000r 2               TK_ATN            = TK_TAN+1        ; ATN token
000000r 2               TK_PEEK           = TK_ATN+1        ; PEEK token
000000r 2               TK_DEEK           = TK_PEEK+1       ; DEEK token
000000r 2               TK_SADD           = TK_DEEK+1       ; SADD token
000000r 2               TK_LEN            = TK_SADD+1       ; LEN token
000000r 2               TK_STRS           = TK_LEN+1        ; STR$ token
000000r 2               TK_VAL            = TK_STRS+1       ; VAL token
000000r 2               TK_ASC            = TK_VAL+1        ; ASC token
000000r 2               TK_UCASES         = TK_ASC+1        ; UCASE$ token
000000r 2               TK_LCASES         = TK_UCASES+1     ; LCASE$ token
000000r 2               TK_CHRS           = TK_LCASES+1     ; CHR$ token
000000r 2               TK_HEXS           = TK_CHRS+1       ; HEX$ token
000000r 2               TK_BINS           = TK_HEXS+1       ; BIN$ token
000000r 2               TK_BITTST         = TK_BINS+1       ; BITTST token
000000r 2               TK_MAX            = TK_BITTST+1     ; MAX token
000000r 2               TK_MIN            = TK_MAX+1        ; MIN token
000000r 2               TK_PI             = TK_MIN+1        ; PI token
000000r 2               TK_TWOPI          = TK_PI+1         ; TWOPI token
000000r 2               TK_VPTR           = TK_TWOPI+1      ; VARPTR token
000000r 2               TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
000000r 2               TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
000000r 2               TK_MIDS           = TK_RIGHTS+1     ; MID$ token
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0            = $00       ; X or Y plus 0
000000r 2               PLUS_1            = $01       ; X or Y plus 1
000000r 2               PLUS_2            = $02       ; X or Y plus 2
000000r 2               PLUS_3            = $03       ; X or Y plus 3
000000r 2               
000000r 2               LAB_STAK          = $0100     ; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE          = LAB_STAK+$FE
000000r 2                                             ; flushed stack address
000000r 2               LAB_SKFF          = LAB_STAK+$FF
000000r 2                                             ; flushed stack address
000000r 2               
000000r 2               ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
000000r 2               ccflag            = $0800     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte            = ccflag+1  ; BASIC CTRL-C byte
000000r 2               ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC            = ccnull+1  ; ctrl c check vector
000000r 2               ; end bulk initialize from PG2_TABS at LAB_COLD
000000r 2               
000000r 2               ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
000000r 2               VEC_IN            = VEC_CC+2  ; input vector          $0805 $0806
000000r 2               VEC_OUT           = VEC_IN+2  ; output vector         $0807 $0808
000000r 2               VEC_LD            = VEC_OUT+2 ; load vector           $0809 $080A
000000r 2               VEC_SV            = VEC_LD+2  ; save vector           $080B $080C
000000r 2               ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
000000r 2               ; the input buffer must not cross a page boundary and must not overlap with
000000r 2               ; program RAM pages!
000000r 2               
000000r 2               ;Ibuffs            = IRQ_vec+$14
000000r 2               Ibuffs            = VEC_SV+$16
000000r 2                                             ; start of input buffer after IRQ/NMI code
000000r 2               Ibuffe            = Ibuffs+$47; end of input buffer
000000r 2               
000000r 2               Ram_base          = $0900     ; start of user RAM (set as needed, should be page aligned)
000000r 2               Ram_top           = $BF00     ; end of user RAM+1 (set as needed, should be page aligned)
000000r 2               
000000r 2               Stack_floor       = 16        ; bytes left free on stack for background interrupts
000000r 2               
000000r 2               ; This start can be changed to suit your system
000000r 2               
000000r 2               ;      *=    $C000
000000r 2               .org $C000
00C000  2               ; BASIC cold start entry point
00C000  2               
00C000  2               ; new page 2 initialisation, copy block to ccflag on
00C000  2               
00C000  2               LAB_COLD:
00C000  2  A0 04              LDY   #PG2_TABE-PG2_TABS-1
00C002  2                                             ; byte count-1
00C002  2               LAB_2D13:
00C002  2  B9 05 E1           LDA   PG2_TABS,Y        ; get byte
00C005  2  99 00 08           STA   ccflag,Y          ; store in page 2
00C008  2  88                 DEY                     ; decrement count
00C009  2  10 F7              BPL   LAB_2D13          ; loop if not done
00C00B  2               
00C00B  2  A2 FF              LDX   #$FF              ; set byte
00C00D  2  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00C00F  2  9A                 TXS                     ; reset stack pointer
00C010  2               
00C010  2  A9 4C              LDA   #$4C              ; code for JMP
00C012  2  85 A1              STA   Fnxjmp            ; save for jump vector for functions
00C014  2               
00C014  2               ; copy block from LAB_2CEE to $00BC - $00D7
00C014  2               
00C014  2  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
00C016  2               LAB_2D4E:
00C016  2  BD 09 E1           LDA   LAB_2CEE-1,X      ; get byte from table
00C019  2  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00C01B  2  CA                 DEX                     ; decrement count
00C01C  2  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00C01E  2               
00C01E  2               ; copy block from StrTab to $0000 - $0012
00C01E  2               
00C01E  2               LAB_GMEM:
00C01E  2  A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
00C020  2               TabLoop:
00C020  2  BD 26 E1           LDA   StrTab,X          ; get byte from table
00C023  2  95 00              STA   PLUS_0,X          ; save byte in page zero
00C025  2  CA                 DEX                     ; decrement count
00C026  2  10 F8              BPL   TabLoop           ; loop if not all done
00C028  2               
00C028  2               ; set-up start values
00C028  2               
00C028  2  A9 00              LDA   #$00              ; clear A
00C02A  2  85 DC              STA   NmiBase           ; clear NMI handler enabled flag
00C02C  2  85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
00C02E  2  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
00C030  2  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
00C032  2               
00C032  2  A9 0E              LDA   #$0E              ; set default tab size
00C034  2  85 64              STA   TabSiz            ; save it
00C036  2  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
00C038  2  85 A0              STA   g_step            ; save it
00C03A  2  A2 68              LDX   #des_sk           ; descriptor stack start
00C03C  2  86 65              STX   next_s            ; set descriptor stack pointer
00C03E  2  20 93 C8           JSR   LAB_CRLF          ; print CR/LF
00C041  2  A9 39              LDA   #<LAB_MSZM        ; point to memory size message (low addr)
00C043  2  A0 E1              LDY   #>LAB_MSZM        ; point to memory size message (high addr)
00C045  2  20 D4 C8           JSR   LAB_18C3          ; print null terminated string from memory
00C048  2  20 43 C2           JSR   LAB_INLN          ; print "? " and get BASIC input
00C04B  2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00C04D  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00C04F  2  20 C2 00           JSR   LAB_GBYT          ; get last byte back
00C052  2               
00C052  2  D0 1F              BNE   LAB_2DAA          ; branch if not null (user typed something)
00C054  2               
00C054  2  A0 00              LDY   #$00              ; else clear Y
00C056  2                                             ; character was null so get memory size the hard way
00C056  2                                             ; we get here with Y=0 and Itempl/h = Ram_base
00C056  2               LAB_2D93:
00C056  2  E6 11              INC   Itempl            ; increment temporary integer low byte
00C058  2  D0 08              BNE   LAB_2D99          ; branch if no overflow
00C05A  2               
00C05A  2  E6 12              INC   Itemph            ; increment temporary integer high byte
00C05C  2  A5 12              LDA   Itemph            ; get high byte
00C05E  2  C9 BF              CMP   #>Ram_top         ; compare with top of RAM+1
00C060  2  F0 1D              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
00C062  2               
00C062  2               LAB_2D99:
00C062  2  A9 55              LDA   #$55              ; set test byte
00C064  2  91 11              STA   (Itempl),Y        ; save via temporary integer
00C066  2  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00C068  2  D0 15              BNE   LAB_2DB6          ; branch if fail
00C06A  2               
00C06A  2  0A                 ASL                     ; shift test byte left (now $AA)
00C06B  2  91 11              STA   (Itempl),Y        ; save via temporary integer
00C06D  2  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00C06F  2  F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
00C071  2               
00C071  2  D0 0C              BNE   LAB_2DB6          ; branch if fail
00C073  2               
00C073  2               LAB_2DAA:
00C073  2  20 B3 D9           JSR   LAB_2887          ; get FAC1 from string
00C076  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00C078  2  C9 98              CMP   #$98              ; compare with exponent = 2^24
00C07A  2  B0 A2              BCS   LAB_GMEM          ; if too large go try again
00C07C  2               
00C07C  2  20 04 D5           JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
00C07F  2                                             ; (no range check)
00C07F  2               
00C07F  2               LAB_2DB6:
00C07F  2  A5 11              LDA   Itempl            ; get temporary integer low byte
00C081  2  A4 12              LDY   Itemph            ; get temporary integer high byte
00C083  2               ; *** begin patch  2.22p5.0 RAM top sanity check ***
00C083  2               ; *** replace
00C083  2               ;      CPY   #<Ram_base+1      ; compare with start of RAM+$100 high byte
00C083  2               ; +++ with
00C083  2  C0 0A              CPY   #>Ram_base+1      ; compare with start of RAM+$100 high byte
00C085  2               ; *** end patch    2.22p5.0 ***
00C085  2  90 97              BCC   LAB_GMEM          ; if too small go try again
00C087  2               
00C087  2               
00C087  2               ; uncomment these lines if you want to check on the high limit of memory. Note if
00C087  2               ; Ram_top is set too low then this will fail. default is ignore it and assume the
00C087  2               ; users know what they're doing!
00C087  2               
00C087  2               ;     CPY   #>Ram_top         ; compare with top of RAM high byte
00C087  2               ;     BCC   MEM_OK            ; branch if < RAM top
00C087  2               
00C087  2               ;     BNE   LAB_GMEM          ; if too large go try again
00C087  2                                             ; else was = so compare low bytes
00C087  2               ;     CMP   #<Ram_top         ; compare with top of RAM low byte
00C087  2               ;     BEQ   MEM_OK            ; branch if = RAM top
00C087  2               
00C087  2               ;     BCS   LAB_GMEM          ; if too large go try again
00C087  2               
00C087  2               ;MEM_OK
00C087  2  85 85              STA   Ememl             ; set end of mem low byte
00C089  2  84 86              STY   Ememh             ; set end of mem high byte
00C08B  2  85 81              STA   Sstorl            ; set bottom of string space low byte
00C08D  2  84 82              STY   Sstorh            ; set bottom of string space high byte
00C08F  2               
00C08F  2  A0 00              LDY   #<Ram_base        ; set start addr low byte
00C091  2  A2 09              LDX   #>Ram_base        ; set start addr high byte
00C093  2  84 79              STY   Smeml             ; save start of mem low byte
00C095  2  86 7A              STX   Smemh             ; save start of mem high byte
00C097  2               
00C097  2               ; this line is only needed if Ram_base is not $xx00
00C097  2               
00C097  2  98                 TYA                     ; clear A
00C098  2  91 79              STA   (Smeml),Y         ; clear first byte
00C09A  2  E6 79              INC   Smeml             ; increment start of mem low byte
00C09C  2               
00C09C  2               ; these two lines are only needed if Ram_base is $xxFF
00C09C  2               
00C09C  2               LAB_2E05:
00C09C  2  20 93 C8           JSR   LAB_CRLF          ; print CR/LF
00C09F  2  20 53 C3           JSR   LAB_1463          ; do "NEW" and "CLEAR"
00C0A2  2  A5 85              LDA   Ememl             ; get end of mem low byte
00C0A4  2  38                 SEC                     ; set carry for subtract
00C0A5  2  E5 79              SBC   Smeml             ; subtract start of mem low byte
00C0A7  2  AA                 TAX                     ; copy to X
00C0A8  2  A5 86              LDA   Ememh             ; get end of mem high byte
00C0AA  2  E5 7A              SBC   Smemh             ; subtract start of mem high byte
00C0AC  2  20 8F DA           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
00C0AF  2  A9 48              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
00C0B1  2  A0 E1              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
00C0B3  2  20 D4 C8           JSR   LAB_18C3          ; print null terminated string from memory
00C0B6  2  A9 5D              LDA   #<LAB_1274        ; warm start vector low byte
00C0B8  2  A0 C1              LDY   #>LAB_1274        ; warm start vector high byte
00C0BA  2  85 01              STA   Wrmjpl            ; save warm start vector low byte
00C0BC  2  84 02              STY   Wrmjph            ; save warm start vector high byte
00C0BE  2  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
00C0C1  2               
00C0C1  2               ; open up space in memory
00C0C1  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00C0C1  2               
00C0C1  2               ; Nbendl,Nbendh - new block end address (A/Y)
00C0C1  2               ; Obendl,Obendh - old block end address
00C0C1  2               ; Ostrtl,Ostrth - old block start address
00C0C1  2               
00C0C1  2               ; returns with ..
00C0C1  2               
00C0C1  2               ; Nbendl,Nbendh - new block start address (high byte - $100)
00C0C1  2               ; Obendl,Obendh - old block start address (high byte - $100)
00C0C1  2               ; Ostrtl,Ostrth - old block start address (unchanged)
00C0C1  2               
00C0C1  2               LAB_11CF:
00C0C1  2  20 0E C1           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00C0C4  2                                             ; addr to check is in AY (low/high)
00C0C4  2  85 7F              STA   Earryl            ; save new array mem end low byte
00C0C6  2  84 80              STY   Earryh            ; save new array mem end high byte
00C0C8  2               
00C0C8  2               ; open up space in memory
00C0C8  2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
00C0C8  2               ; don't set array end
00C0C8  2               
00C0C8  2               LAB_11D6:
00C0C8  2  38                 SEC                     ; set carry for subtract
00C0C9  2  A5 A6              LDA   Obendl            ; get block end low byte
00C0CB  2  E5 AA              SBC   Ostrtl            ; subtract block start low byte
00C0CD  2  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
00C0CE  2  A5 A7              LDA   Obendh            ; get block end high byte
00C0D0  2  E5 AB              SBC   Ostrth            ; subtract block start high byte
00C0D2  2  AA                 TAX                     ; copy block length high byte to X
00C0D3  2  E8                 INX                     ; +1 to allow for count=0 exit
00C0D4  2  98                 TYA                     ; copy block length low byte to A
00C0D5  2  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
00C0D7  2               
00C0D7  2                                             ; block is (X-1)*256+Y bytes, do the Y bytes first
00C0D7  2               
00C0D7  2  38                 SEC                     ; set carry for add + 1, two's complement
00C0D8  2  49 FF              EOR   #$FF              ; invert low byte for subtract
00C0DA  2  65 A6              ADC   Obendl            ; add block end low byte
00C0DC  2               
00C0DC  2  85 A6              STA   Obendl            ; save corrected old block end low byte
00C0DE  2  B0 03              BCS   LAB_11F3          ; branch if no underflow
00C0E0  2               
00C0E0  2  C6 A7              DEC   Obendh            ; else decrement block end high byte
00C0E2  2  38                 SEC                     ; set carry for add + 1, two's complement
00C0E3  2               LAB_11F3:
00C0E3  2  98                 TYA                     ; get MOD(block length/$100) byte
00C0E4  2  49 FF              EOR   #$FF              ; invert low byte for subtract
00C0E6  2  65 A4              ADC   Nbendl            ; add destination end low byte
00C0E8  2  85 A4              STA   Nbendl            ; save modified new block end low byte
00C0EA  2  B0 08              BCS   LAB_1203          ; branch if no underflow
00C0EC  2               
00C0EC  2  C6 A5              DEC   Nbendh            ; else decrement block end high byte
00C0EE  2  90 04              BCC   LAB_1203          ; branch always
00C0F0  2               
00C0F0  2               LAB_11FF:
00C0F0  2  B1 A6              LDA   (Obendl),Y        ; get byte from source
00C0F2  2  91 A4              STA   (Nbendl),Y        ; copy byte to destination
00C0F4  2               LAB_1203:
00C0F4  2  88                 DEY                     ; decrement index
00C0F5  2  D0 F9              BNE   LAB_11FF          ; loop until Y=0
00C0F7  2               
00C0F7  2                                             ; now do Y=0 indexed byte
00C0F7  2  B1 A6              LDA   (Obendl),Y        ; get byte from source
00C0F9  2  91 A4              STA   (Nbendl),Y        ; save byte to destination
00C0FB  2               LAB_120A:
00C0FB  2  C6 A7              DEC   Obendh            ; decrement source pointer high byte
00C0FD  2  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
00C0FF  2  CA                 DEX                     ; decrement block count
00C100  2  D0 F2              BNE   LAB_1203          ; loop until count = $0
00C102  2               
00C102  2  60                 RTS
00C103  2               
00C103  2               ; check room on stack for A bytes
00C103  2               ; stack too deep? do OM error
00C103  2               
00C103  2               LAB_1212:
00C103  2               ; *** patch - additional stack floor protection for background interrupts
00C103  2               ; *** add
00C103  2                     .IF   Stack_floor
00C103  2  18                 CLC                     ; prep ADC
00C104  2  69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
00C106  2                     .ENDIF
00C106  2               ; *** end patch
00C106  2  85 78              STA   TempB             ; save result in temp byte
00C108  2  BA                 TSX                     ; copy stack
00C109  2  E4 78              CPX   TempB             ; compare new "limit" with stack
00C10B  2  90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
00C10D  2               
00C10D  2  60                 RTS
00C10E  2               
00C10E  2               ; check available memory, "Out of memory" error if no room
00C10E  2               ; addr to check is in AY (low/high)
00C10E  2               
00C10E  2               LAB_121F:
00C10E  2  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00C110  2  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
00C112  2               
00C112  2  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
00C114  2               
00C114  2                                             ; high byte was =, now do low byte
00C114  2  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00C116  2  90 24              BCC   LAB_124B          ; if less then exit (is ok)
00C118  2               
00C118  2                                             ; addr is > string storage ptr (oops!)
00C118  2               LAB_1229:
00C118  2  48                 PHA                     ; push addr low byte
00C119  2  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
00C11B  2  98                 TYA                     ; copy addr high byte (to push on stack)
00C11C  2               
00C11C  2                                             ; save misc numeric work area
00C11C  2               LAB_122D:
00C11C  2  48                 PHA                     ; push byte
00C11D  2  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
00C11F  2  CA                 DEX                     ; decrement index
00C120  2  10 FA              BPL   LAB_122D          ; loop until all done
00C122  2               
00C122  2  20 EF D1           JSR   LAB_GARB          ; garbage collection routine
00C125  2               
00C125  2                                             ; restore misc numeric work area
00C125  2  A2 00              LDX   #$00              ; clear the index to restore bytes
00C127  2               LAB_1238:
00C127  2  68                 PLA                     ; pop byte
00C128  2  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
00C12A  2  E8                 INX                     ; increment index
00C12B  2  E0 08              CPX   #$08              ; compare with end + 1
00C12D  2  30 F8              BMI   LAB_1238          ; loop if more to do
00C12F  2               
00C12F  2  68                 PLA                     ; pop addr high byte
00C130  2  A8                 TAY                     ; copy back to Y
00C131  2  68                 PLA                     ; pop addr low byte
00C132  2  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
00C134  2  90 06              BCC   LAB_124B          ; if less then exit (is ok)
00C136  2               
00C136  2  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
00C138  2               
00C138  2                                             ; high byte was =, now do low byte
00C138  2  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00C13A  2  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
00C13C  2               
00C13C  2                                             ; ok exit, carry clear
00C13C  2               LAB_124B:
00C13C  2  60                 RTS
00C13D  2               
00C13D  2               ; do "Out of memory" error then warm start
00C13D  2               
00C13D  2               LAB_OMER:
00C13D  2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00C13F  2               
00C13F  2               ; do error #X, then warm start
00C13F  2               
00C13F  2               LAB_XERR:
00C13F  2  20 93 C8           JSR   LAB_CRLF          ; print CR/LF
00C142  2               
00C142  2  BD B8 E6           LDA   LAB_BAER,X        ; get error message pointer low byte
00C145  2  BC B9 E6           LDY   LAB_BAER+1,X      ; get error message pointer high byte
00C148  2  20 D4 C8           JSR   LAB_18C3          ; print null terminated string from memory
00C14B  2               
00C14B  2  20 8C C3           JSR   LAB_1491          ; flush stack and clear continue flag
00C14E  2  A9 F5              LDA   #<LAB_EMSG        ; point to " Error" low addr
00C150  2  A0 E7              LDY   #>LAB_EMSG        ; point to " Error" high addr
00C152  2               LAB_1269:
00C152  2  20 D4 C8           JSR   LAB_18C3          ; print null terminated string from memory
00C155  2  A4 88              LDY   Clineh            ; get current line high byte
00C157  2  C8                 INY                     ; increment it
00C158  2  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00C15A  2               
00C15A  2                                             ; else print line number
00C15A  2  20 84 DA           JSR   LAB_2953          ; print " in line [LINE #]"
00C15D  2               
00C15D  2               ; BASIC warm start entry point
00C15D  2               ; wait for Basic command
00C15D  2               
00C15D  2               LAB_1274:
00C15D  2                                             ; clear ON IRQ/NMI bytes
00C15D  2  A9 00              LDA   #$00              ; clear A
00C15F  2  85 DF              STA   IrqBase           ; clear enabled byte
00C161  2  85 DC              STA   NmiBase           ; clear enabled byte
00C163  2  A9 06              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
00C165  2  A0 E8              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
00C167  2               
00C167  2  20 D4 C8           JSR   LAB_18C3          ; go do print string
00C16A  2               
00C16A  2               ; wait for Basic command (no "Ready")
00C16A  2               
00C16A  2               LAB_127D:
00C16A  2  20 50 C2           JSR   LAB_1357          ; call for BASIC input
00C16D  2               LAB_1280:
00C16D  2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00C16F  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00C171  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C174  2  F0 F4              BEQ   LAB_127D          ; loop while null
00C176  2               
00C176  2               ; got to interpret input line now ..
00C176  2               
00C176  2  A2 FF              LDX   #$FF              ; current line to null value
00C178  2  86 88              STX   Clineh            ; set current line high byte
00C17A  2  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
00C17C  2               
00C17C  2                                             ; no line number .. immediate mode
00C17C  2  20 81 C2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00C17F  2  4C F5 C4           JMP   LAB_15F6          ; go scan and interpret code
00C182  2               
00C182  2               ; handle new BASIC line
00C182  2               
00C182  2               LAB_1295:
00C182  2  20 56 C7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C185  2  20 81 C2           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00C188  2  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
00C18A  2  20 27 C3           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00C18D  2  90 44              BCC   LAB_12E6          ; branch if not found
00C18F  2               
00C18F  2                                             ; aroooogah! line # already exists! delete it
00C18F  2  A0 01              LDY   #$01              ; set index to next line pointer high byte
00C191  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C193  2  85 72              STA   ut1_ph            ; save it
00C195  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00C197  2  85 71              STA   ut1_pl            ; save it
00C199  2  A5 AB              LDA   Baslnh            ; get found line pointer high byte
00C19B  2  85 74              STA   ut2_ph            ; save it
00C19D  2  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00C19F  2  88                 DEY                     ; decrement index
00C1A0  2  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
00C1A2  2  18                 CLC                     ; clear carry for add
00C1A3  2  65 7B              ADC   Svarl             ; add start of vars low byte
00C1A5  2  85 7B              STA   Svarl             ; save new start of vars low byte
00C1A7  2  85 73              STA   ut2_pl            ; save destination pointer low byte
00C1A9  2  A5 7C              LDA   Svarh             ; get start of vars high byte
00C1AB  2  69 FF              ADC   #$FF              ; -1 + carry
00C1AD  2  85 7C              STA   Svarh             ; save start of vars high byte
00C1AF  2  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
00C1B1  2  AA                 TAX                     ; copy to block count
00C1B2  2  38                 SEC                     ; set carry for subtract
00C1B3  2  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00C1B5  2  E5 7B              SBC   Svarl             ; subtract start of vars low byte
00C1B7  2  A8                 TAY                     ; copy to bytes in first block count
00C1B8  2  B0 03              BCS   LAB_12D0          ; branch if overflow
00C1BA  2               
00C1BA  2  E8                 INX                     ; increment block count (correct for =0 loop exit)
00C1BB  2  C6 74              DEC   ut2_ph            ; decrement destination high byte
00C1BD  2               LAB_12D0:
00C1BD  2  18                 CLC                     ; clear carry for add
00C1BE  2  65 71              ADC   ut1_pl            ; add source pointer low byte
00C1C0  2  90 03              BCC   LAB_12D8          ; branch if no overflow
00C1C2  2               
00C1C2  2  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
00C1C4  2  18                 CLC                     ; clear carry
00C1C5  2               
00C1C5  2                                             ; close up memory to delete old line
00C1C5  2               LAB_12D8:
00C1C5  2  B1 71              LDA   (ut1_pl),Y        ; get byte from source
00C1C7  2  91 73              STA   (ut2_pl),Y        ; copy to destination
00C1C9  2  C8                 INY                     ; increment index
00C1CA  2  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
00C1CC  2               
00C1CC  2  E6 72              INC   ut1_ph            ; increment source pointer high byte
00C1CE  2  E6 74              INC   ut2_ph            ; increment destination pointer high byte
00C1D0  2  CA                 DEX                     ; decrement block count
00C1D1  2  D0 F2              BNE   LAB_12D8          ; loop until all done
00C1D3  2               
00C1D3  2                                             ; got new line in buffer and no existing same #
00C1D3  2               LAB_12E6:
00C1D3  2  AD 21 08           LDA   Ibuffs            ; get byte from start of input buffer
00C1D6  2  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
00C1D8  2               
00C1D8  2                                             ; got new line and it isn't empty line
00C1D8  2  A5 85              LDA   Ememl             ; get end of mem low byte
00C1DA  2  A4 86              LDY   Ememh             ; get end of mem high byte
00C1DC  2  85 81              STA   Sstorl            ; set bottom of string space low byte
00C1DE  2  84 82              STY   Sstorh            ; set bottom of string space high byte
00C1E0  2  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
00C1E2  2  85 A6              STA   Obendl            ; save old block end low byte
00C1E4  2  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
00C1E6  2  84 A7              STY   Obendh            ; save old block end high byte
00C1E8  2  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
00C1EA  2  90 01              BCC   LAB_1301          ; branch if no overflow from add
00C1EC  2               
00C1EC  2  C8                 INY                     ; else increment high byte
00C1ED  2               LAB_1301:
00C1ED  2  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
00C1EF  2  84 A5              STY   Nbendh            ; save new block end high byte
00C1F1  2  20 C1 C0           JSR   LAB_11CF          ; open up space in memory
00C1F4  2                                             ; old start pointer Ostrtl,Ostrth set by the find line call
00C1F4  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00C1F6  2  A4 80              LDY   Earryh            ; get array mem end high byte
00C1F8  2  85 7B              STA   Svarl             ; save start of vars low byte
00C1FA  2  84 7C              STY   Svarh             ; save start of vars high byte
00C1FC  2  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
00C1FE  2  88                 DEY                     ; adjust for loop type
00C1FF  2               LAB_1311:
00C1FF  2  B9 1D 08           LDA   Ibuffs-4,Y        ; get byte from crunched line
00C202  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C204  2  88                 DEY                     ; decrement count
00C205  2  C0 03              CPY   #$03              ; compare with first byte-1
00C207  2  D0 F6              BNE   LAB_1311          ; continue while count <> 3
00C209  2               
00C209  2  A5 12              LDA   Itemph            ; get line # high byte
00C20B  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C20D  2  88                 DEY                     ; decrement count
00C20E  2  A5 11              LDA   Itempl            ; get line # low byte
00C210  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C212  2  88                 DEY                     ; decrement count
00C213  2  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
00C215  2                                             ; byte then a zero already here would stop the chain rebuild
00C215  2                                             ; as it would think it was the [EOT] marker.
00C215  2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00C217  2               
00C217  2               LAB_1319:
00C217  2  20 68 C3           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
00C21A  2  A6 79              LDX   Smeml             ; get start of mem low byte
00C21C  2  A5 7A              LDA   Smemh             ; get start of mem high byte
00C21E  2  A0 01              LDY   #$01              ; index to high byte of next line pointer
00C220  2               LAB_1325:
00C220  2  86 71              STX   ut1_pl            ; set line start pointer low byte
00C222  2  85 72              STA   ut1_ph            ; set line start pointer high byte
00C224  2  B1 71              LDA   (ut1_pl),Y        ; get it
00C226  2  F0 18              BEQ   LAB_133E          ; exit if end of program
00C228  2               
00C228  2               ; rebuild chaining of Basic lines
00C228  2               
00C228  2  A0 04              LDY   #$04              ; point to first code byte of line
00C22A  2                                             ; there is always 1 byte + [EOL] as null entries are deleted
00C22A  2               LAB_1330:
00C22A  2  C8                 INY                     ; next code byte
00C22B  2  B1 71              LDA   (ut1_pl),Y        ; get byte
00C22D  2  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
00C22F  2               
00C22F  2  38                 SEC                     ; set carry for add + 1
00C230  2  98                 TYA                     ; copy end index
00C231  2  65 71              ADC   ut1_pl            ; add to line start pointer low byte
00C233  2  AA                 TAX                     ; copy to X
00C234  2  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
00C236  2  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
00C238  2  98                 TYA                     ; clear A
00C239  2  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
00C23B  2  C8                 INY                     ; increment index to high byte
00C23C  2  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
00C23E  2  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
00C240  2               
00C240  2               
00C240  2               LAB_133E:
00C240  2  4C 6A C1           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
00C243  2               
00C243  2               ; print "? " and get BASIC input
00C243  2               
00C243  2               LAB_INLN:
00C243  2  20 EC C8           JSR   LAB_18E3          ; print "?" character
00C246  2  20 E9 C8           JSR   LAB_18E0          ; print " "
00C249  2  D0 05              BNE   LAB_1357          ; call for BASIC input and return
00C24B  2               
00C24B  2               ; receive line from keyboard
00C24B  2               
00C24B  2                                             ; $08 as delete key (BACKSPACE on standard keyboard)
00C24B  2               LAB_134B:
00C24B  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C24E  2  CA                 DEX                     ; decrement the buffer counter (delete)
00C24F  2  2C                 .byte $2C               ; make LDX into BIT abs
00C250  2               
00C250  2               ; call for BASIC input (main entry point)
00C250  2               
00C250  2               LAB_1357:
00C250  2  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
00C252  2               LAB_1359:
00C252  2  20 F9 E0           JSR   V_INPT            ; call scan input device
00C255  2  90 FB              BCC   LAB_1359          ; loop if no byte
00C257  2               
00C257  2  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
00C259  2               
00C259  2  C9 07              CMP   #$07              ; compare with [BELL]
00C25B  2  F0 10              BEQ   LAB_1378          ; branch if [BELL]
00C25D  2               
00C25D  2  C9 0D              CMP   #$0D              ; compare with [CR]
00C25F  2  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
00C261  2               
00C261  2  E0 00              CPX   #$00              ; compare pointer with $00
00C263  2  D0 04              BNE   LAB_1374          ; branch if not empty
00C265  2               
00C265  2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
00C265  2               
00C265  2  C9 21              CMP   #$21              ; compare with [SP]+1
00C267  2  90 E9              BCC   LAB_1359          ; if < ignore character
00C269  2               
00C269  2               LAB_1374:
00C269  2  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
00C26B  2  F0 DE              BEQ   LAB_134B          ; go delete last character
00C26D  2               
00C26D  2               LAB_1378:
00C26D  2  E0 47              CPX   #Ibuffe-Ibuffs    ; compare character count with max
00C26F  2  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
00C271  2               
00C271  2  9D 21 08           STA   Ibuffs,X          ; else store in buffer
00C274  2  E8                 INX                     ; increment pointer
00C275  2               LAB_137F:
00C275  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C278  2  D0 D8              BNE   LAB_1359          ; always loop for next character
00C27A  2               
00C27A  2               LAB_1384:
00C27A  2  4C 8A C8           JMP   LAB_1866          ; do CR/LF exit to BASIC
00C27D  2               
00C27D  2               ; announce buffer full
00C27D  2               
00C27D  2               LAB_138E:
00C27D  2  A9 07              LDA   #$07              ; [BELL] character into A
00C27F  2  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
00C281  2                                             ; branch always
00C281  2               
00C281  2               ; crunch keywords into Basic tokens
00C281  2               ; position independent buffer version ..
00C281  2               ; faster, dictionary search version ....
00C281  2               
00C281  2               LAB_13A6:
00C281  2  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
00C283  2               
00C283  2  38                 SEC                     ; set carry for subtract
00C284  2  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
00C286  2  E9 21              SBC   #<Ibuffs          ; subtract input buffer start pointer
00C288  2  AA                 TAX                     ; copy result to X (index past line # if any)
00C289  2               
00C289  2  86 60              STX   Oquote            ; clear open quote/DATA flag
00C28B  2               LAB_13AC:
00C28B  2  BD 21 08           LDA   Ibuffs,X          ; get byte from input buffer
00C28E  2  F0 51              BEQ   LAB_13EC          ; if null save byte then exit
00C290  2               
00C290  2  C9 5F              CMP   #'_'              ; compare with "_"
00C292  2  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
00C294  2               
00C294  2  C9 3C              CMP   #'<'              ; compare with "<"
00C296  2  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
00C298  2               
00C298  2  C9 30              CMP   #'0'              ; compare with "0"
00C29A  2  B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
00C29C  2               
00C29C  2  85 5C              STA   Scnquo            ; save buffer byte as search character
00C29E  2  C9 22              CMP   #$22              ; is it quote character?
00C2A0  2  F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
00C2A2  2               
00C2A2  2  C9 2A              CMP   #'*'              ; compare with "*"
00C2A4  2  90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
00C2A6  2               
00C2A6  2                                             ; else crunch now
00C2A6  2               LAB_13CC:
00C2A6  2  24 60              BIT   Oquote            ; get open quote/DATA token flag
00C2A8  2  70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
00C2AA  2                                             ; go save byte then continue crunching
00C2AA  2               
00C2AA  2  86 78              STX   TempB             ; save buffer read index
00C2AC  2  84 BA              STY   csidx             ; copy buffer save index
00C2AE  2  A0 1F              LDY   #<TAB_1STC        ; get keyword first character table low address
00C2B0  2  84 73              STY   ut2_pl            ; save pointer low byte
00C2B2  2  A0 E3              LDY   #>TAB_1STC        ; get keyword first character table high address
00C2B4  2  84 74              STY   ut2_ph            ; save pointer high byte
00C2B6  2  A0 00              LDY   #$00              ; clear table pointer
00C2B8  2               
00C2B8  2               LAB_13D0:
00C2B8  2  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
00C2BA  2  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
00C2BC  2               
00C2BC  2  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
00C2BE  2                                             ; Y and save to crunched
00C2BE  2               
00C2BE  2  C8                 INY                     ; else increment pointer
00C2BF  2  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
00C2C1  2               
00C2C1  2               ; have matched first character of some keyword
00C2C1  2               
00C2C1  2               LAB_13D1:
00C2C1  2  98                 TYA                     ; copy matching index
00C2C2  2  0A                 ASL                     ; *2 (bytes per pointer)
00C2C3  2  AA                 TAX                     ; copy to new index
00C2C4  2  BD 3D E3           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
00C2C7  2  85 73              STA   ut2_pl            ; save pointer low byte
00C2C9  2  BD 3E E3           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
00C2CC  2  85 74              STA   ut2_ph            ; save pointer high byte
00C2CE  2               
00C2CE  2  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
00C2D0  2               
00C2D0  2  A6 78              LDX   TempB             ; restore buffer read index
00C2D2  2               
00C2D2  2               LAB_13D6:
00C2D2  2  C8                 INY                     ; next table byte
00C2D3  2  B1 73              LDA   (ut2_pl),Y        ; get byte from table
00C2D5  2               LAB_13D8:
00C2D5  2  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
00C2D7  2               
00C2D7  2  E8                 INX                     ; next buffer byte
00C2D8  2  DD 21 08           CMP   Ibuffs,X          ; compare with byte from input buffer
00C2DB  2  F0 F5              BEQ   LAB_13D6          ; go compare next if match
00C2DD  2               
00C2DD  2  D0 2B              BNE   LAB_1417          ; branch if >< (not found keyword)
00C2DF  2               
00C2DF  2               LAB_13EA:
00C2DF  2  A4 BA              LDY   csidx             ; restore save index
00C2E1  2               
00C2E1  2                                             ; save crunched to output
00C2E1  2               LAB_13EC:
00C2E1  2  E8                 INX                     ; increment buffer index (to next input byte)
00C2E2  2  C8                 INY                     ; increment save index (to next output byte)
00C2E3  2  99 21 08           STA   Ibuffs,Y          ; save byte to output
00C2E6  2  C9 00              CMP   #$00              ; set the flags, set carry
00C2E8  2  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
00C2EA  2               
00C2EA  2                                             ; A holds token or byte here
00C2EA  2  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
00C2EC  2  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
00C2EE  2               
00C2EE  2                                             ; A now holds token-$3A
00C2EE  2  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
00C2F0  2  D0 02              BNE   LAB_1401          ; branch if not DATA
00C2F2  2               
00C2F2  2                                             ; token was : or DATA
00C2F2  2               LAB_13FF:
00C2F2  2  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
00C2F4  2               LAB_1401:
00C2F4  2  49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
00C2F6  2  D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
00C2F8  2               
00C2F8  2  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
00C2FA  2               
00C2FA  2                                             ; loop for REM, "..." etc.
00C2FA  2               LAB_1408:
00C2FA  2  BD 21 08           LDA   Ibuffs,X          ; get byte from input buffer
00C2FD  2  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
00C2FF  2               
00C2FF  2  C5 5C              CMP   Asrch             ; compare with stored character
00C301  2  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
00C303  2               
00C303  2                                             ; entry for copy string in quotes, don't crunch
00C303  2               LAB_1410:
00C303  2  C8                 INY                     ; increment buffer save index
00C304  2  99 21 08           STA   Ibuffs,Y          ; save byte to output
00C307  2  E8                 INX                     ; increment buffer read index
00C308  2  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
00C30A  2               
00C30A  2                                             ; not found keyword this go
00C30A  2               LAB_1417:
00C30A  2  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
00C30C  2               
00C30C  2                                             ; now find the end of this word in the table
00C30C  2               LAB_141B:
00C30C  2  B1 73              LDA   (ut2_pl),Y        ; get table byte
00C30E  2  08                 PHP                     ; save status
00C30F  2  C8                 INY                     ; increment table index
00C310  2  28                 PLP                     ; restore byte status
00C311  2  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
00C313  2               
00C313  2  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
00C315  2  D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
00C317  2               
00C317  2                                             ; reached end of table with no match
00C317  2  BD 21 08           LDA   Ibuffs,X          ; restore byte from input buffer
00C31A  2  10 C3              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
00C31C  2                                             ; go save byte in output and continue crunching
00C31C  2               
00C31C  2                                             ; reached [EOL]
00C31C  2               LAB_142A:
00C31C  2  C8                 INY                     ; increment pointer
00C31D  2  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
00C31E  2  99 21 08           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
00C321  2  C8                 INY                     ; adjust for line copy
00C322  2  C8                 INY                     ; adjust for line copy
00C323  2  C8                 INY                     ; adjust for line copy
00C324  2               
00C324  2               LAB_142P:
00C324  2  C6 C3              DEC   Bpntrl            ; allow for increment
00C326  2  60                 RTS
00C327  2               
00C327  2               ; search Basic for temp integer line number from start of mem
00C327  2               
00C327  2               LAB_SSLN:
00C327  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C329  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00C32B  2               
00C32B  2               ; search Basic for temp integer line number from AX
00C32B  2               ; returns carry set if found
00C32B  2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
00C32B  2               
00C32B  2               ; old 541 new 507
00C32B  2               
00C32B  2               LAB_SHLN:
00C32B  2  A0 01              LDY   #$01              ; set index
00C32D  2  85 AA              STA   Baslnl            ; save low byte as current
00C32F  2  86 AB              STX   Baslnh            ; save high byte as current
00C331  2  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
00C333  2  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
00C335  2               
00C335  2  A0 03              LDY   #$03              ; set index to line # high byte
00C337  2  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
00C339  2  88                 DEY                     ; decrement index (point to low byte)
00C33A  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C33C  2  D0 04              BNE   LAB_1455          ; if <> skip low byte check
00C33E  2               
00C33E  2  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
00C340  2  C5 11              CMP   Itempl            ; compare with temporary integer low byte
00C342  2               LAB_1455:
00C342  2  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
00C344  2               
00C344  2               LAB_1456:
00C344  2  88                 DEY                     ; decrement index to next line ptr high byte
00C345  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C347  2  AA                 TAX                     ; copy to X
00C348  2  88                 DEY                     ; decrement index to next line ptr low byte
00C349  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
00C34B  2  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
00C34D  2                                             ; (carry always clear)
00C34D  2               
00C34D  2               LAB_145E:
00C34D  2  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
00C34F  2               
00C34F  2               LAB_145F:
00C34F  2  18                 CLC                     ; clear found flag
00C350  2               LAB_1460:
00C350  2  60                 RTS
00C351  2               
00C351  2               ; perform NEW
00C351  2               
00C351  2               LAB_NEW:
00C351  2  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
00C353  2               
00C353  2               LAB_1463:
00C353  2  A9 00              LDA   #$00              ; clear A
00C355  2  A8                 TAY                     ; clear Y
00C356  2  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
00C358  2  C8                 INY                     ; increment index
00C359  2  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
00C35B  2  18                 CLC                     ; clear carry
00C35C  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C35E  2  69 02              ADC   #$02              ; calculate end of BASIC low byte
00C360  2  85 7B              STA   Svarl             ; save start of vars low byte
00C362  2  A5 7A              LDA   Smemh             ; get start of mem high byte
00C364  2  69 00              ADC   #$00              ; add any carry
00C366  2  85 7C              STA   Svarh             ; save start of vars high byte
00C368  2               
00C368  2               ; reset execution to start, clear vars and flush stack
00C368  2               
00C368  2               LAB_1477:
00C368  2  18                 CLC                     ; clear carry
00C369  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C36B  2  69 FF              ADC   #$FF              ; -1
00C36D  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C36F  2  A5 7A              LDA   Smemh             ; get start of mem high byte
00C371  2  69 FF              ADC   #$FF              ; -1+carry
00C373  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C375  2               
00C375  2               ; "CLEAR" command gets here
00C375  2               
00C375  2               LAB_147A:
00C375  2  A5 85              LDA   Ememl             ; get end of mem low byte
00C377  2  A4 86              LDY   Ememh             ; get end of mem high byte
00C379  2  85 81              STA   Sstorl            ; set bottom of string space low byte
00C37B  2  84 82              STY   Sstorh            ; set bottom of string space high byte
00C37D  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00C37F  2  A4 7C              LDY   Svarh             ; get start of vars high byte
00C381  2  85 7D              STA   Sarryl            ; save var mem end low byte
00C383  2  84 7E              STY   Sarryh            ; save var mem end high byte
00C385  2  85 7F              STA   Earryl            ; save array mem end low byte
00C387  2  84 80              STY   Earryh            ; save array mem end high byte
00C389  2  20 40 C5           JSR   LAB_161A          ; perform RESTORE command
00C38C  2               
00C38C  2               ; flush stack and clear continue flag
00C38C  2               
00C38C  2               LAB_1491:
00C38C  2  A2 68              LDX   #des_sk           ; set descriptor stack pointer
00C38E  2  86 65              STX   next_s            ; save descriptor stack pointer
00C390  2  68                 PLA                     ; pull return address low byte
00C391  2  AA                 TAX                     ; copy return address low byte
00C392  2  68                 PLA                     ; pull return address high byte
00C393  2  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
00C396  2  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
00C399  2  A2 FD              LDX   #$FD              ; new stack pointer
00C39B  2  9A                 TXS                     ; reset stack
00C39C  2  A9 00              LDA   #$00              ; clear byte
00C39E  2               ;*** fix p2: no longer necessary as the continue pointer is saved anyway
00C39E  2               ;      STA   Cpntrh            ; clear continue pointer high byte
00C39E  2  85 61              STA   Sufnxf            ; clear subscript/FNX flag
00C3A0  2               LAB_14A6:
00C3A0  2  60                 RTS
00C3A1  2               
00C3A1  2               ; perform CLEAR
00C3A1  2               
00C3A1  2               LAB_CLEAR:
00C3A1  2  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
00C3A3  2               
00C3A3  2                                             ; else there was a following token (go do syntax error)
00C3A3  2  60                 RTS
00C3A4  2               
00C3A4  2               ; perform LIST [n][-m]
00C3A4  2               ; bigger, faster version (a _lot_ faster)
00C3A4  2               
00C3A4  2               LAB_LIST:
00C3A4  2  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
00C3A6  2               
00C3A6  2  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
00C3A8  2               
00C3A8  2  C9 B7              CMP   #TK_MINUS         ; compare with token for -
00C3AA  2  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
00C3AC  2               
00C3AC  2                                             ; LIST [[n][-m]]
00C3AC  2                                             ; this bit sets the n , if present, as the start and end
00C3AC  2               LAB_14BD:
00C3AC  2  20 56 C7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C3AF  2  20 27 C3           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00C3B2  2                                             ; (pointer in Baslnl/Baslnh)
00C3B2  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C3B5  2  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
00C3B7  2               
00C3B7  2                                             ; this bit checks the - is present
00C3B7  2  C9 B7              CMP   #TK_MINUS         ; compare with token for -
00C3B9  2  D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
00C3BB  2               
00C3BB  2                                             ; LIST [n]-m
00C3BB  2                                             ; the - was there so set m as the end value
00C3BB  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C3BE  2  20 56 C7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C3C1  2  D0 8D              BNE   LAB_1460          ; exit if not ok
00C3C3  2               
00C3C3  2               LAB_14D4:
00C3C3  2  A5 11              LDA   Itempl            ; get temporary integer low byte
00C3C5  2  05 12              ORA   Itemph            ; OR temporary integer high byte
00C3C7  2  D0 06              BNE   LAB_14E2          ; branch if start set
00C3C9  2               
00C3C9  2  A9 FF              LDA   #$FF              ; set for -1
00C3CB  2  85 11              STA   Itempl            ; set temporary integer low byte
00C3CD  2  85 12              STA   Itemph            ; set temporary integer high byte
00C3CF  2               LAB_14E2:
00C3CF  2  A0 01              LDY   #$01              ; set index for line
00C3D1  2  84 60              STY   Oquote            ; clear open quote flag
00C3D3  2  20 93 C8           JSR   LAB_CRLF          ; print CR/LF
00C3D6  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C3D8  2                                             ; pointer initially set by search at LAB_14BD
00C3D8  2  F0 3E              BEQ   LAB_152B          ; if null all done so exit
00C3DA  2  20 16 C5           JSR   LAB_1629          ; do CRTL-C check vector
00C3DD  2               
00C3DD  2  C8                 INY                     ; increment index for line
00C3DE  2  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
00C3E0  2  AA                 TAX                     ; copy to X
00C3E1  2  C8                 INY                     ; increment index
00C3E2  2  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
00C3E4  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C3E6  2  D0 04              BNE   LAB_14FF          ; branch if no high byte match
00C3E8  2               
00C3E8  2  E4 11              CPX   Itempl            ; compare with temporary integer low byte
00C3EA  2  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
00C3EC  2               
00C3EC  2               LAB_14FF:                     ; else ..
00C3EC  2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
00C3EE  2               
00C3EE  2               LAB_1501:
00C3EE  2  84 97              STY   Tidx1             ; save index for line
00C3F0  2  20 8F DA           JSR   LAB_295E          ; print XA as unsigned integer
00C3F3  2  A9 20              LDA   #$20              ; space is the next character
00C3F5  2               LAB_1508:
00C3F5  2  A4 97              LDY   Tidx1             ; get index for line
00C3F7  2  29 7F              AND   #$7F              ; mask top out bit of character
00C3F9  2               LAB_150C:
00C3F9  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C3FC  2  C9 22              CMP   #$22              ; was it " character
00C3FE  2  D0 06              BNE   LAB_1519          ; branch if not
00C400  2               
00C400  2                                             ; we are either entering or leaving a pair of quotes
00C400  2  A5 60              LDA   Oquote            ; get open quote flag
00C402  2  49 FF              EOR   #$FF              ; toggle it
00C404  2  85 60              STA   Oquote            ; save it back
00C406  2               LAB_1519:
00C406  2  C8                 INY                     ; increment index
00C407  2  B1 AA              LDA   (Baslnl),Y        ; get next byte
00C409  2  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
00C40B  2  A8                 TAY                     ; else clear index
00C40C  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
00C40E  2  AA                 TAX                     ; copy to X
00C40F  2  C8                 INY                     ; increment index
00C410  2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
00C412  2  86 AA              STX   Baslnl            ; set pointer to line low byte
00C414  2  85 AB              STA   Baslnh            ; set pointer to line high byte
00C416  2  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
00C418  2                                             ; else ..
00C418  2               LAB_152B:
00C418  2  60                 RTS
00C419  2               
00C419  2               LAB_152E:
00C419  2  10 DE              BPL   LAB_150C          ; just go print it if not token byte
00C41B  2               
00C41B  2                                             ; else was token byte so uncrunch it (maybe)
00C41B  2  24 60              BIT   Oquote            ; test the open quote flag
00C41D  2  30 DA              BMI   LAB_150C          ; just go print character if open quote set
00C41F  2               
00C41F  2  A2 E5              LDX   #>LAB_KEYT        ; get table address high byte
00C421  2  0A                 ASL                     ; *2
00C422  2  0A                 ASL                     ; *4
00C423  2  90 02              BCC   LAB_152F          ; branch if no carry
00C425  2               
00C425  2  E8                 INX                     ; else increment high byte
00C426  2  18                 CLC                     ; clear carry for add
00C427  2               LAB_152F:
00C427  2  69 20              ADC   #<LAB_KEYT        ; add low byte
00C429  2  90 01              BCC   LAB_1530          ; branch if no carry
00C42B  2               
00C42B  2  E8                 INX                     ; else increment high byte
00C42C  2               LAB_1530:
00C42C  2  85 73              STA   ut2_pl            ; save table pointer low byte
00C42E  2  86 74              STX   ut2_ph            ; save table pointer high byte
00C430  2  84 97              STY   Tidx1             ; save index for line
00C432  2  A0 00              LDY   #$00              ; clear index
00C434  2  B1 73              LDA   (ut2_pl),Y        ; get length
00C436  2  AA                 TAX                     ; copy length
00C437  2  C8                 INY                     ; increment index
00C438  2  B1 73              LDA   (ut2_pl),Y        ; get 1st character
00C43A  2  CA                 DEX                     ; decrement length
00C43B  2  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
00C43D  2               
00C43D  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C440  2  C8                 INY                     ; increment index
00C441  2  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
00C443  2  48                 PHA                     ; save it for now
00C444  2  C8                 INY                     ; increment index
00C445  2  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
00C447  2  A0 00              LDY   #$00
00C449  2  85 74              STA   ut2_ph            ; save keyword pointer high byte
00C44B  2  68                 PLA                     ; pull low byte
00C44C  2  85 73              STA   ut2_pl            ; save keyword pointer low byte
00C44E  2               LAB_1540:
00C44E  2  B1 73              LDA   (ut2_pl),Y        ; get character
00C450  2  CA                 DEX                     ; decrement character count
00C451  2  F0 A2              BEQ   LAB_1508          ; if last character exit and print
00C453  2               
00C453  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C456  2  C8                 INY                     ; increment index
00C457  2  D0 F5              BNE   LAB_1540          ; loop for next character
00C459  2               
00C459  2               ; perform FOR
00C459  2               
00C459  2               LAB_FOR:
00C459  2  A9 80              LDA   #$80              ; set FNX
00C45B  2  85 61              STA   Sufnxf            ; set subscript/FNX flag
00C45D  2  20 B5 C7           JSR   LAB_LET           ; go do LET
00C460  2  68                 PLA                     ; pull return address
00C461  2  68                 PLA                     ; pull return address
00C462  2  A9 10              LDA   #$10              ; we need 16d bytes !
00C464  2  20 03 C1           JSR   LAB_1212          ; check room on stack for A bytes
00C467  2  20 9B C6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00C46A  2  18                 CLC                     ; clear carry for add
00C46B  2  98                 TYA                     ; copy index to A
00C46C  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C46E  2  48                 PHA                     ; push onto stack
00C46F  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00C471  2  69 00              ADC   #$00              ; add carry
00C473  2  48                 PHA                     ; push onto stack
00C474  2  A5 88              LDA   Clineh            ; get current line high byte
00C476  2  48                 PHA                     ; push onto stack
00C477  2  A5 87              LDA   Clinel            ; get current line low byte
00C479  2  48                 PHA                     ; push onto stack
00C47A  2  A9 AD              LDA   #TK_TO            ; get "TO" token
00C47C  2  20 F1 CB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
00C47F  2  20 D0 CA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00C482  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00C485  2                                             ; else do type mismatch
00C485  2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
00C485  2               ; *** add
00C485  2  20 E6 D8           JSR   LAB_27BA          ; round FAC1
00C488  2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
00C488  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00C48A  2  09 7F              ORA   #$7F              ; set all non sign bits
00C48C  2  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
00C48E  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00C490  2  A9 9B              LDA   #<LAB_159F        ; set return address low byte
00C492  2  A0 C4              LDY   #>LAB_159F        ; set return address high byte
00C494  2  85 71              STA   ut1_pl            ; save return address low byte
00C496  2  84 72              STY   ut1_ph            ; save return address high byte
00C498  2  4C 87 CB           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
00C49B  2               
00C49B  2               LAB_159F:
00C49B  2  A9 EF              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
00C49D  2  A0 E1              LDY   #>LAB_259C        ; set 1 pointer high addr
00C49F  2  20 8A D8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00C4A2  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C4A5  2  C9 B2              CMP   #TK_STEP          ; compare with STEP token
00C4A7  2  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
00C4A9  2               
00C4A9  2                                             ;.was step so ..
00C4A9  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C4AC  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00C4AF  2                                             ; else do type mismatch
00C4AF  2               LAB_15B3:
00C4AF  2  20 F6 D8           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
00C4B2  2  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
00C4B4  2                                             ; this is +1 for +ve step and -1 for -ve step, in NEXT we
00C4B4  2                                             ; compare the FOR value and the TO value and return +1 if
00C4B4  2                                             ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
00C4B4  2                                             ; here (+/-1) is then compared to that result and if they
00C4B4  2                                             ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
00C4B4  2                                             ; the loop is done
00C4B4  2               
00C4B4  2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00C4B4  2               ; *** add
00C4B4  2                  .IF <* = $FD
00C4B4  2                     NOP                     ; return address of JSR +1 (on  next page)
00C4B4  2                  .ENDIF
00C4B4  2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00C4B4  2  20 79 CB           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
00C4B7  2  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
00C4B9  2  48                 PHA                     ; push on stack
00C4BA  2  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
00C4BC  2  48                 PHA                     ; push on stack
00C4BD  2  A9 81              LDA   #TK_FOR           ; get FOR token
00C4BF  2  48                 PHA                     ; push on stack
00C4C0  2               
00C4C0  2               ; interpreter inner loop
00C4C0  2               
00C4C0  2               LAB_15C2:
00C4C0  2  20 16 C5           JSR   LAB_1629          ; do CRTL-C check vector
00C4C3  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C4C5  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00C4C7  2               
00C4C7  2  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
00C4C9  2                                             ; ($00xx for RUN from immediate mode)
00C4C9  2  E8                 INX                     ; increment it (now $00 if immediate mode)
00C4CA  2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
00C4CA  2               ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
00C4CA  2               
00C4CA  2  85 8B              STA   Cpntrl            ; save continue pointer low byte
00C4CC  2  84 8C              STY   Cpntrh            ; save continue pointer high byte
00C4CE  2               LAB_15D1:
00C4CE  2  A0 00              LDY   #$00              ; clear index
00C4D0  2  B1 C3              LDA   (Bpntrl),Y        ; get next byte
00C4D2  2  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
00C4D4  2               
00C4D4  2  C9 3A              CMP   #':'              ; compare with ":"
00C4D6  2  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
00C4D8  2               
00C4D8  2               LAB_15D9:
00C4D8  2  4C 02 CC           JMP   LAB_SNER          ; else syntax error then warm start
00C4DB  2               
00C4DB  2                                             ; have reached [EOL]
00C4DB  2               LAB_15DC:
00C4DB  2  A0 02              LDY   #$02              ; set index
00C4DD  2  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
00C4DF  2  18                 CLC                     ; clear carry for no "BREAK" message
00C4E0  2  F0 50              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
00C4E2  2                                             ; marker)
00C4E2  2               
00C4E2  2  C8                 INY                     ; increment index
00C4E3  2  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
00C4E5  2  85 87              STA   Clinel            ; save current line low byte
00C4E7  2  C8                 INY                     ; increment index
00C4E8  2  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
00C4EA  2  85 88              STA   Clineh            ; save current line high byte
00C4EC  2  98                 TYA                     ; A now = 4
00C4ED  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C4EF  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C4F1  2  90 02              BCC   LAB_15F6          ; branch if no overflow
00C4F3  2               
00C4F3  2  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
00C4F5  2               LAB_15F6:
00C4F5  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C4F8  2               
00C4F8  2               LAB_15F9:
00C4F8  2  20 FE C4           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
00C4FB  2               
00C4FB  2               LAB_15FC:
00C4FB  2  4C C0 C4           JMP   LAB_15C2          ; loop
00C4FE  2               
00C4FE  2               ; interpret BASIC code from (Bpntrl)
00C4FE  2               
00C4FE  2               LAB_15FF:
00C4FE  2  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
00C500  2               
00C500  2               LAB_1602:
00C500  2  0A                 ASL                     ; *2 bytes per vector and normalise token
00C501  2  B0 03              BCS   LAB_1609          ; branch if was token
00C503  2               
00C503  2  4C B5 C7           JMP   LAB_LET           ; else go do implied LET
00C506  2               
00C506  2               LAB_1609:
00C506  2  C9 56              CMP   #$56 ;#[TK_TAB-$80]*2   ; compare normalised token * 2 with TAB
00C508  2  B0 CE              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
00C50A  2                                             ; only tokens before TAB can start a line
00C50A  2  A8                 TAY                     ; copy to index
00C50B  2  B9 17 E2           LDA   LAB_CTBL+1,Y      ; get vector high byte
00C50E  2  48                 PHA                     ; onto stack
00C50F  2  B9 16 E2           LDA   LAB_CTBL,Y        ; get vector low byte
00C512  2  48                 PHA                     ; onto stack
00C513  2  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
00C516  2                                             ; then "return" to vector
00C516  2               
00C516  2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00C516  2               ; key press is detected.
00C516  2               
00C516  2               LAB_1629:
00C516  2  6C 03 08           JMP   (VEC_CC)          ; ctrl c check vector
00C519  2               
00C519  2               ; if there was a key press it gets back here ..
00C519  2               
00C519  2               LAB_1636:
00C519  2  C9 03              CMP   #$03              ; compare with CTRL-C
00C51B  2               
00C51B  2               ; perform STOP
00C51B  2               
00C51B  2               LAB_STOP:
00C51B  2  B0 01              BCS   LAB_163B          ; branch if token follows STOP
00C51D  2                                             ; else just END
00C51D  2               ; END
00C51D  2               
00C51D  2               LAB_END:
00C51D  2  18                 CLC                     ; clear the carry, indicate a normal program end
00C51E  2               LAB_163B:
00C51E  2  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
00C520  2               
00C520  2  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
00C522  2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
00C522  2               ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
00C522  2               ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
00C522  2               ;                              ; (can't continue in immediate mode)
00C522  2               ;                              ; else ..
00C522  2               ;      EOR   #>Ibuffs          ; correct the bits
00C522  2  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
00C524  2  84 8B              STY   Cpntrl            ; save continue pointer low byte
00C526  2  85 8C              STA   Cpntrh            ; save continue pointer high byte
00C528  2               LAB_1647:
00C528  2  A5 87              LDA   Clinel            ; get current line low byte
00C52A  2  A4 88              LDY   Clineh            ; get current line high byte
00C52C  2  85 89              STA   Blinel            ; save break line low byte
00C52E  2  84 8A              STY   Blineh            ; save break line high byte
00C530  2               LAB_164F:
00C530  2  68                 PLA                     ; pull return address low
00C531  2  68                 PLA                     ; pull return address high
00C532  2               LAB_1651:
00C532  2  90 07              BCC   LAB_165E          ; if was program end just do warm start
00C534  2               
00C534  2                                             ; else ..
00C534  2  A9 ED              LDA   #<LAB_BMSG        ; point to "Break" low byte
00C536  2  A0 E7              LDY   #>LAB_BMSG        ; point to "Break" high byte
00C538  2  4C 52 C1           JMP   LAB_1269          ; print "Break" and do warm start
00C53B  2               
00C53B  2               LAB_165E:
00C53B  2  4C 5D C1           JMP   LAB_1274          ; go do warm start
00C53E  2               
00C53E  2               ; perform RESTORE
00C53E  2               
00C53E  2               LAB_RESTORE:
00C53E  2  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
00C540  2               
00C540  2               LAB_161A:
00C540  2  38                 SEC                     ; set carry for subtract
00C541  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C543  2  E9 01              SBC   #$01              ; -1
00C545  2  A4 7A              LDY   Smemh             ; get start of mem high byte
00C547  2  B0 01              BCS   LAB_1624          ; branch if no underflow
00C549  2               
00C549  2               LAB_uflow:
00C549  2  88                 DEY                     ; else decrement high byte
00C54A  2               LAB_1624:
00C54A  2  85 8F              STA   Dptrl             ; save DATA pointer low byte
00C54C  2  84 90              STY   Dptrh             ; save DATA pointer high byte
00C54E  2               LAB_1628:
00C54E  2  60                 RTS
00C54F  2               
00C54F  2                                             ; is RESTORE n
00C54F  2               LAB_RESTOREn:
00C54F  2  20 56 C7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C552  2  20 9E C6           JSR   LAB_SNBL          ; scan for next BASIC line
00C555  2  A5 88              LDA   Clineh            ; get current line high byte
00C557  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C559  2  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
00C55B  2               
00C55B  2  98                 TYA                     ; else copy line index to A
00C55C  2  38                 SEC                     ; set carry (+1)
00C55D  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C55F  2  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
00C561  2  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
00C563  2               
00C563  2  E8                 INX                     ; increment high byte
00C564  2  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
00C566  2               
00C566  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00C566  2               
00C566  2               LAB_reset_search:
00C566  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C568  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00C56A  2               
00C56A  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00C56A  2               
00C56A  2               LAB_go_search:
00C56A  2               
00C56A  2  20 2B C3           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00C56D  2  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
00C56F  2               
00C56F  2  4C 70 C6           JMP   LAB_16F7          ; else go do "Undefined statement" error
00C572  2               
00C572  2               LAB_line_found:
00C572  2                                             ; carry already set for subtract
00C572  2  A5 AA              LDA   Baslnl            ; get pointer low byte
00C574  2  E9 01              SBC   #$01              ; -1
00C576  2  A4 AB              LDY   Baslnh            ; get pointer high byte
00C578  2  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
00C57A  2               
00C57A  2  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
00C57C  2                                             ; return (branch always)
00C57C  2               
00C57C  2               ; perform NULL
00C57C  2               
00C57C  2               LAB_NULL:
00C57C  2  20 A0 D4           JSR   LAB_GTBY          ; get byte parameter
00C57F  2  86 0D              STX   Nullct            ; save new NULL count
00C581  2               LAB_167A:
00C581  2  60                 RTS
00C582  2               
00C582  2               ; perform CONT
00C582  2               
00C582  2               LAB_CONT:
00C582  2  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
00C584  2               
00C584  2  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
00C586  2  C0 08              CPY   #>Ibuffs          ; *** fix p2: test direct mode
00C588  2  D0 05              BNE   LAB_166C          ; go do continue if we can
00C58A  2               
00C58A  2  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
00C58C  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00C58F  2               
00C58F  2                                             ; we can continue so ..
00C58F  2               LAB_166C:
00C58F  2  A9 93              LDA   #TK_ON            ; set token for ON
00C591  2  20 23 DF           JSR   LAB_IRQ           ; set IRQ flags
00C594  2  A9 93              LDA   #TK_ON            ; set token for ON
00C596  2  20 26 DF           JSR   LAB_NMI           ; set NMI flags
00C599  2               
00C599  2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
00C59B  2  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
00C59D  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C59F  2  A5 89              LDA   Blinel            ; get break line low byte
00C5A1  2  A4 8A              LDY   Blineh            ; get break line high byte
00C5A3  2  85 87              STA   Clinel            ; set current line low byte
00C5A5  2  84 88              STY   Clineh            ; set current line high byte
00C5A7  2  60                 RTS
00C5A8  2               
00C5A8  2               ; perform RUN
00C5A8  2               
00C5A8  2               LAB_RUN:
00C5A8  2  D0 03              BNE   LAB_1696          ; branch if RUN n
00C5AA  2  4C 68 C3           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
00C5AD  2                                             ; return
00C5AD  2               
00C5AD  2               ; does RUN n
00C5AD  2               
00C5AD  2               LAB_1696:
00C5AD  2  20 75 C3           JSR   LAB_147A          ; go do "CLEAR"
00C5B0  2  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
00C5B2  2               
00C5B2  2               ; perform DO
00C5B2  2               
00C5B2  2               LAB_DO:
00C5B2  2  A9 05              LDA   #$05              ; need 5 bytes for DO
00C5B4  2  20 03 C1           JSR   LAB_1212          ; check room on stack for A bytes
00C5B7  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00C5B9  2  48                 PHA                     ; push on stack
00C5BA  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C5BC  2  48                 PHA                     ; push on stack
00C5BD  2  A5 88              LDA   Clineh            ; get current line high byte
00C5BF  2  48                 PHA                     ; push on stack
00C5C0  2  A5 87              LDA   Clinel            ; get current line low byte
00C5C2  2  48                 PHA                     ; push on stack
00C5C3  2  A9 9D              LDA   #TK_DO            ; token for DO
00C5C5  2  48                 PHA                     ; push on stack
00C5C6  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C5C9  2  4C C0 C4           JMP   LAB_15C2          ; go do interpreter inner loop
00C5CC  2               
00C5CC  2               ; perform GOSUB
00C5CC  2               
00C5CC  2               LAB_GOSUB:
00C5CC  2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
00C5CE  2  20 03 C1           JSR   LAB_1212          ; check room on stack for A bytes
00C5D1  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00C5D3  2  48                 PHA                     ; push on stack
00C5D4  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C5D6  2  48                 PHA                     ; push on stack
00C5D7  2  A5 88              LDA   Clineh            ; get current line high byte
00C5D9  2  48                 PHA                     ; push on stack
00C5DA  2  A5 87              LDA   Clinel            ; get current line low byte
00C5DC  2  48                 PHA                     ; push on stack
00C5DD  2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
00C5DF  2  48                 PHA                     ; push on stack
00C5E0  2               LAB_16B0:
00C5E0  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C5E3  2  20 E9 C5           JSR   LAB_GOTO          ; perform GOTO n
00C5E6  2  4C C0 C4           JMP   LAB_15C2          ; go do interpreter inner loop
00C5E9  2                                             ; (can't RTS, we used the stack!)
00C5E9  2               
00C5E9  2               ; perform GOTO
00C5E9  2               
00C5E9  2               LAB_GOTO:
00C5E9  2  20 56 C7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00C5EC  2  20 9E C6           JSR   LAB_SNBL          ; scan for next BASIC line
00C5EF  2  A5 88              LDA   Clineh            ; get current line high byte
00C5F1  2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00C5F3  2  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
00C5F5  2               
00C5F5  2  98                 TYA                     ; else copy line index to A
00C5F6  2  38                 SEC                     ; set carry (+1)
00C5F7  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C5F9  2  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
00C5FB  2  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
00C5FD  2               
00C5FD  2  E8                 INX                     ; increment high byte
00C5FE  2  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
00C600  2               
00C600  2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
00C600  2               
00C600  2               LAB_16D0:
00C600  2  A5 79              LDA   Smeml             ; get start of mem low byte
00C602  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00C604  2               
00C604  2               ; search for line # in temp (Itempl/Itemph) from (AX)
00C604  2               
00C604  2               LAB_16D4:
00C604  2  20 2B C3           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00C607  2  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
00C609  2                                             ; (unspecified statement)
00C609  2               
00C609  2                                             ; carry already set for subtract
00C609  2  A5 AA              LDA   Baslnl            ; get pointer low byte
00C60B  2  E9 01              SBC   #$01              ; -1
00C60D  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C60F  2  A5 AB              LDA   Baslnh            ; get pointer high byte
00C611  2  E9 00              SBC   #$00              ; subtract carry
00C613  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C615  2               LAB_16E5:
00C615  2  60                 RTS
00C616  2               
00C616  2               LAB_DONOK:
00C616  2  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
00C618  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00C61B  2               
00C61B  2               ; perform LOOP
00C61B  2               
00C61B  2               LAB_LOOP:
00C61B  2  A8                 TAY                     ; save following token
00C61C  2  BA                 TSX                     ; copy stack pointer
00C61D  2  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
00C620  2  C9 9D              CMP   #TK_DO            ; compare with DO token
00C622  2  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
00C624  2               
00C624  2  E8                 INX                     ; dump calling routine return address
00C625  2  E8                 INX                     ; dump calling routine return address
00C626  2  9A                 TXS                     ; correct stack
00C627  2  98                 TYA                     ; get saved following token back
00C628  2  F0 20              BEQ   LoopAlways        ; if no following token loop forever
00C62A  2                                             ; (stack pointer in X)
00C62A  2               
00C62A  2  C9 3A              CMP   #':'              ; could be ':'
00C62C  2  F0 1C              BEQ   LoopAlways        ; if :... loop forever
00C62E  2               
00C62E  2  E9 B3              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
00C630  2  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
00C631  2  F0 04              BEQ   DoRest            ; branch if was UNTIL
00C633  2               
00C633  2  CA                 DEX                     ; decrement result
00C634  2  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
00C636  2                                             ; only if the token was WHILE will this fail
00C636  2               
00C636  2  CA                 DEX                     ; set invert result byte
00C637  2               DoRest:
00C637  2  86 98              STX   Frnxth            ; save invert result byte
00C639  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C63C  2  20 E1 CA           JSR   LAB_EVEX          ; evaluate expression
00C63F  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00C641  2  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
00C643  2               
00C643  2  A9 FF              LDA   #$FF              ; else set all bits
00C645  2               DoCmp:
00C645  2  BA                 TSX                     ; copy stack pointer
00C646  2  45 98              EOR   Frnxth            ; EOR with invert byte
00C648  2  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
00C64A  2               
00C64A  2                                             ; loop condition wasn't met so do it again
00C64A  2               LoopAlways:
00C64A  2  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
00C64D  2  85 87              STA   Clinel            ; save current line low byte
00C64F  2  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
00C652  2  85 88              STA   Clineh            ; save current line high byte
00C654  2  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
00C657  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C659  2  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
00C65C  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C65E  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C661  2  4C C0 C4           JMP   LAB_15C2          ; go do interpreter inner loop
00C664  2               
00C664  2                                             ; clear stack and back to interpreter loop
00C664  2               LoopDone:
00C664  2  E8                 INX                     ; dump DO token
00C665  2  E8                 INX                     ; dump current line low byte
00C666  2  E8                 INX                     ; dump current line high byte
00C667  2  E8                 INX                     ; dump BASIC execute pointer low byte
00C668  2  E8                 INX                     ; dump BASIC execute pointer high byte
00C669  2  9A                 TXS                     ; correct stack
00C66A  2  4C 8A C6           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
00C66D  2               
00C66D  2               ; do the return without gosub error
00C66D  2               
00C66D  2               LAB_16F4:
00C66D  2  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
00C66F  2  2C                 .byte $2C               ; makes next line BIT LAB_0EA2
00C670  2               
00C670  2               LAB_16F7:                     ; do undefined statement error
00C670  2  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
00C672  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00C675  2               
00C675  2               ; perform RETURN
00C675  2               
00C675  2               LAB_RETURN:
00C675  2  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
00C677  2               
00C677  2               LAB_16E8:
00C677  2  68                 PLA                     ; dump calling routine return address
00C678  2  68                 PLA                     ; dump calling routine return address
00C679  2  68                 PLA                     ; pull token
00C67A  2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
00C67C  2  D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
00C67E  2               
00C67E  2               LAB_16FF:
00C67E  2  68                 PLA                     ; pull current line low byte
00C67F  2  85 87              STA   Clinel            ; save current line low byte
00C681  2  68                 PLA                     ; pull current line high byte
00C682  2  85 88              STA   Clineh            ; save current line high byte
00C684  2  68                 PLA                     ; pull BASIC execute pointer low byte
00C685  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C687  2  68                 PLA                     ; pull BASIC execute pointer high byte
00C688  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00C68A  2               
00C68A  2                                             ; now do the DATA statement as we could be returning into
00C68A  2                                             ; the middle of an ON <var> GOSUB n,m,p,q line
00C68A  2                                             ; (the return address used by the DATA statement is the one
00C68A  2                                             ; pushed before the GOSUB was executed!)
00C68A  2               
00C68A  2               ; perform DATA
00C68A  2               
00C68A  2               LAB_DATA:
00C68A  2  20 9B C6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00C68D  2               
00C68D  2                                             ; set BASIC execute pointer
00C68D  2               LAB_170F:
00C68D  2  98                 TYA                     ; copy index to A
00C68E  2  18                 CLC                     ; clear carry for add
00C68F  2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00C691  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C693  2  90 02              BCC   LAB_1719          ; skip next if no carry
00C695  2               
00C695  2  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
00C697  2               LAB_1719:
00C697  2  60                 RTS
00C698  2               
00C698  2               LAB_16FC:
00C698  2  4C 02 CC           JMP   LAB_SNER          ; do syntax error then warm start
00C69B  2               
00C69B  2               ; scan for next BASIC statement ([:] or [EOL])
00C69B  2               ; returns Y as index to [:] or [EOL]
00C69B  2               
00C69B  2               LAB_SNBS:
00C69B  2  A2 3A              LDX   #':'              ; set look for character = ":"
00C69D  2  2C                 .byte $2C               ; makes next line BIT $00A2
00C69E  2               
00C69E  2               ; scan for next BASIC line
00C69E  2               ; returns Y as index to [EOL]
00C69E  2               
00C69E  2               LAB_SNBL:
00C69E  2  A2 00              LDX   #$00              ; set alt search character = [EOL]
00C6A0  2  A0 00              LDY   #$00              ; set search character = [EOL]
00C6A2  2  84 5C              STY   Asrch             ; store search character
00C6A4  2               LAB_1725:
00C6A4  2  8A                 TXA                     ; get alt search character
00C6A5  2  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
00C6A7  2  85 5C              STA   Asrch             ; save swapped search character
00C6A9  2               LAB_172D:
00C6A9  2  B1 C3              LDA   (Bpntrl),Y        ; get next byte
00C6AB  2  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
00C6AD  2               
00C6AD  2  C5 5C              CMP   Asrch             ; compare with search character
00C6AF  2  F0 E6              BEQ   LAB_1719          ; exit if found
00C6B1  2               
00C6B1  2  C8                 INY                     ; increment index
00C6B2  2  C9 22              CMP   #$22              ; compare current character with open quote
00C6B4  2  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
00C6B6  2               
00C6B6  2  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
00C6B8  2               
00C6B8  2               ; perform IF
00C6B8  2               
00C6B8  2               LAB_IF:
00C6B8  2  20 E1 CA           JSR   LAB_EVEX          ; evaluate the expression
00C6BB  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C6BE  2  C9 B0              CMP   #TK_THEN          ; compare with THEN token
00C6C0  2  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
00C6C2  2               
00C6C2  2                                             ; wasn't IF .. THEN so must be IF .. GOTO
00C6C2  2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
00C6C4  2  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
00C6C6  2               
00C6C6  2  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
00C6C8  2  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
00C6CA  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C6CD  2  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
00C6CF  2               
00C6CF  2  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
00C6D1  2  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
00C6D3  2               LAB_174B:
00C6D3  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00C6D5  2  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
00C6D7  2               
00C6D7  2  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
00C6DA  2  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
00C6DC  2               
00C6DC  2               LAB_174C:
00C6DC  2  4C E9 C5           JMP   LAB_GOTO          ; else was numeric so do GOTO n
00C6DF  2               
00C6DF  2                                             ; is var or keyword
00C6DF  2               LAB_174D:
00C6DF  2               ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
00C6DF  2               ; *** replace
00C6DF  2               ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
00C6DF  2               ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
00C6DF  2               ;                              ; and return to this code to process any following code
00C6DF  2               ;
00C6DF  2               ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
00C6DF  2               ;                              ; but don't return here
00C6DF  2               ;
00C6DF  2               ;LAB_174G
00C6DF  2               ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00C6DF  2               ;
00C6DF  2               ;; the IF was executed and there may be a following ELSE so the code needs to return
00C6DF  2               ;; here to check and ignore the ELSE if present
00C6DF  2               ;
00C6DF  2               ;      LDY   #$00              ; clear the index
00C6DF  2               ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
00C6DF  2               ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
00C6DF  2               ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
00C6DF  2               ;
00C6DF  2               ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00C6DF  2               ;; following ELSE will, correctly, cause a syntax error
00C6DF  2               ;
00C6DF  2               ;      RTS                     ; else return to the interpreter inner loop
00C6DF  2               ;
00C6DF  2               ; *** with
00C6DF  2  68                 PLA                     ; discard interpreter loop return address
00C6E0  2  68                 PLA                     ; so data structures are at the correct stack offset
00C6E1  2  20 C2 00           JSR   LAB_GBYT          ; restore token or variable
00C6E4  2  20 FE C4           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00C6E7  2               
00C6E7  2               ; the IF was executed and there may be a following ELSE so the code needs to return
00C6E7  2               ; here to check and ignore the ELSE if present
00C6E7  2               
00C6E7  2  A0 00              LDY   #$00              ; clear the index
00C6E9  2  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
00C6EB  2  C9 AC              CMP   #TK_ELSE          ; compare it with the token for ELSE
00C6ED  2  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
00C6EF  2  20 8A C6           JSR   LAB_DATA          ; yes - skip the rest of the line
00C6F2  2               
00C6F2  2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00C6F2  2               ; following ELSE will, correctly, cause a syntax error
00C6F2  2               
00C6F2  2               LAB_no_ELSE:
00C6F2  2  4C C0 C4           JMP LAB_15C2            ; return to the interpreter inner loop
00C6F5  2               ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
00C6F5  2               
00C6F5  2               ; perform ELSE after IF
00C6F5  2               
00C6F5  2               LAB_174E:
00C6F5  2  A0 00              LDY   #$00              ; clear the BASIC byte index
00C6F7  2  A2 01              LDX   #$01              ; clear the nesting depth
00C6F9  2               LAB_1750:
00C6F9  2  C8                 INY                     ; increment the BASIC byte index
00C6FA  2  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
00C6FC  2  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
00C6FE  2               
00C6FE  2  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
00C700  2  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
00C702  2               
00C702  2  E8                 INX                     ; else increment the nesting depth ..
00C703  2  D0 F4              BNE   LAB_1750          ; .. and continue looking
00C705  2               
00C705  2               LAB_1752:
00C705  2  C9 AC              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
00C707  2  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
00C709  2               
00C709  2  CA                 DEX                     ; was ELSE so decrement the nesting depth
00C70A  2  D0 ED              BNE   LAB_1750          ; loop if still nested
00C70C  2               
00C70C  2  C8                 INY                     ; increment the BASIC byte index past the ELSE
00C70D  2               
00C70D  2               ; found the matching ELSE, now do <{n|statement}>
00C70D  2               
00C70D  2               LAB_1753:
00C70D  2  98                 TYA                     ; else copy line index to A
00C70E  2  18                 CLC                     ; clear carry for add
00C70F  2  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
00C711  2  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
00C713  2  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
00C715  2               
00C715  2  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
00C717  2               LAB_1754:
00C717  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C71A  2  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
00C71C  2                                             ; the code will return to the interpreter loop at the
00C71C  2                                             ; tail end of the GOTO <n>
00C71C  2               
00C71C  2  4C FE C4           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00C71F  2                                             ; the code will return to the interpreter loop at the
00C71F  2                                             ; tail end of the <statement>
00C71F  2               
00C71F  2               ; perform REM, skip (rest of) line
00C71F  2               
00C71F  2               LAB_REM:
00C71F  2  20 9E C6           JSR   LAB_SNBL          ; scan for next BASIC line
00C722  2  4C 8D C6           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
00C725  2               
00C725  2               LAB_16FD:
00C725  2  4C 02 CC           JMP   LAB_SNER          ; do syntax error then warm start
00C728  2               
00C728  2               ; perform ON
00C728  2               
00C728  2               LAB_ON:
00C728  2  C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
00C72A  2  D0 03              BNE   LAB_NOIN          ; if not go check NMI
00C72C  2               
00C72C  2  4C 47 DF           JMP   LAB_SIRQ          ; else go set-up IRQ
00C72F  2               
00C72F  2               LAB_NOIN:
00C72F  2  C9 AA              CMP   #TK_NMI           ; was it NMI token ?
00C731  2  D0 03              BNE   LAB_NONM          ; if not go do normal ON command
00C733  2               
00C733  2  4C 4B DF           JMP   LAB_SNMI          ; else go set-up NMI
00C736  2               
00C736  2               LAB_NONM:
00C736  2  20 A0 D4           JSR   LAB_GTBY          ; get byte parameter
00C739  2  48                 PHA                     ; push GOTO/GOSUB token
00C73A  2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
00C73C  2  F0 04              BEQ   LAB_176B          ; branch if GOSUB
00C73E  2               
00C73E  2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
00C740  2               LAB_1767:
00C740  2  D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
00C742  2               
00C742  2               
00C742  2               ; next character was GOTO or GOSUB
00C742  2               
00C742  2               LAB_176B:
00C742  2  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
00C744  2  D0 04              BNE   LAB_1773          ; branch if not zero
00C746  2               
00C746  2  68                 PLA                     ; pull GOTO/GOSUB token
00C747  2  4C 00 C5           JMP   LAB_1602          ; go execute it
00C74A  2               
00C74A  2               LAB_1773:
00C74A  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C74D  2  20 56 C7           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
00C750  2                                             ; (we could LDX #',' and JSR LAB_SNBL+2, then we
00C750  2                                             ; just BNE LAB_176B for the loop. should be quicker ..
00C750  2                                             ; no we can't, what if we meet a colon or [EOL]?)
00C750  2  C9 2C              CMP   #$2C              ; compare next character with ","
00C752  2  F0 EE              BEQ   LAB_176B          ; loop if ","
00C754  2               
00C754  2               LAB_177E:
00C754  2  68                 PLA                     ; else pull keyword token (run out of options)
00C755  2                                             ; also dump +/-1 pointer low byte and exit
00C755  2               LAB_177F:
00C755  2  60                 RTS
00C756  2               
00C756  2               ; takes n * 106 + 11 cycles where n is the number of digits
00C756  2               
00C756  2               ; get fixed-point number into temp integer
00C756  2               
00C756  2               LAB_GFPN:
00C756  2  A2 00              LDX   #$00              ; clear reg
00C758  2  86 11              STX   Itempl            ; clear temporary integer low byte
00C75A  2               LAB_1785:
00C75A  2  86 12              STX   Itemph            ; save temporary integer high byte
00C75C  2  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
00C75E  2                                             ; not 0-9
00C75E  2               
00C75E  2  E0 19              CPX   #$19              ; compare high byte with $19
00C760  2  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
00C761  2  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
00C763  2                                             ; bit does *$0A, = 64000, compare at target will fail
00C763  2                                             ; and do syntax error
00C763  2               
00C763  2  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
00C765  2  A8                 TAY                     ; copy binary digit
00C766  2  A5 11              LDA   Itempl            ; get temporary integer low byte
00C768  2  0A                 ASL                     ; *2 low byte
00C769  2  26 12              ROL   Itemph            ; *2 high byte
00C76B  2  0A                 ASL                     ; *2 low byte
00C76C  2  26 12              ROL   Itemph            ; *2 high byte, *4
00C76E  2  65 11              ADC   Itempl            ; + low byte, *5
00C770  2  85 11              STA   Itempl            ; save it
00C772  2  8A                 TXA                     ; get high byte copy to A
00C773  2  65 12              ADC   Itemph            ; + high byte, *5
00C775  2  06 11              ASL   Itempl            ; *2 low byte, *10d
00C777  2  2A                 ROL                     ; *2 high byte, *10d
00C778  2  AA                 TAX                     ; copy high byte back to X
00C779  2  98                 TYA                     ; get binary digit back
00C77A  2  65 11              ADC   Itempl            ; add number low byte
00C77C  2  85 11              STA   Itempl            ; save number low byte
00C77E  2  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
00C780  2               
00C780  2  E8                 INX                     ; else increment high byte
00C781  2               LAB_17B3:
00C781  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C784  2  4C 5A C7           JMP   LAB_1785          ; loop for next character
00C787  2               
00C787  2               ; perform DEC
00C787  2               
00C787  2               LAB_DEC:
00C787  2  A9 F3              LDA   #<LAB_2AFD        ; set -1 pointer low byte
00C789  2  2C                 .byte $2C               ; BIT abs to skip the LDA below
00C78A  2               
00C78A  2               ; perform INC
00C78A  2               
00C78A  2               LAB_INC:
00C78A  2  A9 EF              LDA   #<LAB_259C        ; set 1 pointer low byte
00C78C  2               LAB_17B5:
00C78C  2  48                 PHA                     ; save +/-1 pointer low byte
00C78D  2               LAB_17B7:
00C78D  2  20 B8 CD           JSR   LAB_GVAR          ; get var address
00C790  2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
00C792  2  30 1E              BMI   IncrErr           ; exit if string
00C794  2               
00C794  2  85 97              STA   Lvarpl            ; save var address low byte
00C796  2  84 98              STY   Lvarph            ; save var address high byte
00C798  2  20 8A D8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00C79B  2  68                 PLA                     ; get +/-1 pointer low byte
00C79C  2  48                 PHA                     ; save +/-1 pointer low byte
00C79D  2  A0 E1              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
00C79F  2  20 CB D5           JSR   LAB_246C          ; add (AY) to FAC1
00C7A2  2  20 B0 D8           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
00C7A5  2               
00C7A5  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C7A8  2  C9 2C              CMP   #','              ; compare with ","
00C7AA  2  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
00C7AC  2               
00C7AC  2                                             ; was "," so another INCR variable to do
00C7AC  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C7AF  2  4C 8D C7           JMP   LAB_17B7          ; go do next var
00C7B2  2               
00C7B2  2               IncrErr:
00C7B2  2  4C DC CA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
00C7B5  2               
00C7B5  2               ; perform LET
00C7B5  2               
00C7B5  2               LAB_LET:
00C7B5  2  20 B8 CD           JSR   LAB_GVAR          ; get var address
00C7B8  2  85 97              STA   Lvarpl            ; save var address low byte
00C7BA  2  84 98              STY   Lvarph            ; save var address high byte
00C7BC  2  A9 C1              LDA   #TK_EQUAL         ; get = token
00C7BE  2  20 F1 CB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00C7C1  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00C7C3  2  48                 PHA                     ; push data type flag
00C7C4  2  20 E1 CA           JSR   LAB_EVEX          ; evaluate expression
00C7C7  2  68                 PLA                     ; pop data type flag
00C7C8  2  2A                 ROL                     ; set carry if type = string
00C7C9  2               ; *** begin patch  result of a string compare stores string pointer to variable
00C7C9  2               ;                  but should store FAC1 (true/false value)
00C7C9  2               ; *** replace
00C7C9  2               ;      JSR   LAB_CKTM          ; type match check, set C for string
00C7C9  2               ;      BNE   LAB_17D5          ; branch if string
00C7C9  2               ; *** with
00C7C9  2  20 D3 CA           JSR   LAB_CKTM          ; type match check, keep C (expected type)
00C7CC  2  B0 03              BCS   LAB_17D5          ; branch if string
00C7CE  2               ; *** end patch
00C7CE  2               
00C7CE  2  4C B0 D8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
00C7D1  2               
00C7D1  2               ; string LET
00C7D1  2               
00C7D1  2               LAB_17D5:
00C7D1  2  A0 02              LDY   #$02              ; set index to pointer high byte
00C7D3  2  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
00C7D5  2  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
00C7D7  2  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
00C7D9  2               
00C7D9  2  D0 07              BNE   LAB_17E6          ; branch if >
00C7DB  2                                             ; else was equal so compare low bytes
00C7DB  2  88                 DEY                     ; decrement index
00C7DC  2  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
00C7DE  2  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
00C7E0  2  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
00C7E2  2               
00C7E2  2                                             ; pointer was >= to bottom of string space pointer
00C7E2  2               LAB_17E6:
00C7E2  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00C7E4  2  C4 7C              CPY   Svarh             ; compare start of vars high byte
00C7E6  2  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
00C7E8  2               
00C7E8  2  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
00C7EA  2               
00C7EA  2                                             ; else high bytes were equal so ..
00C7EA  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00C7EC  2  C5 7B              CMP   Svarl             ; compare start of vars low byte
00C7EE  2  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
00C7F0  2               
00C7F0  2               LAB_17F4:
00C7F0  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00C7F2  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00C7F4  2  4C 0D C8           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
00C7F7  2               
00C7F7  2                                             ; make space and copy string
00C7F7  2               LAB_17FB:
00C7F7  2  A0 00              LDY   #$00              ; index to length
00C7F9  2  B1 AE              LDA   (des_pl),Y        ; get string length
00C7FB  2  20 40 D1           JSR   LAB_209C          ; copy string
00C7FE  2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
00C800  2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
00C802  2  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
00C804  2  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
00C806  2  20 25 D3           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
00C809  2  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
00C80B  2  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
00C80D  2               
00C80D  2                                             ; clean stack and assign value to string variable
00C80D  2               LAB_1811:
00C80D  2  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
00C80F  2  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
00C811  2  20 87 D3           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
00C814  2  A0 00              LDY   #$00              ; index to length
00C816  2  B1 9E              LDA   (des_2l),Y        ; get string length
00C818  2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00C81A  2  C8                 INY                     ; index to string pointer low byte
00C81B  2  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
00C81D  2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00C81F  2  C8                 INY                     ; index to string pointer high byte
00C820  2  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
00C822  2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00C824  2  60                 RTS
00C825  2               
00C825  2               ; perform GET
00C825  2               
00C825  2               LAB_GET:
00C825  2  20 B8 CD           JSR   LAB_GVAR          ; get var address
00C828  2  85 97              STA   Lvarpl            ; save var address low byte
00C82A  2  84 98              STY   Lvarph            ; save var address high byte
00C82C  2  20 0F DF           JSR   INGET             ; get input byte
00C82F  2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
00C831  2  30 07              BMI   LAB_GETS          ; go get string character
00C833  2               
00C833  2                                             ; was numeric get
00C833  2  A8                 TAY                     ; copy character to Y
00C834  2  20 74 D0           JSR   LAB_1FD0          ; convert Y to byte in FAC1
00C837  2  4C B0 D8           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
00C83A  2               
00C83A  2               LAB_GETS:
00C83A  2  48                 PHA                     ; save character
00C83B  2  A9 01              LDA   #$01              ; string is single byte
00C83D  2  B0 01              BCS   LAB_IsByte        ; branch if byte received
00C83F  2               
00C83F  2  68                 PLA                     ; string is null
00C840  2               LAB_IsByte:
00C840  2  20 48 D1           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00C843  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00C843  2  F0 05              BEQ   LAB_NoSt          ; skip store if null string
00C845  2               
00C845  2  68                 PLA                     ; get character back
00C846  2  A0 00              LDY   #$00              ; clear index
00C848  2  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
00C84A  2               LAB_NoSt:
00C84A  2  20 95 D1           JSR   LAB_RTST          ; check for space on descriptor stack then put address
00C84D  2                                             ; and length on descriptor stack and update stack pointers
00C84D  2               
00C84D  2  4C D1 C7           JMP   LAB_17D5          ; do string LET and return
00C850  2               
00C850  2               ; perform PRINT
00C850  2               
00C850  2               LAB_1829:
00C850  2  20 D7 C8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
00C853  2               LAB_182C:
00C853  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C856  2               
00C856  2               ; PRINT
00C856  2               
00C856  2               LAB_PRINT:
00C856  2  F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
00C858  2               
00C858  2               LAB_1831:
00C858  2  C9 AB              CMP   #TK_TAB           ; compare with TAB( token
00C85A  2  F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
00C85C  2               
00C85C  2  C9 AF              CMP   #TK_SPC           ; compare with SPC( token
00C85E  2  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
00C860  2               
00C860  2  C9 2C              CMP   #','              ; compare with ","
00C862  2  F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
00C864  2               
00C864  2  C9 3B              CMP   #';'              ; compare with ";"
00C866  2  F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
00C868  2               
00C868  2  20 E1 CA           JSR   LAB_EVEX          ; evaluate expression
00C86B  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00C86D  2  30 E1              BMI   LAB_1829          ; branch if string
00C86F  2               
00C86F  2  20 A2 DA           JSR   LAB_296E          ; convert FAC1 to string
00C872  2  20 52 D1           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
00C875  2  A0 00              LDY   #$00              ; clear index
00C877  2               
00C877  2               ; don't check fit if terminal width byte is zero
00C877  2               
00C877  2  A5 0F              LDA   TWidth            ; get terminal width byte
00C879  2  F0 0A              BEQ   LAB_185E          ; skip check if zero
00C87B  2               
00C87B  2  38                 SEC                     ; set carry for subtract
00C87C  2  E5 0E              SBC   TPos              ; subtract terminal position
00C87E  2  F1 AE              SBC   (des_pl),Y        ; subtract string length
00C880  2  B0 03              BCS   LAB_185E          ; branch if less than terminal width
00C882  2               
00C882  2  20 93 C8           JSR   LAB_CRLF          ; else print CR/LF
00C885  2               LAB_185E:
00C885  2  20 D7 C8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
00C888  2  F0 C9              BEQ   LAB_182C          ; always go continue processing line
00C88A  2               
00C88A  2               ; CR/LF return to BASIC from BASIC input handler
00C88A  2               
00C88A  2               LAB_1866:
00C88A  2  A9 00              LDA   #$00              ; clear byte
00C88C  2  9D 21 08           STA   Ibuffs,X          ; null terminate input
00C88F  2  A2 21              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
00C891  2  A0 08              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
00C893  2               
00C893  2               ; print CR/LF
00C893  2               
00C893  2               LAB_CRLF:
00C893  2  A9 0D              LDA   #$0D              ; load [CR]
00C895  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C898  2  A9 0A              LDA   #$0A              ; load [LF]
00C89A  2  D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
00C89C  2               
00C89C  2               LAB_188B:
00C89C  2  A5 0E              LDA   TPos              ; get terminal position
00C89E  2  C5 10              CMP   Iclim             ; compare with input column limit
00C8A0  2  90 05              BCC   LAB_1897          ; branch if less
00C8A2  2               
00C8A2  2  20 93 C8           JSR   LAB_CRLF          ; else print CR/LF (next line)
00C8A5  2  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
00C8A7  2               
00C8A7  2               LAB_1897:
00C8A7  2  38                 SEC                     ; set carry for subtract
00C8A8  2               LAB_1898:
00C8A8  2  E5 64              SBC   TabSiz            ; subtract TAB size
00C8AA  2  B0 FC              BCS   LAB_1898          ; loop if result was +ve
00C8AC  2               
00C8AC  2  49 FF              EOR   #$FF              ; complement it
00C8AE  2  69 01              ADC   #$01              ; +1 (twos complement)
00C8B0  2  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
00C8B2  2               
00C8B2  2                                             ; do TAB/SPC
00C8B2  2               LAB_18A2:
00C8B2  2  48                 PHA                     ; save token
00C8B3  2  20 9D D4           JSR   LAB_SGBY          ; scan and get byte parameter
00C8B6  2  C9 29              CMP   #$29              ; is next character )
00C8B8  2  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
00C8BA  2               
00C8BA  2  68                 PLA                     ; get token back
00C8BB  2  C9 AB              CMP   #TK_TAB           ; was it TAB ?
00C8BD  2  D0 06              BNE   LAB_18B7          ; if not go do SPC
00C8BF  2               
00C8BF  2                                             ; calculate TAB offset
00C8BF  2  8A                 TXA                     ; copy integer value to A
00C8C0  2  E5 0E              SBC   TPos              ; subtract terminal position
00C8C2  2  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
00C8C4  2               
00C8C4  2                                             ; print A spaces
00C8C4  2               LAB_18B6:
00C8C4  2  AA                 TAX                     ; copy result to X
00C8C5  2               LAB_18B7:
00C8C5  2  8A                 TXA                     ; set flags on size for SPC
00C8C6  2  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
00C8C8  2               
00C8C8  2                                             ; print X spaces
00C8C8  2               LAB_18BA:
00C8C8  2  20 E9 C8           JSR   LAB_18E0          ; print " "
00C8CB  2  CA                 DEX                     ; decrement count
00C8CC  2  D0 FA              BNE   LAB_18BA          ; loop if not all done
00C8CE  2               
00C8CE  2                                             ; continue with PRINT processing
00C8CE  2               LAB_18BD:
00C8CE  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C8D1  2  D0 85              BNE   LAB_1831          ; if more to print go do it
00C8D3  2               
00C8D3  2  60                 RTS
00C8D4  2               
00C8D4  2               ; print null terminated string from memory
00C8D4  2               
00C8D4  2               LAB_18C3:
00C8D4  2  20 52 D1           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
00C8D7  2               
00C8D7  2               ; print string from Sutill/Sutilh
00C8D7  2               
00C8D7  2               LAB_18C6:
00C8D7  2  20 52 D3           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00C8DA  2                                             ; space returns with A = length, X=$71=pointer low byte,
00C8DA  2                                             ; Y=$72=pointer high byte
00C8DA  2  A0 00              LDY   #$00              ; reset index
00C8DC  2  AA                 TAX                     ; copy length to X
00C8DD  2  F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
00C8DF  2               
00C8DF  2               LAB_18CD:
00C8DF  2               
00C8DF  2  B1 71              LDA   (ut1_pl),Y        ; get next byte
00C8E1  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C8E4  2  C8                 INY                     ; increment index
00C8E5  2  CA                 DEX                     ; decrement count
00C8E6  2  D0 F7              BNE   LAB_18CD          ; loop if not done yet
00C8E8  2               
00C8E8  2  60                 RTS
00C8E9  2               
00C8E9  2                                             ; Print single format character
00C8E9  2               ; print " "
00C8E9  2               
00C8E9  2               LAB_18E0:
00C8E9  2  A9 20              LDA   #$20              ; load " "
00C8EB  2  2C                 .byte $2C               ; change next line to BIT LAB_3FA9
00C8EC  2               
00C8EC  2               ; print "?" character
00C8EC  2               
00C8EC  2               LAB_18E3:
00C8EC  2  A9 3F              LDA   #$3F              ; load "?" character
00C8EE  2               
00C8EE  2               ; print character in A
00C8EE  2               ; now includes the null handler
00C8EE  2               ; also includes infinite line length code
00C8EE  2               ; note! some routines expect this one to exit with Zb=0
00C8EE  2               
00C8EE  2               LAB_PRNA:
00C8EE  2  C9 20              CMP   #' '              ; compare with " "
00C8F0  2  90 19              BCC   LAB_18F9          ; branch if less (non printing)
00C8F2  2               
00C8F2  2                                             ; else printable character
00C8F2  2  48                 PHA                     ; save the character
00C8F3  2               
00C8F3  2               ; don't check fit if terminal width byte is zero
00C8F3  2               
00C8F3  2  A5 0F              LDA   TWidth            ; get terminal width
00C8F5  2  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
00C8F7  2               
00C8F7  2               ; is "infinite line" so check TAB position
00C8F7  2               
00C8F7  2  A5 0E              LDA   TPos              ; get position
00C8F9  2  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
00C8FB  2  D0 0B              BNE   LAB_18F7          ; skip reset if different
00C8FD  2               
00C8FD  2  85 0E              STA   TPos              ; else reset position
00C8FF  2  F0 07              BEQ   LAB_18F7          ; go print character
00C901  2               
00C901  2               LAB_18F0:
00C901  2  C5 0E              CMP   TPos              ; compare with terminal character position
00C903  2  D0 03              BNE   LAB_18F7          ; branch if not at end of line
00C905  2               
00C905  2  20 93 C8           JSR   LAB_CRLF          ; else print CR/LF
00C908  2               LAB_18F7:
00C908  2  E6 0E              INC   TPos              ; increment terminal position
00C90A  2  68                 PLA                     ; get character back
00C90B  2               LAB_18F9:
00C90B  2  20 FC E0           JSR   V_OUTP            ; output byte via output vector
00C90E  2  C9 0D              CMP   #$0D              ; compare with [CR]
00C910  2  D0 14              BNE   LAB_188A          ; branch if not [CR]
00C912  2               
00C912  2                                             ; else print nullct nulls after the [CR]
00C912  2  86 78              STX   TempB             ; save buffer index
00C914  2  A6 0D              LDX   Nullct            ; get null count
00C916  2  F0 0A              BEQ   LAB_1886          ; branch if no nulls
00C918  2               
00C918  2  A9 00              LDA   #$00              ; load [NULL]
00C91A  2               LAB_1880:
00C91A  2  20 EE C8           JSR   LAB_PRNA          ; go print the character
00C91D  2  CA                 DEX                     ; decrement count
00C91E  2  D0 FA              BNE   LAB_1880          ; loop if not all done
00C920  2               
00C920  2  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
00C922  2               LAB_1886:
00C922  2  86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
00C924  2  A6 78              LDX   TempB             ; restore buffer index
00C926  2               LAB_188A:
00C926  2  29 FF              AND   #$FF              ; set the flags
00C928  2               LAB_188C:
00C928  2  60                 RTS
00C929  2               
00C929  2               ; handle bad input data
00C929  2               
00C929  2               LAB_1904:
00C929  2  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
00C92B  2  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
00C92D  2               
00C92D  2  A5 8D              LDA   Dlinel            ; get current DATA line low byte
00C92F  2  A4 8E              LDY   Dlineh            ; get current DATA line high byte
00C931  2  85 87              STA   Clinel            ; save current line low byte
00C933  2  84 88              STY   Clineh            ; save current line high byte
00C935  2               LAB_1910:
00C935  2  4C 02 CC           JMP   LAB_SNER          ; do syntax error then warm start
00C938  2               
00C938  2                                             ; mode was INPUT
00C938  2               LAB_1913:
00C938  2  A9 21              LDA   #<LAB_REDO        ; point to redo message (low addr)
00C93A  2  A0 E8              LDY   #>LAB_REDO        ; point to redo message (high addr)
00C93C  2  20 D4 C8           JSR   LAB_18C3          ; print null terminated string from memory
00C93F  2  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
00C941  2  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
00C943  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00C945  2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
00C947  2  60                 RTS
00C948  2               
00C948  2               ; perform INPUT
00C948  2               
00C948  2               LAB_INPUT:
00C948  2  C9 22              CMP   #$22              ; compare next byte with open quote
00C94A  2  D0 0B              BNE   LAB_1934          ; branch if no prompt string
00C94C  2               
00C94C  2  20 BE CB           JSR   LAB_1BC1          ; print "..." string
00C94F  2  A9 3B              LDA   #$3B              ; load A with ";"
00C951  2  20 F1 CB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00C954  2  20 D7 C8           JSR   LAB_18C6          ; print string from Sutill/Sutilh
00C957  2               
00C957  2                                             ; done with prompt, now get data
00C957  2               LAB_1934:
00C957  2  20 78 D0           JSR   LAB_CKRN          ; check not Direct, back here if ok
00C95A  2  20 43 C2           JSR   LAB_INLN          ; print "? " and get BASIC input
00C95D  2  A9 00              LDA   #$00              ; set mode = INPUT
00C95F  2  CD 21 08           CMP   Ibuffs            ; test first byte in buffer
00C962  2  D0 09              BNE   LAB_1953          ; branch if not null input
00C964  2               
00C964  2               ; *** change p2: keep carry set to throw break message
00C964  2               ;      CLC                     ; was null input so clear carry to exit program
00C964  2  4C 28 C5           JMP   LAB_1647          ; go do BREAK exit
00C967  2               
00C967  2               ; perform READ
00C967  2               
00C967  2               LAB_READ:
00C967  2  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
00C969  2  A4 90              LDY   Dptrh             ; get DATA pointer high byte
00C96B  2  A9 80              LDA   #$80              ; set mode = READ
00C96D  2               
00C96D  2               LAB_1953:
00C96D  2  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
00C96F  2  86 91              STX   Rdptrl            ; save READ pointer low byte
00C971  2  84 92              STY   Rdptrh            ; save READ pointer high byte
00C973  2               
00C973  2                                             ; READ or INPUT next variable from list
00C973  2               LAB_195B:
00C973  2  20 B8 CD           JSR   LAB_GVAR          ; get (var) address
00C976  2  85 97              STA   Lvarpl            ; save address low byte
00C978  2  84 98              STY   Lvarph            ; save address high byte
00C97A  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C97C  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00C97E  2  85 11              STA   Itempl            ; save as temporary integer low byte
00C980  2  84 12              STY   Itemph            ; save as temporary integer high byte
00C982  2  A6 91              LDX   Rdptrl            ; get READ pointer low byte
00C984  2  A4 92              LDY   Rdptrh            ; get READ pointer high byte
00C986  2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00C988  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00C98A  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C98D  2  D0 11              BNE   LAB_1988          ; branch if not null
00C98F  2               
00C98F  2                                             ; pointer was to null entry
00C98F  2  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
00C991  2  30 65              BMI   LAB_19DD          ; branch if READ
00C993  2               
00C993  2                                             ; mode was INPUT
00C993  2  20 EC C8           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
00C996  2  20 43 C2           JSR   LAB_INLN          ; print "? " and get BASIC input
00C999  2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00C99B  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00C99D  2               LAB_1985:
00C99D  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C9A0  2               LAB_1988:
00C9A0  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00C9A2  2  10 24              BPL   LAB_19B0          ; branch if numeric
00C9A4  2               
00C9A4  2                                             ; else get string
00C9A4  2  85 5B              STA   Srchc             ; save search character
00C9A6  2  C9 22              CMP   #$22              ; was it " ?
00C9A8  2  F0 07              BEQ   LAB_1999          ; branch if so
00C9AA  2               
00C9AA  2  A9 3A              LDA   #':'              ; else search character is ":"
00C9AC  2  85 5B              STA   Srchc             ; set new search character
00C9AE  2  A9 2C              LDA   #','              ; other search character is ","
00C9B0  2  18                 CLC                     ; clear carry for add
00C9B1  2               LAB_1999:
00C9B1  2  85 5C              STA   Asrch             ; set second search character
00C9B3  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00C9B5  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00C9B7  2               
00C9B7  2  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
00C9B9  2  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
00C9BB  2               
00C9BB  2  C8                 INY                     ; else increment high byte
00C9BC  2               LAB_19A4:
00C9BC  2  20 58 D1           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
00C9BF  2  20 DC D4           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00C9C2  2  20 D1 C7           JSR   LAB_17D5          ; go do string LET
00C9C5  2  4C CE C9           JMP   LAB_19B6          ; go check string terminator
00C9C8  2               
00C9C8  2                                             ; get numeric INPUT
00C9C8  2               LAB_19B0:
00C9C8  2  20 B3 D9           JSR   LAB_2887          ; get FAC1 from string
00C9CB  2  20 B0 D8           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
00C9CE  2               LAB_19B6:
00C9CE  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C9D1  2  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
00C9D3  2               
00C9D3  2  C9 2C              CMP   #','              ; else compare with ","
00C9D5  2  F0 03              BEQ   LAB_19C2          ; branch if ","
00C9D7  2               
00C9D7  2  4C 29 C9           JMP   LAB_1904          ; else go handle bad input data
00C9DA  2               
00C9DA  2                                             ; got good input data
00C9DA  2               LAB_19C2:
00C9DA  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00C9DD  2               LAB_19C5:
00C9DD  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
00C9DF  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
00C9E1  2  85 91              STA   Rdptrl            ; save for now
00C9E3  2  84 92              STY   Rdptrh            ; save for now
00C9E5  2  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
00C9E7  2  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
00C9E9  2  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
00C9EB  2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00C9ED  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00C9F0  2  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
00C9F2  2               
00C9F2  2  20 FE CB           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
00C9F5  2  4C 73 C9           JMP   LAB_195B          ; go INPUT next variable from list
00C9F8  2               
00C9F8  2                                             ; find next DATA statement or do "Out of DATA" error
00C9F8  2               LAB_19DD:
00C9F8  2  20 9B C6           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00C9FB  2  C8                 INY                     ; increment index
00C9FC  2  AA                 TAX                     ; copy character ([:] or [EOL])
00C9FD  2  D0 12              BNE   LAB_19F6          ; branch if [:]
00C9FF  2               
00C9FF  2  A2 06              LDX   #$06              ; set for "Out of DATA" error
00CA01  2  C8                 INY                     ; increment index, now points to next line pointer high byte
00CA02  2  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
00CA04  2  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
00CA06  2               
00CA06  2  C8                 INY                     ; increment index
00CA07  2  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
00CA09  2  85 8D              STA   Dlinel            ; save current DATA line low byte
00CA0B  2  C8                 INY                     ; increment index
00CA0C  2  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
00CA0E  2  C8                 INY                     ; increment index
00CA0F  2  85 8E              STA   Dlineh            ; save current DATA line high byte
00CA11  2               LAB_19F6:
00CA11  2  B1 C3              LDA   (Bpntrl),Y        ; get byte
00CA13  2  C8                 INY                     ; increment index
00CA14  2  AA                 TAX                     ; copy to X
00CA15  2  20 8D C6           JSR   LAB_170F          ; set BASIC execute pointer
00CA18  2  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
00CA1A  2  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
00CA1C  2               
00CA1C  2  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
00CA1E  2               
00CA1E  2               ; end of INPUT/READ routine
00CA1E  2               
00CA1E  2               LAB_1A03:
00CA1E  2  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
00CA20  2  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
00CA22  2  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
00CA24  2  10 03              BPL   LAB_1A0E          ; branch if INPUT
00CA26  2               
00CA26  2  4C 4A C5           JMP   LAB_1624          ; save AY as DATA pointer and return
00CA29  2               
00CA29  2                                             ; we were getting INPUT
00CA29  2               LAB_1A0E:
00CA29  2  A0 00              LDY   #$00              ; clear index
00CA2B  2  B1 91              LDA   (Rdptrl),Y        ; get next byte
00CA2D  2  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
00CA2F  2               
00CA2F  2  60                 RTS
00CA30  2               
00CA30  2                                             ; user typed too much
00CA30  2               LAB_1A1B:
00CA30  2  A9 10              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
00CA32  2  A0 E8              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
00CA34  2  4C D4 C8           JMP   LAB_18C3          ; print null terminated string from memory and return
00CA37  2               
00CA37  2               ; search the stack for FOR activity
00CA37  2               ; exit with z=1 if FOR else exit with z=0
00CA37  2               
00CA37  2               LAB_11A1:
00CA37  2  BA                 TSX                     ; copy stack pointer
00CA38  2  E8                 INX                     ; +1 pass return address
00CA39  2  E8                 INX                     ; +2 pass return address
00CA3A  2  E8                 INX                     ; +3 pass calling routine return address
00CA3B  2  E8                 INX                     ; +4 pass calling routine return address
00CA3C  2               LAB_11A6:
00CA3C  2  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
00CA3F  2  C9 81              CMP   #TK_FOR           ; is it FOR token
00CA41  2  D0 21              BNE   LAB_11CE          ; exit if not FOR token
00CA43  2               
00CA43  2                                             ; was FOR token
00CA43  2  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
00CA45  2  D0 0A              BNE   LAB_11BB          ; branch if not null
00CA47  2               
00CA47  2  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
00CA4A  2  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
00CA4C  2  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
00CA4F  2  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
00CA51  2               LAB_11BB:
00CA51  2  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
00CA54  2  D0 07              BNE   LAB_11C7          ; branch if no match
00CA56  2               
00CA56  2  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
00CA58  2  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
00CA5B  2  F0 07              BEQ   LAB_11CE          ; exit if match found
00CA5D  2               
00CA5D  2               LAB_11C7:
00CA5D  2  8A                 TXA                     ; copy index
00CA5E  2  18                 CLC                     ; clear carry for add
00CA5F  2  69 10              ADC   #$10              ; add FOR stack use size
00CA61  2  AA                 TAX                     ; copy back to index
00CA62  2  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
00CA64  2               
00CA64  2               LAB_11CE:
00CA64  2  60                 RTS
00CA65  2               
00CA65  2               ; perform NEXT
00CA65  2               
00CA65  2               LAB_NEXT:
00CA65  2  D0 04              BNE   LAB_1A46          ; branch if NEXT var
00CA67  2               
00CA67  2  A0 00              LDY   #$00              ; else clear Y
00CA69  2  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
00CA6B  2               
00CA6B  2               ; NEXT var
00CA6B  2               
00CA6B  2               LAB_1A46:
00CA6B  2  20 B8 CD           JSR   LAB_GVAR          ; get variable address
00CA6E  2               LAB_1A49:
00CA6E  2  85 97              STA   Frnxtl            ; store variable pointer low byte
00CA70  2  84 98              STY   Frnxth            ; store variable pointer high byte
00CA72  2                                             ; (both cleared if no variable defined)
00CA72  2  20 37 CA           JSR   LAB_11A1          ; search the stack for FOR activity
00CA75  2  F0 04              BEQ   LAB_1A56          ; branch if found
00CA77  2               
00CA77  2  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
00CA79  2               LAB_1A54:
00CA79  2  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
00CA7B  2               
00CA7B  2               LAB_1A56:
00CA7B  2  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
00CA7C  2               
00CA7C  2  8A                 TXA                     ; copy stack pointer
00CA7D  2  38                 SEC                     ; set carry for subtract
00CA7E  2  E9 F7              SBC   #$F7              ; point to TO var
00CA80  2  85 73              STA   ut2_pl            ; save pointer to TO var for compare
00CA82  2  69 FB              ADC   #$FB              ; point to STEP var
00CA84  2               
00CA84  2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
00CA86  2  20 8A D8           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
00CA89  2  BA                 TSX                     ; get stack pointer back
00CA8A  2  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
00CA8D  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00CA8F  2  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
00CA91  2  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
00CA93  2  20 CB D5           JSR   LAB_246C          ; add (FOR variable) to FAC1
00CA96  2  20 B0 D8           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
00CA99  2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
00CA9B  2  20 26 D9           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
00CA9E  2  BA                 TSX                     ; get stack pointer back
00CA9F  2  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
00CAA2  2  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
00CAA4  2               
00CAA4  2                                             ; loop back and do it all again
00CAA4  2  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
00CAA7  2  85 87              STA   Clinel            ; save current line low byte
00CAA9  2  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
00CAAC  2  85 88              STA   Clineh            ; save current line high byte
00CAAE  2  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
00CAB1  2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00CAB3  2  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
00CAB6  2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00CAB8  2               LAB_1A98:
00CAB8  2  4C C0 C4           JMP   LAB_15C2          ; go do interpreter inner loop
00CABB  2               
00CABB  2                                             ; loop complete so carry on
00CABB  2               LAB_1A9B:
00CABB  2  8A                 TXA                     ; stack copy to A
00CABC  2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
00CABE  2  AA                 TAX                     ; copy back to index
00CABF  2  9A                 TXS                     ; copy to stack pointer
00CAC0  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CAC3  2  C9 2C              CMP   #','              ; compare with ","
00CAC5  2  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
00CAC7  2               
00CAC7  2                                             ; was "," so another NEXT variable to do
00CAC7  2  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
00CACA  2  20 6B CA           JSR   LAB_1A46          ; do NEXT (var)
00CACD  2               
00CACD  2               ; evaluate expression and check is numeric, else do type mismatch
00CACD  2               
00CACD  2               LAB_EVNM:
00CACD  2  20 E1 CA           JSR   LAB_EVEX          ; evaluate expression
00CAD0  2               
00CAD0  2               ; check if source is numeric, else do type mismatch
00CAD0  2               
00CAD0  2               LAB_CTNM:
00CAD0  2  18                 CLC                     ; destination is numeric
00CAD1  2  24                 .byte $24               ; makes next line BIT $38
00CAD2  2               
00CAD2  2               ; check if source is string, else do type mismatch
00CAD2  2               
00CAD2  2               LAB_CTST:
00CAD2  2  38                 SEC                     ; required type is string
00CAD3  2               
00CAD3  2               ; type match check, set C for string, clear C for numeric
00CAD3  2               
00CAD3  2               LAB_CKTM:
00CAD3  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00CAD5  2  30 03              BMI   LAB_1ABA          ; branch if data type is string
00CAD7  2               
00CAD7  2                                             ; else data type was numeric
00CAD7  2  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
00CAD9  2               LAB_1AB9:
00CAD9  2  60                 RTS
00CADA  2               
00CADA  2                                             ; data type was string, now check required type
00CADA  2               LAB_1ABA:
00CADA  2  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
00CADC  2               
00CADC  2                                             ; else do type mismatch error
00CADC  2               LAB_1ABC:
00CADC  2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
00CADE  2               LAB_1ABE:
00CADE  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00CAE1  2               
00CAE1  2               ; evaluate expression
00CAE1  2               
00CAE1  2               LAB_EVEX:
00CAE1  2  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
00CAE3  2  D0 02              BNE   LAB_1AC7          ; skip next if not zero
00CAE5  2               
00CAE5  2  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
00CAE7  2               LAB_1AC7:
00CAE7  2  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
00CAE9  2               
00CAE9  2               LAB_EVEZ:
00CAE9  2  A9 00              LDA   #$00              ; set null precedence (flag done)
00CAEB  2               LAB_1ACC:
00CAEB  2  48                 PHA                     ; push precedence byte
00CAEC  2  A9 02              LDA   #$02              ; 2 bytes
00CAEE  2  20 03 C1           JSR   LAB_1212          ; check room on stack for A bytes
00CAF1  2  20 CD CB           JSR   LAB_GVAL          ; get value from line
00CAF4  2  A9 00              LDA   #$00              ; clear A
00CAF6  2  85 9B              STA   comp_f            ; clear compare function flag
00CAF8  2               LAB_1ADB:
00CAF8  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CAFB  2               LAB_1ADE:
00CAFB  2  38                 SEC                     ; set carry for subtract
00CAFC  2  E9 C0              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
00CAFE  2  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
00CB00  2               
00CB00  2  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
00CB02  2  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
00CB04  2               
00CB04  2                                             ; was token for > = or < (A = 0, 1 or 2)
00CB04  2  C9 01              CMP   #$01              ; compare with token for =
00CB06  2  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
00CB07  2                                             ; (A = 0, 3 or 5)
00CB07  2  49 01              EOR   #$01              ; toggle b0
00CB09  2                                             ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
00CB09  2  45 9B              EOR   comp_f            ; EOR with compare function flag bits
00CB0B  2  C5 9B              CMP   comp_f            ; compare with compare function flag
00CB0D  2  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
00CB0F  2                                             ; was more than one <, = or >)
00CB0F  2               
00CB0F  2  85 9B              STA   comp_f            ; save new compare function flag
00CB11  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CB14  2  4C FB CA           JMP   LAB_1ADE          ; go do next character
00CB17  2               
00CB17  2                                             ; token is < ">" or > "<" tokens
00CB17  2               LAB_1AFA:
00CB17  2  A6 9B              LDX   comp_f            ; get compare function flag
00CB19  2  D0 2C              BNE   LAB_1B2A          ; branch if compare function
00CB1B  2               
00CB1B  2  B0 79              BCS   LAB_1B78          ; go do functions
00CB1D  2               
00CB1D  2                                             ; else was <  TK_GT so is operator or lower
00CB1D  2  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
00CB1F  2  90 75              BCC   LAB_1B78          ; branch if < + operator
00CB21  2               
00CB21  2                                             ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
00CB21  2  D0 07              BNE   LAB_1B0B          ; branch if not + token
00CB23  2               
00CB23  2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00CB25  2  10 03              BPL   LAB_1B0B          ; branch if not string
00CB27  2               
00CB27  2                                             ; will only be $00 if type is string and token was +
00CB27  2  4C E8 D2           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
00CB2A  2                                             ; is in line, and return
00CB2A  2               
00CB2A  2               LAB_1B0B:
00CB2A  2  85 71              STA   ut1_pl            ; save it
00CB2C  2  0A                 ASL                     ; *2
00CB2D  2  65 71              ADC   ut1_pl            ; *3
00CB2F  2  A8                 TAY                     ; copy to index
00CB30  2               LAB_1B13:
00CB30  2  68                 PLA                     ; pull previous precedence
00CB31  2  D9 F8 E2           CMP   LAB_OPPT,Y        ; compare with precedence byte
00CB34  2  B0 65              BCS   LAB_1B7D          ; branch if A >=
00CB36  2               
00CB36  2  20 D0 CA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00CB39  2               LAB_1B1C:
00CB39  2  48                 PHA                     ; save precedence
00CB3A  2               LAB_1B1D:
00CB3A  2  20 62 CB           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
00CB3D  2  68                 PLA                     ; restore precedence
00CB3E  2  A4 99              LDY   prstk             ; get precedence stacked flag
00CB40  2  10 19              BPL   LAB_1B3C          ; branch if stacked values
00CB42  2               
00CB42  2  AA                 TAX                     ; copy precedence (set flags)
00CB43  2  F0 76              BEQ   LAB_1B9D          ; exit if done
00CB45  2               
00CB45  2  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
00CB47  2               
00CB47  2               LAB_1B2A:
00CB47  2  26 5F              ROL   Dtypef            ; shift data type flag into Cb
00CB49  2  8A                 TXA                     ; copy compare function flag
00CB4A  2  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
00CB4C  2  2A                 ROL                     ; shift data type into compare function byte b0
00CB4D  2  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
00CB4F  2  D0 02              BNE   LAB_1B34          ; branch if no underflow
00CB51  2               
00CB51  2  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
00CB53  2               LAB_1B34:
00CB53  2  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
00CB55  2               TK_LT_PLUS  = TK_LT-TK_PLUS
00CB55  2  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
00CB57  2  85 9B              STA   comp_f            ; save new compare function flag
00CB59  2  D0 D5              BNE   LAB_1B13          ; branch always
00CB5B  2               
00CB5B  2               LAB_1B3C:
00CB5B  2  D9 F8 E2           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
00CB5E  2  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
00CB60  2               
00CB60  2  90 D7              BCC   LAB_1B1C          ; branch always
00CB62  2               
00CB62  2               ;.get vector, execute function then continue evaluation
00CB62  2               
00CB62  2               LAB_1B43:
00CB62  2  B9 FA E2           LDA   LAB_OPPT+2,Y      ; get function vector high byte
00CB65  2  48                 PHA                     ; onto stack
00CB66  2  B9 F9 E2           LDA   LAB_OPPT+1,Y      ; get function vector low byte
00CB69  2  48                 PHA                     ; onto stack
00CB6A  2                                             ; now push sign, round FAC1 and put on stack
00CB6A  2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00CB6A  2               ; *** add
00CB6A  2                  .IF <* = $FD
00CB6A  2                     NOP                     ; return address of JSR +1 (on  next page)
00CB6A  2                  .ENDIF
00CB6A  2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
00CB6A  2  20 79 CB           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
00CB6D  2                                             ; the function
00CB6D  2  A5 9B              LDA   comp_f            ; get compare function flag
00CB6F  2  48                 PHA                     ; push compare evaluation byte
00CB70  2  B9 F8 E2           LDA   LAB_OPPT,Y        ; get precedence byte
00CB73  2  4C EB CA           JMP   LAB_1ACC          ; continue evaluating expression
00CB76  2               
00CB76  2               LAB_1B53:
00CB76  2  4C 02 CC           JMP   LAB_SNER          ; do syntax error then warm start
00CB79  2               
00CB79  2               ; push sign, round FAC1 and put on stack
00CB79  2               
00CB79  2               LAB_1B5B:
00CB79  2  68                 PLA                     ; get return addr low byte
00CB7A  2  85 71              STA   ut1_pl            ; save it
00CB7C  2  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
00CB7E  2                                             ; note! no check is made on the high byte! if the calling
00CB7E  2                                             ; routine assembles to a page edge then this all goes
00CB7E  2                                             ; horribly wrong !!!
00CB7E  2  68                 PLA                     ; get return addr high byte
00CB7F  2  85 72              STA   ut1_ph            ; save it
00CB81  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00CB83  2  48                 PHA                     ; push sign
00CB84  2               
00CB84  2               ; round FAC1 and put on stack
00CB84  2               
00CB84  2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
00CB84  2               ; *** replace
00CB84  2               ;LAB_1B66
00CB84  2               ;      JSR   LAB_27BA          ; round FAC1
00CB84  2               ; *** with
00CB84  2  20 E6 D8           JSR   LAB_27BA          ; round FAC1
00CB87  2               LAB_1B66:
00CB87  2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
00CB87  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CB89  2  48                 PHA                     ; push on stack
00CB8A  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CB8C  2  48                 PHA                     ; push on stack
00CB8D  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00CB8F  2  48                 PHA                     ; push on stack
00CB90  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00CB92  2  48                 PHA                     ; push on stack
00CB93  2  6C 71 00           JMP   (ut1_pl)          ; return, sort of
00CB96  2               
00CB96  2               ; do functions
00CB96  2               
00CB96  2               LAB_1B78:
00CB96  2  A0 FF              LDY   #$FF              ; flag function
00CB98  2  68                 PLA                     ; pull precedence byte
00CB99  2               LAB_1B7B:
00CB99  2  F0 20              BEQ   LAB_1B9D          ; exit if done
00CB9B  2               
00CB9B  2               LAB_1B7D:
00CB9B  2  C9 64              CMP   #$64              ; compare previous precedence with $64
00CB9D  2  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
00CB9F  2               
00CB9F  2  20 D0 CA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00CBA2  2               LAB_1B84:
00CBA2  2  84 99              STY   prstk             ; save precedence stacked flag
00CBA4  2               
00CBA4  2                                             ; pop FAC2 and return
00CBA4  2               LAB_1B86:
00CBA4  2  68                 PLA                     ; pop byte
00CBA5  2  4A                 LSR                     ; shift out comparison evaluation lowest bit
00CBA6  2  85 63              STA   Cflag             ; save comparison evaluation flag
00CBA8  2  68                 PLA                     ; pop exponent
00CBA9  2  85 B3              STA   FAC2_e            ; save FAC2 exponent
00CBAB  2  68                 PLA                     ; pop mantissa1
00CBAC  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00CBAE  2  68                 PLA                     ; pop mantissa2
00CBAF  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00CBB1  2  68                 PLA                     ; pop mantissa3
00CBB2  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00CBB4  2  68                 PLA                     ; pop sign
00CBB5  2  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
00CBB7  2  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
00CBB9  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00CBBB  2               LAB_1B9D:
00CBBB  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00CBBD  2  60                 RTS
00CBBE  2               
00CBBE  2               ; print "..." string to string util area
00CBBE  2               
00CBBE  2               LAB_1BC1:
00CBBE  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00CBC0  2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00CBC2  2  69 00              ADC   #$00              ; add carry to low byte
00CBC4  2  90 01              BCC   LAB_1BCA          ; branch if no overflow
00CBC6  2               
00CBC6  2  C8                 INY                     ; increment high byte
00CBC7  2               LAB_1BCA:
00CBC7  2  20 52 D1           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
00CBCA  2  4C DC D4           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
00CBCD  2               
00CBCD  2               ; get value from line
00CBCD  2               
00CBCD  2               LAB_GVAL:
00CBCD  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CBD0  2  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
00CBD2  2               
00CBD2  2                                             ; else numeric string found (e.g. 123)
00CBD2  2               LAB_1BA9:
00CBD2  2  4C B3 D9           JMP   LAB_2887          ; get FAC1 from string and return
00CBD5  2               
00CBD5  2               ; get value from line .. continued
00CBD5  2               
00CBD5  2                                             ; wasn't a number so ..
00CBD5  2               LAB_1BAC:
00CBD5  2  AA                 TAX                     ; set the flags
00CBD6  2  30 2F              BMI   LAB_1BD0          ; if -ve go test token values
00CBD8  2               
00CBD8  2                                             ; else it is either a string, number, variable or (<expr>)
00CBD8  2  C9 24              CMP   #'$'              ; compare with "$"
00CBDA  2  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
00CBDC  2               
00CBDC  2  C9 25              CMP   #'%'              ; else compare with "%"
00CBDE  2  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
00CBE0  2               
00CBE0  2  C9 2E              CMP   #'.'              ; compare with "."
00CBE2  2  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
00CBE4  2               
00CBE4  2                                             ; it wasn't any sort of number so ..
00CBE4  2  C9 22              CMP   #$22              ; compare with "
00CBE6  2  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
00CBE8  2               
00CBE8  2                                             ; wasn't any sort of number so ..
00CBE8  2               
00CBE8  2               ; evaluate expression within parentheses
00CBE8  2               
00CBE8  2  C9 28              CMP   #'('              ; compare with "("
00CBEA  2  D0 5B              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
00CBEC  2               
00CBEC  2               LAB_1BF7:
00CBEC  2  20 E9 CA           JSR   LAB_EVEZ          ; evaluate expression, no decrement
00CBEF  2               
00CBEF  2               ; all the 'scan for' routines return the character after the sought character
00CBEF  2               
00CBEF  2               ; scan for ")" , else do syntax error then warm start
00CBEF  2               
00CBEF  2               LAB_1BFB:
00CBEF  2  A9 29              LDA   #$29              ; load A with ")"
00CBF1  2               
00CBF1  2               ; scan for CHR$(A) , else do syntax error then warm start
00CBF1  2               
00CBF1  2               LAB_SCCA:
00CBF1  2  A0 00              LDY   #$00              ; clear index
00CBF3  2  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
00CBF5  2  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
00CBF7  2               
00CBF7  2  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
00CBFA  2               
00CBFA  2               ; scan for "(" , else do syntax error then warm start
00CBFA  2               
00CBFA  2               LAB_1BFE:
00CBFA  2  A9 28              LDA   #$28              ; load A with "("
00CBFC  2  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00CBFE  2                                             ; (branch always)
00CBFE  2               
00CBFE  2               ; scan for "," , else do syntax error then warm start
00CBFE  2               
00CBFE  2               LAB_1C01:
00CBFE  2  A9 2C              LDA   #$2C              ; load A with ","
00CC00  2  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00CC02  2                                             ; (branch always)
00CC02  2               
00CC02  2               ; syntax error then warm start
00CC02  2               
00CC02  2               LAB_SNER:
00CC02  2  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
00CC04  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00CC07  2               
00CC07  2               ; get value from line .. continued
00CC07  2               ; do tokens
00CC07  2               
00CC07  2               LAB_1BD0:
00CC07  2  C9 B7              CMP   #TK_MINUS         ; compare with token for -
00CC09  2  F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
00CC0B  2               
00CC0B  2                                             ; wasn't -n so ..
00CC0B  2  C9 B6              CMP   #TK_PLUS          ; compare with token for +
00CC0D  2  F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
00CC0F  2               
00CC0F  2  C9 B1              CMP   #TK_NOT           ; compare with token for NOT
00CC11  2  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
00CC13  2               
00CC13  2                                             ; was NOT token
00CC13  2               TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
00CC13  2  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
00CC15  2  D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
00CC17  2               
00CC17  2               ; do = compare
00CC17  2               
00CC17  2               LAB_EQUAL:
00CC17  2  20 B4 CE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
00CC1A  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CC1C  2  49 FF              EOR   #$FF              ; invert it
00CC1E  2  A8                 TAY                     ; copy it
00CC1F  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CC21  2  49 FF              EOR   #$FF              ; invert it
00CC23  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CC26  2               
00CC26  2               ; get value from line .. continued
00CC26  2               
00CC26  2                                             ; wasn't +, -, or NOT so ..
00CC26  2               LAB_1BE7:
00CC26  2  C9 AE              CMP   #TK_FN            ; compare with token for FN
00CC28  2  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
00CC2A  2               
00CC2A  2  4C C2 D0           JMP   LAB_201E          ; go evaluate FNx
00CC2D  2               
00CC2D  2               ; get value from line .. continued
00CC2D  2               
00CC2D  2                                             ; wasn't +, -, NOT or FN so ..
00CC2D  2               LAB_1BEE:
00CC2D  2  E9 C3              SBC   #TK_SGN           ; subtract with token for SGN
00CC2F  2  B0 27              BCS   LAB_1C27          ; if a function token go do it
00CC31  2               
00CC31  2  4C 02 CC           JMP   LAB_SNER          ; else do syntax error
00CC34  2               
00CC34  2               ; set-up for functions
00CC34  2               
00CC34  2               LAB_1C11:
00CC34  2               TK_GT_PLUS  = TK_GT-TK_PLUS
00CC34  2  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
00CC36  2               LAB_1C13:
00CC36  2  68                 PLA                     ; dump return address low byte
00CC37  2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00CC37  2               ; *** replace
00CC37  2               ;      PLA                     ; dump return address high byte
00CC37  2               ;      JMP   LAB_1B1D          ; execute function then continue evaluation
00CC37  2               ; *** with
00CC37  2  AA                 TAX                     ; save to trap concatenate
00CC38  2  68                 PLA                     ; dump return address high byte
00CC39  2  E0 F0              CPX   #<(LAB_224Da+2)   ; from concatenate low return address?
00CC3B  2  D0 04              BNE   LAB_1C13b         ; No - continue!
00CC3D  2  C9 D2              CMP   #>(LAB_224Da+2)   ; from concatenate high return address?
00CC3F  2  F0 03              BEQ   LAB_1C13a         ; Yes - error!
00CC41  2               LAB_1C13b:
00CC41  2  4C 3A CB           JMP   LAB_1B1D          ; execute function then continue evaluation
00CC44  2               LAB_1C13a:
00CC44  2  4C DC CA           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start
00CC47  2               ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00CC47  2               
00CC47  2               ; variable name set-up
00CC47  2               ; get (var), return value in FAC_1 and $ flag
00CC47  2               
00CC47  2               LAB_1C18:
00CC47  2  20 B8 CD           JSR   LAB_GVAR          ; get (var) address
00CC4A  2  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
00CC4C  2  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
00CC4E  2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
00CC50  2  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
00CC52  2               
00CC52  2               LAB_1C24:
00CC52  2  4C 8A D8           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
00CC55  2               
00CC55  2               LAB_1C25:
00CC55  2               ; *** begin patch  string pointer high byte trashed when moved to stack
00CC55  2               ; *** add
00CC55  2  46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
00CC57  2               ; *** end patch
00CC57  2  60                 RTS
00CC58  2               
00CC58  2               ; get value from line .. continued
00CC58  2               ; only functions left so ..
00CC58  2               
00CC58  2               ; set up function references
00CC58  2               
00CC58  2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00CC58  2               ; to process function calls. now the function vector is computed and pushed on the stack
00CC58  2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
00CC58  2               ; is calculated and the routine called, if not this routine just does RTS. whichever
00CC58  2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
00CC58  2               ; the function code
00CC58  2               
00CC58  2               ; this also removes some less than elegant code that was used to bypass type checking
00CC58  2               ; for functions that returned strings
00CC58  2               
00CC58  2               LAB_1C27:
00CC58  2  0A                 ASL                     ; *2 (2 bytes per function address)
00CC59  2  A8                 TAY                     ; copy to index
00CC5A  2               
00CC5A  2  B9 B3 E2           LDA   LAB_FTBM,Y        ; get function jump vector high byte
00CC5D  2  48                 PHA                     ; push functions jump vector high byte
00CC5E  2  B9 B2 E2           LDA   LAB_FTBL,Y        ; get function jump vector low byte
00CC61  2  48                 PHA                     ; push functions jump vector low byte
00CC62  2               
00CC62  2  B9 6D E2           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
00CC65  2  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
00CC67  2               
00CC67  2  48                 PHA                     ; push functions pre process vector high byte
00CC68  2  B9 6C E2           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
00CC6B  2  48                 PHA                     ; push functions pre process vector low byte
00CC6C  2               
00CC6C  2               LAB_1C56:
00CC6C  2  60                 RTS                     ; do function, or pre process, call
00CC6D  2               
00CC6D  2               ; process string expression in parenthesis
00CC6D  2               
00CC6D  2               LAB_PPFS:
00CC6D  2  20 EC CB           JSR   LAB_1BF7          ; process expression in parenthesis
00CC70  2  4C D2 CA           JMP   LAB_CTST          ; check if source is string then do function,
00CC73  2                                             ; else do type mismatch
00CC73  2               
00CC73  2               ; process numeric expression in parenthesis
00CC73  2               
00CC73  2               LAB_PPFN:
00CC73  2  20 EC CB           JSR   LAB_1BF7          ; process expression in parenthesis
00CC76  2  4C D0 CA           JMP   LAB_CTNM          ; check if source is numeric then do function,
00CC79  2                                             ; else do type mismatch
00CC79  2               
00CC79  2               ; set numeric data type and increment BASIC execute pointer
00CC79  2               
00CC79  2               LAB_PPBI:
00CC79  2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00CC7B  2  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
00CC7E  2               
00CC7E  2               ; process string for LEFT$, RIGHT$ or MID$
00CC7E  2               
00CC7E  2               LAB_LRMS:
00CC7E  2  20 E9 CA           JSR   LAB_EVEZ          ; evaluate (should be string) expression
00CC81  2  20 FE CB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
00CC84  2  20 D2 CA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00CC87  2               
00CC87  2  68                 PLA                     ; get function jump vector low byte
00CC88  2  AA                 TAX                     ; save functions jump vector low byte
00CC89  2  68                 PLA                     ; get function jump vector high byte
00CC8A  2  A8                 TAY                     ; save functions jump vector high byte
00CC8B  2  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
00CC8D  2  48                 PHA                     ; push string pointer high byte
00CC8E  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00CC90  2  48                 PHA                     ; push string pointer low byte
00CC91  2  98                 TYA                     ; get function jump vector high byte back
00CC92  2  48                 PHA                     ; save functions jump vector high byte
00CC93  2  8A                 TXA                     ; get function jump vector low byte back
00CC94  2  48                 PHA                     ; save functions jump vector low byte
00CC95  2  20 A0 D4           JSR   LAB_GTBY          ; get byte parameter
00CC98  2  8A                 TXA                     ; copy byte parameter to A
00CC99  2  60                 RTS                     ; go do function
00CC9A  2               
00CC9A  2               ; process numeric expression(s) for BIN$ or HEX$
00CC9A  2               
00CC9A  2               LAB_BHSS:
00CC9A  2  20 E9 CA           JSR   LAB_EVEZ          ; process expression
00CC9D  2  20 D0 CA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00CCA0  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00CCA2  2  C9 98              CMP   #$98              ; compare with exponent = 2^24
00CCA4  2  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
00CCA6  2               
00CCA6  2  20 5D D9           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00CCA9  2  A2 02              LDX   #$02              ; 3 bytes to do
00CCAB  2               LAB_CFAC:
00CCAB  2  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
00CCAD  2  95 11              STA   nums_1,X          ; save byte to temp
00CCAF  2  CA                 DEX                     ; decrement index
00CCB0  2  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
00CCB2  2               
00CCB2  2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00CCB5  2  A2 00              LDX   #$00              ; set default to no leading "0"s
00CCB7  2  C9 29              CMP   #')'              ; compare with close bracket
00CCB9  2  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
00CCBB  2               
00CCBB  2  20 EB D4           JSR   LAB_SCGB          ; scan for "," and get byte
00CCBE  2  20 C2 00           JSR   LAB_GBYT          ; get last byte back
00CCC1  2  C9 29              CMP   #')'              ; is next character )
00CCC3  2  D0 01              BNE   LAB_BHER          ; if not ")" go do error
00CCC5  2               
00CCC5  2               LAB_1C54:
00CCC5  2  60                 RTS                     ; else do function
00CCC6  2               
00CCC6  2               LAB_BHER:
00CCC6  2  4C 37 CF           JMP   LAB_FCER          ; do function call error then warm start
00CCC9  2               
00CCC9  2               ; perform EOR
00CCC9  2               
00CCC9  2               ; added operator format is the same as AND or OR, precedence is the same as OR
00CCC9  2               
00CCC9  2               ; this bit worked first time but it took a while to sort out the operator table
00CCC9  2               ; pointers and offsets afterwards!
00CCC9  2               
00CCC9  2               LAB_EOR:
00CCC9  2  20 F0 CC           JSR   GetFirst          ; get first integer expression (no sign check)
00CCCC  2  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
00CCCE  2  A8                 TAY                     ; save in Y
00CCCF  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CCD1  2  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
00CCD3  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CCD6  2               
00CCD6  2               ; perform OR
00CCD6  2               
00CCD6  2               LAB_OR:
00CCD6  2  20 F0 CC           JSR   GetFirst          ; get first integer expression (no sign check)
00CCD9  2  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
00CCDB  2  A8                 TAY                     ; save in Y
00CCDC  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CCDE  2  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
00CCE0  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CCE3  2               
00CCE3  2               ; perform AND
00CCE3  2               
00CCE3  2               LAB_AND:
00CCE3  2  20 F0 CC           JSR   GetFirst          ; get first integer expression (no sign check)
00CCE6  2  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
00CCE8  2  A8                 TAY                     ; save in Y
00CCE9  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CCEB  2  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
00CCED  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CCF0  2               
00CCF0  2               ; get first value for OR, AND or EOR
00CCF0  2               
00CCF0  2               GetFirst:
00CCF0  2  20 B4 CE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
00CCF3  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00CCF5  2  85 5C              STA   XOAw_h            ; save it
00CCF7  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CCF9  2  85 5B              STA   XOAw_l            ; save it
00CCFB  2  20 D0 D5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
00CCFE  2  20 B4 CE           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
00CD01  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00CD03  2               LAB_1C95:
00CD03  2  60                 RTS
00CD04  2               
00CD04  2               ; perform comparisons
00CD04  2               
00CD04  2               ; do < compare
00CD04  2               
00CD04  2               LAB_LTHAN:
00CD04  2  20 D3 CA           JSR   LAB_CKTM          ; type match check, set C for string
00CD07  2  B0 13              BCS   LAB_1CAE          ; branch if string
00CD09  2               
00CD09  2                                             ; do numeric < compare
00CD09  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00CD0B  2  09 7F              ORA   #$7F              ; set all non sign bits
00CD0D  2  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
00CD0F  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00CD11  2  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
00CD13  2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
00CD15  2  20 24 D9           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
00CD18  2  AA                 TAX                     ; copy result
00CD19  2  4C 4D CD           JMP   LAB_1CE1          ; go evaluate result
00CD1C  2               
00CD1C  2                                             ; do string < compare
00CD1C  2               LAB_1CAE:
00CD1C  2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00CD1E  2  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
00CD20  2  20 52 D3           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00CD23  2                                             ; space returns with A = length, X=pointer low byte,
00CD23  2                                             ; Y=pointer high byte
00CD23  2  85 AC              STA   str_ln            ; save length
00CD25  2  86 AD              STX   str_pl            ; save string pointer low byte
00CD27  2  84 AE              STY   str_ph            ; save string pointer high byte
00CD29  2  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
00CD2B  2  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
00CD2D  2  20 56 D3           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00CD30  2                                             ; returns with A = length, X=pointer low byte,
00CD30  2                                             ; Y=pointer high byte
00CD30  2  86 B5              STX   FAC2_2            ; save string pointer low byte
00CD32  2  84 B6              STY   FAC2_3            ; save string pointer high byte
00CD34  2  AA                 TAX                     ; copy length
00CD35  2  38                 SEC                     ; set carry for subtract
00CD36  2  E5 AC              SBC   str_ln            ; subtract string 1 length
00CD38  2  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
00CD3A  2               
00CD3A  2  A9 01              LDA   #$01              ; set str 1 length > string 2 length
00CD3C  2  90 04              BCC   LAB_1CD6          ; branch if so
00CD3E  2               
00CD3E  2  A6 AC              LDX   str_ln            ; get string 1 length
00CD40  2  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
00CD42  2               LAB_1CD6:
00CD42  2  85 B0              STA   FAC1_s            ; save length compare
00CD44  2  A0 FF              LDY   #$FF              ; set index
00CD46  2  E8                 INX                     ; adjust for loop
00CD47  2               LAB_1CDB:
00CD47  2  C8                 INY                     ; increment index
00CD48  2  CA                 DEX                     ; decrement count
00CD49  2  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
00CD4B  2               
00CD4B  2  A6 B0              LDX   FAC1_s            ; get length compare back
00CD4D  2               LAB_1CE1:
00CD4D  2  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
00CD4F  2               
00CD4F  2  18                 CLC                     ; flag str 1 <= str 2
00CD50  2  90 0C              BCC   LAB_1CF2          ; go evaluate result
00CD52  2               
00CD52  2               LAB_1CE6:
00CD52  2  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
00CD54  2  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
00CD56  2  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
00CD58  2               
00CD58  2  A2 FF              LDX   #$FF              ; set str 1 < string 2
00CD5A  2  B0 02              BCS   LAB_1CF2          ; branch if so
00CD5C  2               
00CD5C  2  A2 01              LDX   #$01              ;  set str 1 > string 2
00CD5E  2               LAB_1CF2:
00CD5E  2  E8                 INX                     ; x = 0, 1 or 2
00CD5F  2  8A                 TXA                     ; copy to A
00CD60  2  2A                 ROL                     ; *2 (1, 2 or 4)
00CD61  2  25 63              AND   Cflag             ; AND with comparison evaluation flag
00CD63  2  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
00CD65  2               
00CD65  2  A9 FF              LDA   #$FF              ; else set result true
00CD67  2               LAB_1CFB:
00CD67  2  4C 07 D9           JMP   LAB_27DB          ; save A as integer byte and return
00CD6A  2               
00CD6A  2               LAB_1CFE:
00CD6A  2  20 FE CB           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
00CD6D  2               
00CD6D  2               ; perform DIM
00CD6D  2               
00CD6D  2               LAB_DIM:
00CD6D  2  AA                 TAX                     ; copy "DIM" flag to X
00CD6E  2  20 BD CD           JSR   LAB_1D10          ; search for variable
00CD71  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CD74  2  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
00CD76  2               
00CD76  2  60                 RTS
00CD77  2               
00CD77  2               ; perform << (left shift)
00CD77  2               
00CD77  2               LAB_LSHIFT:
00CD77  2  20 AD CD           JSR   GetPair           ; get integer expression and byte (no sign check)
00CD7A  2  A5 AE              LDA   FAC1_2            ; get expression high byte
00CD7C  2  A6 78              LDX   TempB             ; get shift count
00CD7E  2  F0 22              BEQ   NoShift           ; branch if zero
00CD80  2               
00CD80  2  E0 10              CPX   #$10              ; compare bit count with 16d
00CD82  2  B0 23              BCS   TooBig            ; branch if >=
00CD84  2               
00CD84  2               Ls_loop:
00CD84  2  06 AF              ASL   FAC1_3            ; shift low byte
00CD86  2  2A                 ROL                     ; shift high byte
00CD87  2  CA                 DEX                     ; decrement bit count
00CD88  2  D0 FA              BNE   Ls_loop           ; loop if shift not complete
00CD8A  2               
00CD8A  2  A4 AF              LDY   FAC1_3            ; get expression low byte
00CD8C  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CD8F  2               
00CD8F  2               ; perform >> (right shift)
00CD8F  2               
00CD8F  2               LAB_RSHIFT:
00CD8F  2  20 AD CD           JSR   GetPair           ; get integer expression and byte (no sign check)
00CD92  2  A5 AE              LDA   FAC1_2            ; get expression high byte
00CD94  2  A6 78              LDX   TempB             ; get shift count
00CD96  2  F0 0A              BEQ   NoShift           ; branch if zero
00CD98  2               
00CD98  2  E0 10              CPX   #$10              ; compare bit count with 16d
00CD9A  2  B0 0B              BCS   TooBig            ; branch if >=
00CD9C  2               
00CD9C  2               Rs_loop:
00CD9C  2  4A                 LSR                     ; shift high byte
00CD9D  2  66 AF              ROR   FAC1_3            ; shift low byte
00CD9F  2  CA                 DEX                     ; decrement bit count
00CDA0  2  D0 FA              BNE   Rs_loop           ; loop if shift not complete
00CDA2  2               
00CDA2  2               NoShift:
00CDA2  2  A4 AF              LDY   FAC1_3            ; get expression low byte
00CDA4  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CDA7  2               
00CDA7  2               TooBig:
00CDA7  2  A9 00              LDA   #$00              ; clear high byte
00CDA9  2  A8                 TAY                     ; copy to low byte
00CDAA  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00CDAD  2               
00CDAD  2               GetPair:
00CDAD  2  20 A3 D4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
00CDB0  2  86 78              STX   TempB             ; save it
00CDB2  2  20 D0 D5           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
00CDB5  2  4C B4 CE           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
00CDB8  2               
00CDB8  2               ; search for variable
00CDB8  2               
00CDB8  2               ; return pointer to variable in Cvaral/Cvarah
00CDB8  2               
00CDB8  2               LAB_GVAR:
00CDB8  2  A2 00              LDX   #$00              ; set DIM flag = $00
00CDBA  2  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
00CDBD  2               LAB_1D10:
00CDBD  2  86 5E              STX   Defdim            ; save DIM flag
00CDBF  2               LAB_1D12:
00CDBF  2  85 93              STA   Varnm1            ; save 1st character
00CDC1  2  29 7F              AND   #$7F              ; clear FN flag bit
00CDC3  2  20 2C CE           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
00CDC6  2  B0 03              BCS   LAB_1D1F          ; branch if ok
00CDC8  2               
00CDC8  2  4C 02 CC           JMP   LAB_SNER          ; else syntax error then warm start
00CDCB  2               
00CDCB  2                                             ; was variable name so ..
00CDCB  2               LAB_1D1F:
00CDCB  2  A2 00              LDX   #$00              ; clear 2nd character temp
00CDCD  2  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00CDCF  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
00CDD2  2  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
00CDD4  2               
00CDD4  2                                             ; 2nd character wasn't "0" to "9" so ..
00CDD4  2  20 2C CE           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
00CDD7  2  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
00CDD9  2               
00CDD9  2               LAB_1D2D:
00CDD9  2  AA                 TAX                     ; copy 2nd character
00CDDA  2               
00CDDA  2                                             ; ignore further (valid) characters in the variable name
00CDDA  2               LAB_1D2E:
00CDDA  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
00CDDD  2  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
00CDDF  2               
00CDDF  2  20 2C CE           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
00CDE2  2  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
00CDE4  2               
00CDE4  2                                             ; check if string variable
00CDE4  2               LAB_1D38:
00CDE4  2  C9 24              CMP   #'$'              ; compare with "$"
00CDE6  2  D0 0B              BNE   LAB_1D47          ; branch if not string
00CDE8  2               
00CDE8  2               ; to introduce a new variable type (% suffix for integers say) then this branch
00CDE8  2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
00CDE8  2               
00CDE8  2                                             ; type is string
00CDE8  2  A9 FF              LDA   #$FF              ; set data type = string
00CDEA  2  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
00CDEC  2  8A                 TXA                     ; get 2nd character back
00CDED  2  09 80              ORA   #$80              ; set top bit (indicate string var)
00CDEF  2  AA                 TAX                     ; copy back to 2nd character temp
00CDF0  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CDF3  2               
00CDF3  2               ; after we have determined the variable type we need to come back here to determine
00CDF3  2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
00CDF3  2               
00CDF3  2               
00CDF3  2               LAB_1D47:                      ; gets here with character after var name in A
00CDF3  2  86 94              STX   Varnm2            ; save 2nd character
00CDF5  2  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
00CDF7  2  C9 28              CMP   #'('              ; compare with "("
00CDF9  2  D0 03              BNE   LAB_1D53          ; branch if not "("
00CDFB  2               
00CDFB  2  4C C6 CE           JMP   LAB_1E17          ; go find, or make, array
00CDFE  2               
00CDFE  2               ; either find or create var
00CDFE  2               ; var name (1st two characters only!) is in Varnm1,Varnm2
00CDFE  2               
00CDFE  2                                             ; variable name wasn't var(... so look for plain var
00CDFE  2               LAB_1D53:
00CDFE  2  A9 00              LDA   #$00              ; clear A
00CE00  2  85 61              STA   Sufnxf            ; clear subscript/FNX flag
00CE02  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00CE04  2  A6 7C              LDX   Svarh             ; get start of vars high byte
00CE06  2  A0 00              LDY   #$00              ; clear index
00CE08  2               LAB_1D5D:
00CE08  2  86 AB              STX   Vrschh            ; save search address high byte
00CE0A  2               LAB_1D5F:
00CE0A  2  85 AA              STA   Vrschl            ; save search address low byte
00CE0C  2  E4 7E              CPX   Sarryh            ; compare high address with var space end
00CE0E  2  D0 04              BNE   LAB_1D69          ; skip next compare if <>
00CE10  2               
00CE10  2                                             ; high addresses were = so compare low addresses
00CE10  2  C5 7D              CMP   Sarryl            ; compare low address with var space end
00CE12  2  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
00CE14  2               
00CE14  2               LAB_1D69:
00CE14  2  A5 93              LDA   Varnm1            ; get 1st character of var to find
00CE16  2  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
00CE18  2  D0 08              BNE   LAB_1D77          ; branch if no match
00CE1A  2               
00CE1A  2                                             ; 1st characters match so compare 2nd characters
00CE1A  2  A5 94              LDA   Varnm2            ; get 2nd character of var to find
00CE1C  2  C8                 INY                     ; index to point to variable name 2nd character
00CE1D  2  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
00CE1F  2  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
00CE21  2               
00CE21  2  88                 DEY                     ; else decrement index (now = $00)
00CE22  2               LAB_1D77:
00CE22  2  18                 CLC                     ; clear carry for add
00CE23  2  A5 AA              LDA   Vrschl            ; get search address low byte
00CE25  2  69 06              ADC   #$06              ; +6 (offset to next var name)
00CE27  2  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
00CE29  2               
00CE29  2  E8                 INX                     ; else increment high byte
00CE2A  2  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
00CE2C  2               
00CE2C  2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
00CE2C  2               
00CE2C  2               LAB_CASC:
00CE2C  2  C9 61              CMP   #'a'              ; compare with "a"
00CE2E  2  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
00CE30  2               
00CE30  2               ; check byte, return C=0 if<"A" or >"Z"
00CE30  2               
00CE30  2               LAB_1D82:
00CE30  2  C9 41              CMP   #'A'              ; compare with "A"
00CE32  2  90 05              BCC   LAB_1D8A          ; exit if less
00CE34  2               
00CE34  2                                             ; carry is set
00CE34  2  E9 5B              SBC   #$5B              ; subtract "Z"+1
00CE36  2  38                 SEC                     ; set carry
00CE37  2  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
00CE39  2                                             ; carry clear if byte>$5A
00CE39  2               LAB_1D8A:
00CE39  2  60                 RTS
00CE3A  2               
00CE3A  2               LAB_1D83:
00CE3A  2  E9 7B              SBC   #$7B              ; subtract "z"+1
00CE3C  2  38                 SEC                     ; set carry
00CE3D  2  E9 85              SBC   #$85              ; subtract $85 (restore byte)
00CE3F  2                                             ; carry clear if byte>$7A
00CE3F  2  60                 RTS
00CE40  2               
00CE40  2                                             ; reached end of variable mem without match
00CE40  2                                             ; .. so create new variable
00CE40  2               LAB_1D8B:
00CE40  2  68                 PLA                     ; pop return address low byte
00CE41  2  48                 PHA                     ; push return address low byte
00CE42  2               LAB_1C18p2  = LAB_1C18+2
00CE42  2  C9 49              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
00CE44  2  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
00CE46  2               
00CE46  2               ; This will only drop through if the call was from LAB_1C18 and is only called
00CE46  2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
00CE46  2               ; it prevents the creation of variables not assigned a value.
00CE46  2               
00CE46  2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
00CE46  2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
00CE46  2               
00CE46  2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
00CE46  2               
00CE46  2               ; this is where you would put the undefined variable error call e.g.
00CE46  2               
00CE46  2               ;                             ; variable doesn't exist so flag error
00CE46  2               ;     LDX   #$24              ; error code $24 ("undefined variable" error)
00CE46  2               ;     JMP   LAB_XERR          ; do error #X then warm start
00CE46  2               
00CE46  2               ; the above code has been tested and works a treat! (it replaces the three code lines
00CE46  2               ; below)
00CE46  2               
00CE46  2                                             ; else return dummy null value
00CE46  2  A9 F0              LDA   #<LAB_1D96        ; low byte point to $00,$00
00CE48  2                                             ; (uses part of misc constants table)
00CE48  2  A0 E1              LDY   #>LAB_1D96        ; high byte point to $00,$00
00CE4A  2  60                 RTS
00CE4B  2               
00CE4B  2                                             ; create new numeric variable
00CE4B  2               LAB_1D98:
00CE4B  2  A5 7D              LDA   Sarryl            ; get var mem end low byte
00CE4D  2  A4 7E              LDY   Sarryh            ; get var mem end high byte
00CE4F  2  85 AA              STA   Ostrtl            ; save old block start low byte
00CE51  2  84 AB              STY   Ostrth            ; save old block start high byte
00CE53  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00CE55  2  A4 80              LDY   Earryh            ; get array mem end high byte
00CE57  2  85 A6              STA   Obendl            ; save old block end low byte
00CE59  2  84 A7              STY   Obendh            ; save old block end high byte
00CE5B  2  18                 CLC                     ; clear carry for add
00CE5C  2  69 06              ADC   #$06              ; +6 (space for one var)
00CE5E  2  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
00CE60  2               
00CE60  2  C8                 INY                     ; else increment high byte
00CE61  2               LAB_1DAE:
00CE61  2  85 A4              STA   Nbendl            ; set new block end low byte
00CE63  2  84 A5              STY   Nbendh            ; set new block end high byte
00CE65  2  20 C1 C0           JSR   LAB_11CF          ; open up space in memory
00CE68  2  A5 A4              LDA   Nbendl            ; get new start low byte
00CE6A  2  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
00CE6C  2  C8                 INY                     ; correct high byte
00CE6D  2  85 7D              STA   Sarryl            ; save new var mem end low byte
00CE6F  2  84 7E              STY   Sarryh            ; save new var mem end high byte
00CE71  2  A0 00              LDY   #$00              ; clear index
00CE73  2  A5 93              LDA   Varnm1            ; get var name 1st character
00CE75  2  91 AA              STA   (Vrschl),Y        ; save var name 1st character
00CE77  2  C8                 INY                     ; increment index
00CE78  2  A5 94              LDA   Varnm2            ; get var name 2nd character
00CE7A  2  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
00CE7C  2  A9 00              LDA   #$00              ; clear A
00CE7E  2  C8                 INY                     ; increment index
00CE7F  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00CE81  2  C8                 INY                     ; increment index
00CE82  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00CE84  2  C8                 INY                     ; increment index
00CE85  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00CE87  2  C8                 INY                     ; increment index
00CE88  2  91 AA              STA   (Vrschl),Y        ; initialise var byte
00CE8A  2               
00CE8A  2                                             ; found a match for var ((Vrschl) = ptr)
00CE8A  2               LAB_1DD7:
00CE8A  2  A5 AA              LDA   Vrschl            ; get var address low byte
00CE8C  2  18                 CLC                     ; clear carry for add
00CE8D  2  69 02              ADC   #$02              ; +2 (offset past var name bytes)
00CE8F  2  A4 AB              LDY   Vrschh            ; get var address high byte
00CE91  2  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
00CE93  2               
00CE93  2  C8                 INY                     ; else increment high byte
00CE94  2               LAB_1DE1:
00CE94  2  85 95              STA   Cvaral            ; save current var address low byte
00CE96  2  84 96              STY   Cvarah            ; save current var address high byte
00CE98  2  60                 RTS
00CE99  2               
00CE99  2               ; set-up array pointer (Adatal/h) to first element in array
00CE99  2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
00CE99  2               
00CE99  2               LAB_1DE6:
00CE99  2  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
00CE9B  2  0A                 ASL                     ; *2 (also clears the carry !)
00CE9C  2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
00CE9E  2  65 AA              ADC   Astrtl            ; add array start pointer low byte
00CEA0  2  A4 AB              LDY   Astrth            ; get array pointer high byte
00CEA2  2  90 01              BCC   LAB_1DF2          ; branch if no overflow
00CEA4  2               
00CEA4  2  C8                 INY                     ; else increment high byte
00CEA5  2               LAB_1DF2:
00CEA5  2  85 A4              STA   Adatal            ; save array data pointer low byte
00CEA7  2  84 A5              STY   Adatah            ; save array data pointer high byte
00CEA9  2  60                 RTS
00CEAA  2               
00CEAA  2               ; evaluate integer expression
00CEAA  2               
00CEAA  2               LAB_EVIN:
00CEAA  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00CEAD  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00CEB0  2                                             ; else do type mismatch
00CEB0  2               
00CEB0  2               ; evaluate integer expression (no check)
00CEB0  2               
00CEB0  2               LAB_EVPI:
00CEB0  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00CEB2  2  30 0D              BMI   LAB_1E12          ; do function call error if -ve
00CEB4  2               
00CEB4  2               ; evaluate integer expression (no sign check)
00CEB4  2               
00CEB4  2               LAB_EVIR:
00CEB4  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00CEB6  2  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
00CEB8  2  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
00CEBA  2               
00CEBA  2  A9 F7              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
00CEBC  2  A0 E1              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
00CEBE  2  20 24 D9           JSR   LAB_27F8          ; compare FAC1 with (AY)
00CEC1  2               LAB_1E12:
00CEC1  2  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
00CEC3  2               
00CEC3  2               LAB_1E14:
00CEC3  2  4C 5D D9           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
00CEC6  2               
00CEC6  2               ; find or make array
00CEC6  2               
00CEC6  2               LAB_1E17:
00CEC6  2  A5 5E              LDA   Defdim            ; get DIM flag
00CEC8  2  48                 PHA                     ; push it
00CEC9  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00CECB  2  48                 PHA                     ; push it
00CECC  2  A0 00              LDY   #$00              ; clear dimensions count
00CECE  2               
00CECE  2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
00CECE  2               
00CECE  2               LAB_1E1F:
00CECE  2  98                 TYA                     ; copy dimensions count
00CECF  2  48                 PHA                     ; save it
00CED0  2  A5 94              LDA   Varnm2            ; get array name 2nd byte
00CED2  2  48                 PHA                     ; save it
00CED3  2  A5 93              LDA   Varnm1            ; get array name 1st byte
00CED5  2  48                 PHA                     ; save it
00CED6  2  20 AA CE           JSR   LAB_EVIN          ; evaluate integer expression
00CED9  2  68                 PLA                     ; pull array name 1st byte
00CEDA  2  85 93              STA   Varnm1            ; restore array name 1st byte
00CEDC  2  68                 PLA                     ; pull array name 2nd byte
00CEDD  2  85 94              STA   Varnm2            ; restore array name 2nd byte
00CEDF  2  68                 PLA                     ; pull dimensions count
00CEE0  2  A8                 TAY                     ; restore it
00CEE1  2  BA                 TSX                     ; copy stack pointer
00CEE2  2  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
00CEE5  2  48                 PHA                     ; push it
00CEE6  2  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
00CEE9  2  48                 PHA                     ; push it
00CEEA  2  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
00CEEC  2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
00CEEF  2  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
00CEF1  2  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
00CEF4  2  C8                 INY                     ; increment dimensions count
00CEF5  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00CEF8  2  C9 2C              CMP   #','              ; compare with ","
00CEFA  2  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
00CEFC  2               
00CEFC  2  84 5D              STY   Dimcnt            ; store dimensions count
00CEFE  2  20 EF CB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00CF01  2  68                 PLA                     ; pull data type flag
00CF02  2  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
00CF04  2  68                 PLA                     ; pull DIM flag
00CF05  2  85 5E              STA   Defdim            ; restore DIM flag
00CF07  2  A6 7D              LDX   Sarryl            ; get array mem start low byte
00CF09  2  A5 7E              LDA   Sarryh            ; get array mem start high byte
00CF0B  2               
00CF0B  2               ; now check to see if we are at the end of array memory (we would be if there were
00CF0B  2               ; no arrays).
00CF0B  2               
00CF0B  2               LAB_1E5C:
00CF0B  2  86 AA              STX   Astrtl            ; save as array start pointer low byte
00CF0D  2  85 AB              STA   Astrth            ; save as array start pointer high byte
00CF0F  2  C5 80              CMP   Earryh            ; compare with array mem end high byte
00CF11  2  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
00CF13  2               
00CF13  2  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
00CF15  2  F0 39              BEQ   LAB_1EA1          ; go build array if not found
00CF17  2               
00CF17  2                                             ; search for array
00CF17  2               LAB_1E68:
00CF17  2  A0 00              LDY   #$00              ; clear index
00CF19  2  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
00CF1B  2  C8                 INY                     ; increment index to second name byte
00CF1C  2  C5 93              CMP   Varnm1            ; compare with this array name first byte
00CF1E  2  D0 06              BNE   LAB_1E77          ; branch if no match
00CF20  2               
00CF20  2  A5 94              LDA   Varnm2            ; else get this array name second byte
00CF22  2  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
00CF24  2  F0 16              BEQ   LAB_1E8D          ; array found so branch
00CF26  2               
00CF26  2                                             ; no match
00CF26  2               LAB_1E77:
00CF26  2  C8                 INY                     ; increment index
00CF27  2  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
00CF29  2  18                 CLC                     ; clear carry for add
00CF2A  2  65 AA              ADC   Astrtl            ; add array start pointer low byte
00CF2C  2  AA                 TAX                     ; copy low byte to X
00CF2D  2  C8                 INY                     ; increment index
00CF2E  2  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
00CF30  2  65 AB              ADC   Astrth            ; add array mem pointer high byte
00CF32  2  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
00CF34  2               
00CF34  2               ; do array bounds error
00CF34  2               
00CF34  2               LAB_1E85:
00CF34  2  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
00CF36  2  2C                 .byte $2C               ; makes next bit BIT LAB_08A2
00CF37  2               
00CF37  2               ; do function call error
00CF37  2               
00CF37  2               LAB_FCER:
00CF37  2  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
00CF39  2               LAB_1E8A:
00CF39  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00CF3C  2               
00CF3C  2                                             ; found array, are we trying to dimension it?
00CF3C  2               LAB_1E8D:
00CF3C  2  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
00CF3E  2  A5 5E              LDA   Defdim            ; get DIM flag
00CF40  2  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
00CF42  2                                             ; start
00CF42  2               
00CF42  2               ; found the array and we're not dimensioning it so we must find an element in it
00CF42  2               
00CF42  2  20 99 CE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
00CF45  2                                             ; (Astrtl,Astrth points to start of array)
00CF45  2  A5 5D              LDA   Dimcnt            ; get dimensions count
00CF47  2  A0 04              LDY   #$04              ; set index to array's # of dimensions
00CF49  2  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
00CF4B  2  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
00CF4D  2                                             ; dimensions" error here .. if we want a different
00CF4D  2                                             ; error message
00CF4D  2               
00CF4D  2  4C D3 CF           JMP   LAB_1F28          ; found array so go get element
00CF50  2                                             ; (could jump to LAB_1F28 as all LAB_1F24 does is take
00CF50  2                                             ; Dimcnt and save it at (Astrtl),Y which is already the
00CF50  2                                             ; same or we would have taken the BNE)
00CF50  2               
00CF50  2                                             ; array not found, so build it
00CF50  2               LAB_1EA1:
00CF50  2  20 99 CE           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
00CF53  2                                             ; (Astrtl,Astrth points to start of array)
00CF53  2  20 0E C1           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00CF56  2                                             ; addr to check is in AY (low/high)
00CF56  2  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
00CF58  2  84 BB              STY   Aspth             ; clear array data size high byte
00CF5A  2  A5 93              LDA   Varnm1            ; get variable name 1st byte
00CF5C  2  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
00CF5E  2  C8                 INY                     ; increment index
00CF5F  2  A5 94              LDA   Varnm2            ; get variable name 2nd byte
00CF61  2  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
00CF63  2  A5 5D              LDA   Dimcnt            ; get dimensions count
00CF65  2  A0 04              LDY   #$04              ; index to dimension count
00CF67  2  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
00CF69  2  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
00CF6B  2               
00CF6B  2                                             ; now calculate the size of the data space for the array
00CF6B  2  18                 CLC                     ; clear carry for add (clear on subsequent loops)
00CF6C  2               LAB_1EC0:
00CF6C  2  A2 0B              LDX   #$0B              ; set default dimension value low byte
00CF6E  2  A9 00              LDA   #$00              ; set default dimension value high byte
00CF70  2  24 5E              BIT   Defdim            ; test default DIM flag
00CF72  2  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
00CF74  2               
00CF74  2  68                 PLA                     ; else pull dimension value low byte
00CF75  2  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
00CF77  2  AA                 TAX                     ; copy low byte to X
00CF78  2  68                 PLA                     ; pull dimension value high byte
00CF79  2  69 00              ADC   #$00              ; add carry from low byte
00CF7B  2               
00CF7B  2               LAB_1ED0:
00CF7B  2  C8                 INY                     ; index to dimension value high byte
00CF7C  2  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
00CF7E  2  C8                 INY                     ; index to dimension value high byte
00CF7F  2  8A                 TXA                     ; get dimension value low byte
00CF80  2  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
00CF82  2  20 22 D0           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
00CF85  2  86 BA              STX   Asptl             ; save array data size low byte
00CF87  2  85 BB              STA   Aspth             ; save array data size high byte
00CF89  2  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
00CF8B  2  C6 5D              DEC   Dimcnt            ; decrement dimensions count
00CF8D  2  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
00CF8F  2               
00CF8F  2  65 A5              ADC   Adatah            ; add size high byte to first element high byte
00CF91  2                                             ; (carry is always clear here)
00CF91  2  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00CF93  2               
00CF93  2  85 A5              STA   Adatah            ; save end of array high byte
00CF95  2  A8                 TAY                     ; copy end high byte to Y
00CF96  2  8A                 TXA                     ; get array size low byte
00CF97  2  65 A4              ADC   Adatal            ; add array start low byte
00CF99  2  90 03              BCC   LAB_1EF3          ; branch if no carry
00CF9B  2               
00CF9B  2  C8                 INY                     ; else increment end of array high byte
00CF9C  2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
00CF9E  2               
00CF9E  2                                             ; set-up mostly complete, now zero the array
00CF9E  2               LAB_1EF3:
00CF9E  2  20 0E C1           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
00CFA1  2                                             ; addr to check is in AY (low/high)
00CFA1  2  85 7F              STA   Earryl            ; save array mem end low byte
00CFA3  2  84 80              STY   Earryh            ; save array mem end high byte
00CFA5  2  A9 00              LDA   #$00              ; clear byte for array clear
00CFA7  2  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
00CFA9  2  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
00CFAB  2  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
00CFAD  2               
00CFAD  2               LAB_1F02:
00CFAD  2  88                 DEY                     ; decrement index (do 0 to n-1)
00CFAE  2  91 A4              STA   (Adatal),Y        ; zero byte
00CFB0  2  D0 FB              BNE   LAB_1F02          ; loop until this block done
00CFB2  2               
00CFB2  2               LAB_1F07:
00CFB2  2  C6 A5              DEC   Adatah            ; decrement array pointer high byte
00CFB4  2  C6 BB              DEC   Aspth             ; decrement block count high byte
00CFB6  2  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
00CFB8  2               
00CFB8  2  E6 A5              INC   Adatah            ; correct for last loop
00CFBA  2  38                 SEC                     ; set carry for subtract
00CFBB  2  A0 02              LDY   #$02              ; index to array size low byte
00CFBD  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00CFBF  2  E5 AA              SBC   Astrtl            ; subtract array start low byte
00CFC1  2  91 AA              STA   (Astrtl),Y        ; save array size low byte
00CFC3  2  C8                 INY                     ; index to array size high byte
00CFC4  2  A5 80              LDA   Earryh            ; get array mem end high byte
00CFC6  2  E5 AB              SBC   Astrth            ; subtract array start high byte
00CFC8  2  91 AA              STA   (Astrtl),Y        ; save array size high byte
00CFCA  2  A5 5E              LDA   Defdim            ; get default DIM flag
00CFCC  2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
00CFCE  2               
00CFCE  2                                             ; else, find element
00CFCE  2  C8                 INY                     ; index to # of dimensions
00CFCF  2               
00CFCF  2               LAB_1F24:
00CFCF  2  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
00CFD1  2  85 5D              STA   Dimcnt            ; save it
00CFD3  2               
00CFD3  2               ; we have found, or built, the array. now we need to find the element
00CFD3  2               
00CFD3  2               LAB_1F28:
00CFD3  2  A9 00              LDA   #$00              ; clear byte
00CFD5  2  85 BA              STA   Asptl             ; clear array data pointer low byte
00CFD7  2               LAB_1F2C:
00CFD7  2  85 BB              STA   Aspth             ; save array data pointer high byte
00CFD9  2  C8                 INY                     ; increment index (point to array bound high byte)
00CFDA  2  68                 PLA                     ; pull array index low byte
00CFDB  2  AA                 TAX                     ; copy to X
00CFDC  2  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
00CFDE  2  68                 PLA                     ; pull array index high byte
00CFDF  2  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
00CFE1  2  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
00CFE3  2  90 0E              BCC   LAB_1F48          ; branch if within bounds
00CFE5  2               
00CFE5  2  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
00CFE7  2               
00CFE7  2                                             ; else high byte was = so test low bytes
00CFE7  2  C8                 INY                     ; index to array bound low byte
00CFE8  2  8A                 TXA                     ; get array index low byte
00CFE9  2  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
00CFEB  2  90 07              BCC   LAB_1F49          ; branch if within bounds
00CFED  2               
00CFED  2               LAB_1F42:
00CFED  2  4C 34 CF           JMP   LAB_1E85          ; else do array bounds error
00CFF0  2               
00CFF0  2               LAB_1F45:
00CFF0  2  4C 3D C1           JMP   LAB_OMER          ; do "Out of memory" error then warm start
00CFF3  2               
00CFF3  2               LAB_1F48:
00CFF3  2  C8                 INY                     ; index to array bound low byte
00CFF4  2               LAB_1F49:
00CFF4  2  A5 BB              LDA   Aspth             ; get array data pointer high byte
00CFF6  2  05 BA              ORA   Asptl             ; OR with array data pointer low byte
00CFF8  2  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
00CFFA  2               
00CFFA  2  20 22 D0           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
00CFFD  2  8A                 TXA                     ; get result low byte
00CFFE  2  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
00D000  2  AA                 TAX                     ; save result low byte
00D001  2  98                 TYA                     ; get result high byte
00D002  2  A4 71              LDY   ut1_pl            ; restore index
00D004  2               LAB_1F5A:
00D004  2  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
00D006  2  86 BA              STX   Asptl             ; save array data pointer low byte
00D008  2  C6 5D              DEC   Dimcnt            ; decrement dimensions count
00D00A  2  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
00D00C  2               
00D00C  2  06 BA              ASL   Asptl             ; array data pointer low byte * 2
00D00E  2  2A                 ROL                     ; array data pointer high byte * 2
00D00F  2  06 BA              ASL   Asptl             ; array data pointer low byte * 4
00D011  2  2A                 ROL                     ; array data pointer high byte * 4
00D012  2  A8                 TAY                     ; copy high byte
00D013  2  A5 BA              LDA   Asptl             ; get low byte
00D015  2  65 A4              ADC   Adatal            ; add array data start pointer low byte
00D017  2  85 95              STA   Cvaral            ; save as current var address low byte
00D019  2  98                 TYA                     ; get high byte back
00D01A  2  65 A5              ADC   Adatah            ; add array data start pointer high byte
00D01C  2  85 96              STA   Cvarah            ; save as current var address high byte
00D01E  2  A8                 TAY                     ; copy high byte to Y
00D01F  2  A5 95              LDA   Cvaral            ; get current var address low byte
00D021  2               LAB_1F7B:
00D021  2  60                 RTS
00D022  2               
00D022  2               ; does XY = (Astrtl),Y * (Asptl)
00D022  2               
00D022  2               LAB_1F7C:
00D022  2  84 71              STY   ut1_pl            ; save index
00D024  2  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
00D026  2  85 76              STA   dims_l            ; save dimension size low byte
00D028  2  88                 DEY                     ; decrement index
00D029  2  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
00D02B  2  85 77              STA   dims_h            ; save dimension size high byte
00D02D  2               
00D02D  2  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
00D02F  2  85 A8              STA   numbit            ; save bit count
00D031  2  A2 00              LDX   #$00              ; clear result low byte
00D033  2  A0 00              LDY   #$00              ; clear result high byte
00D035  2               LAB_1F8F:
00D035  2  8A                 TXA                     ; get result low byte
00D036  2  0A                 ASL                     ; *2
00D037  2  AA                 TAX                     ; save result low byte
00D038  2  98                 TYA                     ; get result high byte
00D039  2  2A                 ROL                     ; *2
00D03A  2  A8                 TAY                     ; save result high byte
00D03B  2  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00D03D  2               
00D03D  2  06 BA              ASL   Asptl             ; shift multiplier low byte
00D03F  2  26 BB              ROL   Aspth             ; shift multiplier high byte
00D041  2  90 0B              BCC   LAB_1FA8          ; skip add if no carry
00D043  2               
00D043  2  18                 CLC                     ; else clear carry for add
00D044  2  8A                 TXA                     ; get result low byte
00D045  2  65 76              ADC   dims_l            ; add dimension size low byte
00D047  2  AA                 TAX                     ; save result low byte
00D048  2  98                 TYA                     ; get result high byte
00D049  2  65 77              ADC   dims_h            ; add dimension size high byte
00D04B  2  A8                 TAY                     ; save result high byte
00D04C  2  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00D04E  2               
00D04E  2               LAB_1FA8:
00D04E  2  C6 A8              DEC   numbit            ; decrement bit count
00D050  2  D0 E3              BNE   LAB_1F8F          ; loop until all done
00D052  2               
00D052  2  60                 RTS
00D053  2               
00D053  2               ; perform FRE()
00D053  2               
00D053  2               LAB_FRE:
00D053  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00D055  2  10 03              BPL   LAB_1FB4          ; branch if numeric
00D057  2               
00D057  2  20 52 D3           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00D05A  2                                             ; space returns with A = length, X=$71=pointer low byte,
00D05A  2                                             ; Y=$72=pointer high byte
00D05A  2               
00D05A  2                                             ; FRE(n) was numeric so do this
00D05A  2               LAB_1FB4:
00D05A  2  20 EF D1           JSR   LAB_GARB          ; go do garbage collection
00D05D  2  38                 SEC                     ; set carry for subtract
00D05E  2  A5 81              LDA   Sstorl            ; get bottom of string space low byte
00D060  2  E5 7F              SBC   Earryl            ; subtract array mem end low byte
00D062  2  A8                 TAY                     ; copy result to Y
00D063  2  A5 82              LDA   Sstorh            ; get bottom of string space high byte
00D065  2  E5 80              SBC   Earryh            ; subtract array mem end high byte
00D067  2               
00D067  2               ; save and convert integer AY to FAC1
00D067  2               
00D067  2               LAB_AYFC:
00D067  2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00D069  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D06B  2  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
00D06D  2  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
00D06F  2  4C 0F D9           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
00D072  2               
00D072  2               ; perform POS()
00D072  2               
00D072  2               LAB_POS:
00D072  2  A4 0E              LDY   TPos              ; get terminal position
00D074  2               
00D074  2               ; convert Y to byte in FAC1
00D074  2               
00D074  2               LAB_1FD0:
00D074  2  A9 00              LDA   #$00              ; clear high byte
00D076  2  F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
00D078  2               
00D078  2               ; check not Direct (used by DEF and INPUT)
00D078  2               
00D078  2               LAB_CKRN:
00D078  2  A6 88              LDX   Clineh            ; get current line high byte
00D07A  2  E8                 INX                     ; increment it
00D07B  2  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
00D07D  2               
00D07D  2                                             ; else do illegal direct error
00D07D  2               LAB_1FD9:
00D07D  2  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
00D07F  2               LAB_1FDB:
00D07F  2  4C 3F C1           JMP   LAB_XERR          ; go do error #X, then warm start
00D082  2               
00D082  2               ; perform DEF
00D082  2               
00D082  2               LAB_DEF:
00D082  2  20 B3 D0           JSR   LAB_200B          ; check FNx syntax
00D085  2  85 9C              STA   func_l            ; save function pointer low byte
00D087  2  84 9D              STY   func_h            ; save function pointer high byte
00D089  2  20 78 D0           JSR   LAB_CKRN          ; check not Direct (back here if ok)
00D08C  2  20 FA CB           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
00D08F  2  A9 80              LDA   #$80              ; set flag for FNx
00D091  2  85 61              STA   Sufnxf            ; save subscript/FNx flag
00D093  2  20 B8 CD           JSR   LAB_GVAR          ; get (var) address
00D096  2  20 D0 CA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00D099  2  20 EF CB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00D09C  2  A9 C1              LDA   #TK_EQUAL         ; get = token
00D09E  2  20 F1 CB           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
00D0A1  2  A5 96              LDA   Cvarah            ; get current var address high byte
00D0A3  2  48                 PHA                     ; push it
00D0A4  2  A5 95              LDA   Cvaral            ; get current var address low byte
00D0A6  2  48                 PHA                     ; push it
00D0A7  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00D0A9  2  48                 PHA                     ; push it
00D0AA  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00D0AC  2  48                 PHA                     ; push it
00D0AD  2  20 8A C6           JSR   LAB_DATA          ; go perform DATA
00D0B0  2  4C 22 D1           JMP   LAB_207A          ; put execute pointer and variable pointer into function
00D0B3  2                                             ; and return
00D0B3  2               
00D0B3  2               ; check FNx syntax
00D0B3  2               
00D0B3  2               LAB_200B:
00D0B3  2  A9 AE              LDA   #TK_FN            ; get FN" token
00D0B5  2  20 F1 CB           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
00D0B8  2                                             ; return character after A
00D0B8  2  09 80              ORA   #$80              ; set FN flag bit
00D0BA  2  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
00D0BC  2  20 BF CD           JSR   LAB_1D12          ; search for FN variable
00D0BF  2  4C D0 CA           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
00D0C2  2                                             ; mismatch
00D0C2  2               
00D0C2  2                                             ; Evaluate FNx
00D0C2  2               LAB_201E:
00D0C2  2  20 B3 D0           JSR   LAB_200B          ; check FNx syntax
00D0C5  2  48                 PHA                     ; push function pointer low byte
00D0C6  2  98                 TYA                     ; copy function pointer high byte
00D0C7  2  48                 PHA                     ; push function pointer high byte
00D0C8  2  20 FA CB           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
00D0CB  2  20 E1 CA           JSR   LAB_EVEX          ; evaluate expression
00D0CE  2  20 EF CB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00D0D1  2  20 D0 CA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00D0D4  2  68                 PLA                     ; pop function pointer high byte
00D0D5  2  85 9D              STA   func_h            ; restore it
00D0D7  2  68                 PLA                     ; pop function pointer low byte
00D0D8  2  85 9C              STA   func_l            ; restore it
00D0DA  2  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
00D0DC  2  A0 03              LDY   #$03              ; index to variable pointer high byte
00D0DE  2  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
00D0E0  2  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
00D0E2  2               
00D0E2  2  85 96              STA   Cvarah            ; save variable address high byte
00D0E4  2  88                 DEY                     ; index to variable address low byte
00D0E5  2  B1 9C              LDA   (func_l),Y        ; get variable address low byte
00D0E7  2  85 95              STA   Cvaral            ; save variable address low byte
00D0E9  2  AA                 TAX                     ; copy address low byte
00D0EA  2               
00D0EA  2                                             ; now stack the function variable value before use
00D0EA  2  C8                 INY                     ; index to mantissa_3
00D0EB  2               LAB_2043:
00D0EB  2  B1 95              LDA   (Cvaral),Y        ; get byte from variable
00D0ED  2  48                 PHA                     ; stack it
00D0EE  2  88                 DEY                     ; decrement index
00D0EF  2  10 FA              BPL   LAB_2043          ; loop until variable stacked
00D0F1  2               
00D0F1  2  A4 96              LDY   Cvarah            ; get variable address high byte
00D0F3  2  20 B4 D8           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
00D0F6  2                                             ; (function variable), return Y=0, always
00D0F6  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00D0F8  2  48                 PHA                     ; push it
00D0F9  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00D0FB  2  48                 PHA                     ; push it
00D0FC  2  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
00D0FE  2  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
00D100  2  C8                 INY                     ; index to high byte
00D101  2  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
00D103  2  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
00D105  2  A5 96              LDA   Cvarah            ; get variable address high byte
00D107  2  48                 PHA                     ; push it
00D108  2  A5 95              LDA   Cvaral            ; get variable address low byte
00D10A  2  48                 PHA                     ; push it
00D10B  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D10E  2                                             ; else do type mismatch
00D10E  2  68                 PLA                     ; pull variable address low byte
00D10F  2  85 9C              STA   func_l            ; save variable address low byte
00D111  2  68                 PLA                     ; pull variable address high byte
00D112  2  85 9D              STA   func_h            ; save variable address high byte
00D114  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D117  2  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
00D119  2               
00D119  2  4C 02 CC           JMP   LAB_SNER          ; else syntax error then warm start
00D11C  2               
00D11C  2               ; restore Bpntrl,Bpntrh and function variable from stack
00D11C  2               
00D11C  2               LAB_2074:
00D11C  2  68                 PLA                     ; pull BASIC execute pointer low byte
00D11D  2  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
00D11F  2  68                 PLA                     ; pull BASIC execute pointer high byte
00D120  2  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
00D122  2               
00D122  2               ; put execute pointer and variable pointer into function
00D122  2               
00D122  2               LAB_207A:
00D122  2  A0 00              LDY   #$00              ; clear index
00D124  2  68                 PLA                     ; pull BASIC execute pointer low byte
00D125  2  91 9C              STA   (func_l),Y        ; save to function
00D127  2  C8                 INY                     ; increment index
00D128  2  68                 PLA                     ; pull BASIC execute pointer high byte
00D129  2  91 9C              STA   (func_l),Y        ; save to function
00D12B  2  C8                 INY                     ; increment index
00D12C  2  68                 PLA                     ; pull current var address low byte
00D12D  2  91 9C              STA   (func_l),Y        ; save to function
00D12F  2  C8                 INY                     ; increment index
00D130  2  68                 PLA                     ; pull current var address high byte
00D131  2  91 9C              STA   (func_l),Y        ; save to function
00D133  2  60                 RTS
00D134  2               
00D134  2               ; perform STR$()
00D134  2               
00D134  2               LAB_STRS:
00D134  2  20 D0 CA           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
00D137  2  20 A2 DA           JSR   LAB_296E          ; convert FAC1 to string
00D13A  2  A9 F0              LDA   #<Decssp1         ; set result string low pointer
00D13C  2  A0 00              LDY   #>Decssp1         ; set result string high pointer
00D13E  2  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
00D140  2               
00D140  2               ; Do string vector
00D140  2               ; copy des_pl/h to des_2l/h and make string space A bytes long
00D140  2               
00D140  2               LAB_209C:
00D140  2  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
00D142  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00D144  2  86 9E              STX   des_2l            ; save descriptor pointer low byte
00D146  2  84 9F              STY   des_2h            ; save descriptor pointer high byte
00D148  2               
00D148  2               ; make string space A bytes long
00D148  2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D148  2               
00D148  2               LAB_MSSP:
00D148  2  20 BD D1           JSR   LAB_2115          ; make space in string memory for string A long
00D14B  2                                             ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D14B  2  86 AD              STX   str_pl            ; save string pointer low byte
00D14D  2  84 AE              STY   str_ph            ; save string pointer high byte
00D14F  2  85 AC              STA   str_ln            ; save length
00D151  2  60                 RTS
00D152  2               
00D152  2               ; Scan, set up string
00D152  2               ; print " terminated string to Sutill/Sutilh
00D152  2               
00D152  2               LAB_20AE:
00D152  2  A2 22              LDX   #$22              ; set terminator to "
00D154  2  86 5B              STX   Srchc             ; set search character (terminator 1)
00D156  2  86 5C              STX   Asrch             ; set terminator 2
00D158  2               
00D158  2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
00D158  2               ; source is AY
00D158  2               
00D158  2               LAB_20B4:
00D158  2  85 B8              STA   ssptr_l           ; store string start low byte
00D15A  2  84 B9              STY   ssptr_h           ; store string start high byte
00D15C  2  85 AD              STA   str_pl            ; save string pointer low byte
00D15E  2  84 AE              STY   str_ph            ; save string pointer high byte
00D160  2  A0 FF              LDY   #$FF              ; set length to -1
00D162  2               LAB_20BE:
00D162  2  C8                 INY                     ; increment length
00D163  2  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
00D165  2  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
00D167  2               
00D167  2  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
00D169  2  F0 04              BEQ   LAB_20CB          ; branch if terminator
00D16B  2               
00D16B  2  C5 5C              CMP   Asrch             ; compare with terminator 2
00D16D  2  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
00D16F  2               
00D16F  2               LAB_20CB:
00D16F  2  C9 22              CMP   #$22              ; compare with "
00D171  2  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
00D173  2               
00D173  2               LAB_20CF:
00D173  2  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
00D174  2               LAB_20D0:
00D174  2  84 AC              STY   str_ln            ; save length in FAC1 exponent
00D176  2  98                 TYA                     ; copy length to A
00D177  2  65 B8              ADC   ssptr_l           ; add string start low byte
00D179  2  85 BA              STA   Sendl             ; save string end low byte
00D17B  2  A6 B9              LDX   ssptr_h           ; get string start high byte
00D17D  2  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
00D17F  2               
00D17F  2  E8                 INX                     ; else increment high byte
00D180  2               LAB_20DC:
00D180  2  86 BB              STX   Sendh             ; save string end high byte
00D182  2  A5 B9              LDA   ssptr_h           ; get string start high byte
00D184  2               ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
00D184  2               ; *** replace
00D184  2               ;      CMP   #>Ram_base        ; compare with start of program memory
00D184  2               ;      BCS   LAB_RTST          ; branch if not in utility area
00D184  2               ; *** with
00D184  2  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
00D186  2  C9 08              CMP   #>Ibuffs          ; compare with location of input buffer page
00D188  2  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
00D18A  2               LAB_MVST:
00D18A  2               ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
00D18A  2               
00D18A  2                                             ; string in utility area, move to string memory
00D18A  2  98                 TYA                     ; copy length to A
00D18B  2  20 40 D1           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00D18E  2                                             ; long
00D18E  2  A6 B8              LDX   ssptr_l           ; get string start low byte
00D190  2  A4 B9              LDY   ssptr_h           ; get string start high byte
00D192  2  20 33 D3           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
00D195  2               
00D195  2               ; check for space on descriptor stack then ..
00D195  2               ; put string address and length on descriptor stack and update stack pointers
00D195  2               
00D195  2               LAB_RTST:
00D195  2  A6 65              LDX   next_s            ; get string stack pointer
00D197  2  E0 71              CPX   #des_sk+$09       ; compare with max+1
00D199  2  D0 05              BNE   LAB_20F8          ; branch if space on string stack
00D19B  2               
00D19B  2                                             ; else do string too complex error
00D19B  2  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
00D19D  2               LAB_20F5:
00D19D  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00D1A0  2               
00D1A0  2               ; put string address and length on descriptor stack and update stack pointers
00D1A0  2               
00D1A0  2               LAB_20F8:
00D1A0  2  A5 AC              LDA   str_ln            ; get string length
00D1A2  2  95 00              STA   PLUS_0,X          ; put on string stack
00D1A4  2  A5 AD              LDA   str_pl            ; get string pointer low byte
00D1A6  2  95 01              STA   PLUS_1,X          ; put on string stack
00D1A8  2  A5 AE              LDA   str_ph            ; get string pointer high byte
00D1AA  2  95 02              STA   PLUS_2,X          ; put on string stack
00D1AC  2  A0 00              LDY   #$00              ; clear Y
00D1AE  2  86 AE              STX   des_pl            ; save string descriptor pointer low byte
00D1B0  2  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
00D1B2  2  88                 DEY                     ; Y = $FF
00D1B3  2  84 5F              STY   Dtypef            ; save data type flag, $FF=string
00D1B5  2  86 66              STX   last_sl           ; save old stack pointer (current top item)
00D1B7  2  E8                 INX                     ; update stack pointer
00D1B8  2  E8                 INX                     ; update stack pointer
00D1B9  2  E8                 INX                     ; update stack pointer
00D1BA  2  86 65              STX   next_s            ; save new top item value
00D1BC  2  60                 RTS
00D1BD  2               
00D1BD  2               ; Build descriptor
00D1BD  2               ; make space in string memory for string A long
00D1BD  2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
00D1BD  2               
00D1BD  2               LAB_2115:
00D1BD  2  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
00D1BF  2               
00D1BF  2                                             ; make space for string A long
00D1BF  2               LAB_2117:
00D1BF  2  48                 PHA                     ; save string length
00D1C0  2  49 FF              EOR   #$FF              ; complement it
00D1C2  2  38                 SEC                     ; set carry for subtract (twos comp add)
00D1C3  2  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
00D1C5  2  A4 82              LDY   Sstorh            ; get bottom of string space high byte
00D1C7  2  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
00D1C9  2               
00D1C9  2  88                 DEY                     ; decrement bottom of string space high byte
00D1CA  2               LAB_2122:
00D1CA  2  C4 80              CPY   Earryh            ; compare with array mem end high byte
00D1CC  2  90 11              BCC   LAB_2137          ; do out of memory error if less
00D1CE  2               
00D1CE  2  D0 04              BNE   LAB_212C          ; if not = skip next test
00D1D0  2               
00D1D0  2  C5 7F              CMP   Earryl            ; compare with array mem end low byte
00D1D2  2  90 0B              BCC   LAB_2137          ; do out of memory error if less
00D1D4  2               
00D1D4  2               LAB_212C:
00D1D4  2  85 81              STA   Sstorl            ; save bottom of string space low byte
00D1D6  2  84 82              STY   Sstorh            ; save bottom of string space high byte
00D1D8  2  85 83              STA   Sutill            ; save string utility ptr low byte
00D1DA  2  84 84              STY   Sutilh            ; save string utility ptr high byte
00D1DC  2  AA                 TAX                     ; copy low byte to X
00D1DD  2  68                 PLA                     ; get string length back
00D1DE  2  60                 RTS
00D1DF  2               
00D1DF  2               LAB_2137:
00D1DF  2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00D1E1  2  A5 60              LDA   Gclctd            ; get garbage collected flag
00D1E3  2  30 B8              BMI   LAB_20F5          ; if set then do error code X
00D1E5  2               
00D1E5  2  20 EF D1           JSR   LAB_GARB          ; else go do garbage collection
00D1E8  2  A9 80              LDA   #$80              ; flag for garbage collected
00D1EA  2  85 60              STA   Gclctd            ; set garbage collected flag
00D1EC  2  68                 PLA                     ; pull length
00D1ED  2  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
00D1EF  2               
00D1EF  2               ; garbage collection routine
00D1EF  2               
00D1EF  2               LAB_GARB:
00D1EF  2  A6 85              LDX   Ememl             ; get end of mem low byte
00D1F1  2  A5 86              LDA   Ememh             ; get end of mem high byte
00D1F3  2               
00D1F3  2               ; re-run routine from last ending
00D1F3  2               
00D1F3  2               LAB_214B:
00D1F3  2  86 81              STX   Sstorl            ; set string storage low byte
00D1F5  2  85 82              STA   Sstorh            ; set string storage high byte
00D1F7  2  A0 00              LDY   #$00              ; clear index
00D1F9  2  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
00D1FB  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00D1FB  2               ; *** add
00D1FB  2  84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
00D1FD  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00D1FD  2  A5 7F              LDA   Earryl            ; get array mem end low byte
00D1FF  2  A6 80              LDX   Earryh            ; get array mem end high byte
00D201  2  85 AA              STA   Histrl            ; save as highest string low byte
00D203  2  86 AB              STX   Histrh            ; save as highest string high byte
00D205  2  A9 68              LDA   #des_sk           ; set descriptor stack pointer
00D207  2  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
00D209  2  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
00D20B  2               LAB_2161:
00D20B  2  C5 65              CMP   next_s            ; compare with descriptor stack pointer
00D20D  2  F0 05              BEQ   LAB_216A          ; branch if =
00D20F  2               
00D20F  2  20 75 D2           JSR   LAB_21D7          ; go garbage collect descriptor stack
00D212  2  F0 F7              BEQ   LAB_2161          ; loop always
00D214  2               
00D214  2                                             ; done stacked strings, now do string vars
00D214  2               LAB_216A:
00D214  2  06 A0              ASL   g_step            ; set step size = $06
00D216  2  A5 7B              LDA   Svarl             ; get start of vars low byte
00D218  2  A6 7C              LDX   Svarh             ; get start of vars high byte
00D21A  2  85 71              STA   ut1_pl            ; save as pointer low byte
00D21C  2  86 72              STX   ut1_ph            ; save as pointer high byte
00D21E  2               LAB_2176:
00D21E  2  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
00D220  2  D0 04              BNE   LAB_217E          ; branch if no high byte match
00D222  2               
00D222  2  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
00D224  2  F0 05              BEQ   LAB_2183          ; branch if = var mem end
00D226  2               
00D226  2               LAB_217E:
00D226  2  20 6F D2           JSR   LAB_21D1          ; go garbage collect strings
00D229  2  F0 F3              BEQ   LAB_2176          ; loop always
00D22B  2               
00D22B  2                                             ; done string vars, now do string arrays
00D22B  2               LAB_2183:
00D22B  2  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
00D22D  2  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
00D22F  2  A9 04              LDA   #$04              ; set step size
00D231  2  85 A0              STA   g_step            ; save step size
00D233  2               LAB_218B:
00D233  2  A5 A4              LDA   Nbendl            ; get pointer low byte
00D235  2  A6 A5              LDX   Nbendh            ; get pointer high byte
00D237  2               LAB_218F:
00D237  2  E4 80              CPX   Earryh            ; compare with array mem end high byte
00D239  2  D0 04              BNE   LAB_219A          ; branch if not at end
00D23B  2               
00D23B  2  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
00D23D  2  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
00D23F  2               
00D23F  2               LAB_219A:
00D23F  2  85 71              STA   ut1_pl            ; save pointer low byte
00D241  2  86 72              STX   ut1_ph            ; save pointer high byte
00D243  2  A0 02              LDY   #$02              ; set index
00D245  2  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
00D247  2  65 A4              ADC   Nbendl            ; add start of this array low byte
00D249  2  85 A4              STA   Nbendl            ; save start of next array low byte
00D24B  2  C8                 INY                     ; increment index
00D24C  2  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
00D24E  2  65 A5              ADC   Nbendh            ; add start of this array high byte
00D250  2  85 A5              STA   Nbendh            ; save start of next array high byte
00D252  2  A0 01              LDY   #$01              ; set index
00D254  2  B1 71              LDA   (ut1_pl),Y        ; get name second byte
00D256  2  10 DB              BPL   LAB_218B          ; skip if not string array
00D258  2               
00D258  2               ; was string array so ..
00D258  2               
00D258  2  A0 04              LDY   #$04              ; set index
00D25A  2  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
00D25C  2  0A                 ASL                     ; *2
00D25D  2  69 05              ADC   #$05              ; +5 (array header size)
00D25F  2  20 A7 D2           JSR   LAB_2208          ; go set up for first element
00D262  2               LAB_21C4:
00D262  2  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
00D264  2  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
00D266  2               
00D266  2  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
00D268  2                                             ; low byte
00D268  2  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
00D26A  2               
00D26A  2               LAB_21CC:
00D26A  2  20 75 D2           JSR   LAB_21D7          ; go defrag array strings
00D26D  2  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
00D26F  2               
00D26F  2               ; defrag string variables
00D26F  2               ; enter with XA = variable pointer
00D26F  2               ; return with XA = next variable pointer
00D26F  2               
00D26F  2               LAB_21D1:
00D26F  2  C8                 INY                     ; increment index (Y was $00)
00D270  2  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
00D272  2  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
00D274  2               
00D274  2  C8                 INY                     ; else increment index
00D275  2               LAB_21D7:
00D275  2  B1 71              LDA   (ut1_pl),Y        ; get string length
00D277  2  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
00D279  2               
00D279  2  C8                 INY                     ; else increment index
00D27A  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
00D27C  2  AA                 TAX                     ; copy to X
00D27D  2  C8                 INY                     ; increment index
00D27E  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
00D280  2  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
00D282  2  90 06              BCC   LAB_21EC          ; branch if less
00D284  2               
00D284  2  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
00D286  2               
00D286  2                                             ; high bytes were = so compare low bytes
00D286  2  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
00D288  2  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
00D28A  2               
00D28A  2                                             ; string pointer is < string storage pointer (pos in mem)
00D28A  2               LAB_21EC:
00D28A  2  C5 AB              CMP   Histrh            ; compare to highest string high byte
00D28C  2  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
00D28E  2               
00D28E  2  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
00D290  2               
00D290  2                                             ; high bytes were = so compare low bytes
00D290  2  E4 AA              CPX   Histrl            ; compare to highest string low byte
00D292  2  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
00D294  2               
00D294  2                                             ; string is in string memory space
00D294  2               LAB_21F6:
00D294  2  86 AA              STX   Histrl            ; save as new highest string low byte
00D296  2  85 AB              STA   Histrh            ; save as new highest string high byte
00D298  2  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
00D29A  2  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
00D29C  2  85 9C              STA   garb_l            ; save as working pointer low byte
00D29E  2  86 9D              STX   garb_h            ; save as working pointer high byte
00D2A0  2  88                 DEY                     ; decrement index DIFFERS
00D2A1  2  88                 DEY                     ; decrement index (should point to descriptor start)
00D2A2  2  84 A2              STY   g_indx            ; save index pointer
00D2A4  2               
00D2A4  2                                             ; step pointer to next string
00D2A4  2               LAB_2206:
00D2A4  2  18                 CLC                     ; clear carry for add
00D2A5  2               LAB_2207:
00D2A5  2  A5 A0              LDA   g_step            ; get step size
00D2A7  2               LAB_2208:
00D2A7  2  65 71              ADC   ut1_pl            ; add pointer low byte
00D2A9  2  85 71              STA   ut1_pl            ; save pointer low byte
00D2AB  2  90 02              BCC   LAB_2211          ; branch if no overflow
00D2AD  2               
00D2AD  2  E6 72              INC   ut1_ph            ; else increment high byte
00D2AF  2               LAB_2211:
00D2AF  2  A6 72              LDX   ut1_ph            ; get pointer high byte
00D2B1  2  A0 00              LDY   #$00              ; clear Y
00D2B3  2  60                 RTS
00D2B4  2               
00D2B4  2               ; search complete, now either exit or set-up and move string
00D2B4  2               
00D2B4  2               LAB_2216:
00D2B4  2  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
00D2B6  2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
00D2B6  2               ; *** replace
00D2B6  2               ;      LDX   garb_h            ; get string to move high byte
00D2B6  2               ; *** with
00D2B6  2  A5 9D              LDA   garb_h            ; any string to move?
00D2B8  2  05 9C              ORA   garb_l
00D2BA  2               ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
00D2BA  2  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
00D2BC  2               
00D2BC  2  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
00D2BE  2  18                 CLC                     ; clear carry for add
00D2BF  2  B1 9C              LDA   (garb_l),Y        ; get string length
00D2C1  2  65 AA              ADC   Histrl            ; add highest string low byte
00D2C3  2  85 A6              STA   Obendl            ; save old block end low pointer
00D2C5  2  A5 AB              LDA   Histrh            ; get highest string high byte
00D2C7  2  69 00              ADC   #$00              ; add any carry
00D2C9  2  85 A7              STA   Obendh            ; save old block end high byte
00D2CB  2  A5 81              LDA   Sstorl            ; get bottom of string space low byte
00D2CD  2  A6 82              LDX   Sstorh            ; get bottom of string space high byte
00D2CF  2  85 A4              STA   Nbendl            ; save new block end low byte
00D2D1  2  86 A5              STX   Nbendh            ; save new block end high byte
00D2D3  2  20 C8 C0           JSR   LAB_11D6          ; open up space in memory, don't set array end
00D2D6  2  A4 A2              LDY   g_indx            ; get index byte
00D2D8  2  C8                 INY                     ; point to descriptor low byte
00D2D9  2  A5 A4              LDA   Nbendl            ; get string pointer low byte
00D2DB  2  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
00D2DD  2  AA                 TAX                     ; copy string pointer low byte
00D2DE  2  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
00D2E0  2  A5 A5              LDA   Nbendh            ; get new string pointer high byte
00D2E2  2  C8                 INY                     ; point to descriptor high byte
00D2E3  2  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
00D2E5  2  4C F3 D1           JMP   LAB_214B          ; re-run routine from last ending
00D2E8  2                                             ; (but don't collect this string)
00D2E8  2               
00D2E8  2               ; concatenate
00D2E8  2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
00D2E8  2               
00D2E8  2               LAB_224D:
00D2E8  2  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
00D2EA  2  48                 PHA                     ; put on stack
00D2EB  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00D2ED  2  48                 PHA                     ; put on stack
00D2EE  2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00D2EE  2               ; *** add extra label to verify originating function
00D2EE  2               LAB_224Da:
00D2EE  2               ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
00D2EE  2  20 CD CB           JSR   LAB_GVAL          ; get value from line
00D2F1  2  20 D2 CA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00D2F4  2  68                 PLA                     ; get descriptor pointer low byte back
00D2F5  2  85 B8              STA   ssptr_l           ; set pointer low byte
00D2F7  2  68                 PLA                     ; get descriptor pointer high byte back
00D2F8  2  85 B9              STA   ssptr_h           ; set pointer high byte
00D2FA  2  A0 00              LDY   #$00              ; clear index
00D2FC  2  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
00D2FE  2  18                 CLC                     ; clear carry for add
00D2FF  2  71 AE              ADC   (des_pl),Y        ; add length_2
00D301  2  90 05              BCC   LAB_226D          ; branch if no overflow
00D303  2               
00D303  2  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
00D305  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00D308  2               
00D308  2               LAB_226D:
00D308  2  20 40 D1           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00D30B  2                                             ; long
00D30B  2  20 25 D3           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
00D30E  2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
00D310  2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
00D312  2  20 56 D3           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00D315  2                                             ; returns with A = length, ut1_pl = pointer low byte,
00D315  2                                             ; ut1_ph = pointer high byte
00D315  2  20 37 D3           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
00D318  2  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
00D31A  2  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
00D31C  2  20 56 D3           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00D31F  2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
00D31F  2                                             ; Y=ut1_ph=pointer high byte
00D31F  2  20 95 D1           JSR   LAB_RTST          ; check for space on descriptor stack then put string
00D322  2                                             ; address and length on descriptor stack and update stack
00D322  2                                             ; pointers
00D322  2  4C F8 CA           JMP   LAB_1ADB          ;.continue evaluation
00D325  2               
00D325  2               ; copy string from descriptor (sdescr) to (Sutill)
00D325  2               
00D325  2               LAB_228A:
00D325  2  A0 00              LDY   #$00              ; clear index
00D327  2  B1 B8              LDA   (sdescr),Y        ; get string length
00D329  2  48                 PHA                     ; save on stack
00D32A  2  C8                 INY                     ; increment index
00D32B  2  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
00D32D  2  AA                 TAX                     ; copy to X
00D32E  2  C8                 INY                     ; increment index
00D32F  2  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
00D331  2  A8                 TAY                     ; copy to Y
00D332  2  68                 PLA                     ; get length back
00D333  2               
00D333  2               ; store string A bytes long from YX to (Sutill)
00D333  2               
00D333  2               LAB_2298:
00D333  2  86 71              STX   ut1_pl            ; save source string pointer low byte
00D335  2  84 72              STY   ut1_ph            ; save source string pointer high byte
00D337  2               
00D337  2               ; store string A bytes long from (ut1_pl) to (Sutill)
00D337  2               
00D337  2               LAB_229C:
00D337  2  AA                 TAX                     ; copy length to index (don't count with Y)
00D338  2  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
00D33A  2               
00D33A  2  A0 00              LDY   #$00              ; zero pointer (copy forward)
00D33C  2               LAB_22A0:
00D33C  2  B1 71              LDA   (ut1_pl),Y        ; get source byte
00D33E  2  91 83              STA   (Sutill),Y        ; save destination byte
00D340  2               
00D340  2  C8                 INY                     ; increment index
00D341  2  CA                 DEX                     ; decrement counter
00D342  2  D0 F8              BNE   LAB_22A0          ; loop while <> 0
00D344  2               
00D344  2  98                 TYA                     ; restore length from Y
00D345  2               LAB_22A9:
00D345  2  18                 CLC                     ; clear carry for add
00D346  2  65 83              ADC   Sutill            ; add string utility ptr low byte
00D348  2  85 83              STA   Sutill            ; save string utility ptr low byte
00D34A  2  90 02              BCC   LAB_22B2          ; branch if no carry
00D34C  2               
00D34C  2  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
00D34E  2               LAB_22B2:
00D34E  2  60                 RTS
00D34F  2               
00D34F  2               ; evaluate string
00D34F  2               
00D34F  2               LAB_EVST:
00D34F  2  20 D2 CA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00D352  2               
00D352  2               ; pop string off descriptor stack, or from top of string space
00D352  2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
00D352  2               
00D352  2               LAB_22B6:
00D352  2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
00D354  2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
00D356  2               
00D356  2               ; pop (YA) descriptor off stack or from top of string space
00D356  2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
00D356  2               
00D356  2               LAB_22BA:
00D356  2  85 71              STA   ut1_pl            ; save descriptor pointer low byte
00D358  2  84 72              STY   ut1_ph            ; save descriptor pointer high byte
00D35A  2  20 87 D3           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
00D35D  2  08                 PHP                     ; save status flags
00D35E  2  A0 00              LDY   #$00              ; clear index
00D360  2  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
00D362  2  48                 PHA                     ; put on stack
00D363  2  C8                 INY                     ; increment index
00D364  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
00D366  2  AA                 TAX                     ; copy to X
00D367  2  C8                 INY                     ; increment index
00D368  2  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
00D36A  2  A8                 TAY                     ; copy to Y
00D36B  2  68                 PLA                     ; get string length back
00D36C  2  28                 PLP                     ; restore status
00D36D  2  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
00D36F  2               
00D36F  2  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
00D371  2  D0 0F              BNE   LAB_22E6          ; branch if <>
00D373  2               
00D373  2  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
00D375  2  D0 0B              BNE   LAB_22E6          ; branch if <>
00D377  2               
00D377  2  48                 PHA                     ; save string length
00D378  2  18                 CLC                     ; clear carry for add
00D379  2  65 81              ADC   Sstorl            ; add bottom of string space low byte
00D37B  2  85 81              STA   Sstorl            ; save bottom of string space low byte
00D37D  2  90 02              BCC   LAB_22E5          ; skip increment if no overflow
00D37F  2               
00D37F  2  E6 82              INC   Sstorh            ; increment bottom of string space high byte
00D381  2               LAB_22E5:
00D381  2  68                 PLA                     ; restore string length
00D382  2               LAB_22E6:
00D382  2  86 71              STX   ut1_pl            ; save string pointer low byte
00D384  2  84 72              STY   ut1_ph            ; save string pointer high byte
00D386  2  60                 RTS
00D387  2               
00D387  2               ; clean descriptor stack, YA = pointer
00D387  2               ; checks if AY is on the descriptor stack, if so does a stack discard
00D387  2               
00D387  2               LAB_22EB:
00D387  2  C4 67              CPY   last_sh           ; compare pointer high byte
00D389  2  D0 0C              BNE   LAB_22FB          ; exit if <>
00D38B  2               
00D38B  2  C5 66              CMP   last_sl           ; compare pointer low byte
00D38D  2  D0 08              BNE   LAB_22FB          ; exit if <>
00D38F  2               
00D38F  2  85 65              STA   next_s            ; save descriptor stack pointer
00D391  2  E9 03              SBC   #$03              ; -3
00D393  2  85 66              STA   last_sl           ; save low byte -3
00D395  2  A0 00              LDY   #$00              ; clear high byte
00D397  2               LAB_22FB:
00D397  2  60                 RTS
00D398  2               
00D398  2               ; perform CHR$()
00D398  2               
00D398  2               LAB_CHRS:
00D398  2  20 A3 D4           JSR   LAB_EVBY          ; evaluate byte expression, result in X
00D39B  2  8A                 TXA                     ; copy to A
00D39C  2  48                 PHA                     ; save character
00D39D  2  A9 01              LDA   #$01              ; string is single byte
00D39F  2  20 48 D1           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00D3A2  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00D3A2  2  68                 PLA                     ; get character back
00D3A3  2  A0 00              LDY   #$00              ; clear index
00D3A5  2  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
00D3A7  2  4C 95 D1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00D3AA  2                                             ; address and length on descriptor stack and update stack
00D3AA  2                                             ; pointers
00D3AA  2               
00D3AA  2               ; perform LEFT$()
00D3AA  2               
00D3AA  2               LAB_LEFT:
00D3AA  2  48                 PHA                     ; push byte parameter
00D3AB  2  20 0B D4           JSR   LAB_236F          ; pull string data and byte parameter from stack
00D3AE  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00D3AE  2  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
00D3B0  2  98                 TYA                     ; clear A
00D3B1  2  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
00D3B3  2               
00D3B3  2               ; perform RIGHT$()
00D3B3  2               
00D3B3  2               LAB_RIGHT:
00D3B3  2  48                 PHA                     ; push byte parameter
00D3B4  2  20 0B D4           JSR   LAB_236F          ; pull string data and byte parameter from stack
00D3B7  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00D3B7  2  18                 CLC                     ; clear carry for add-1
00D3B8  2  F1 9E              SBC   (des_2l),Y        ; subtract string length
00D3BA  2  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
00D3BC  2               
00D3BC  2               LAB_2316:
00D3BC  2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
00D3BE  2               
00D3BE  2  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
00D3C0  2  AA                 TAX                     ; copy to byte parameter copy
00D3C1  2  98                 TYA                     ; clear string start offset
00D3C2  2               LAB_231C:
00D3C2  2  48                 PHA                     ; save string start offset
00D3C3  2               LAB_231D:
00D3C3  2  8A                 TXA                     ; copy byte parameter (or string length if <)
00D3C4  2               LAB_231E:
00D3C4  2  48                 PHA                     ; save string length
00D3C5  2  20 48 D1           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
00D3C8  2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
00D3C8  2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
00D3CA  2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
00D3CC  2  20 56 D3           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00D3CF  2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
00D3CF  2                                             ; Y=ut1_ph=pointer high byte
00D3CF  2  68                 PLA                     ; get string length back
00D3D0  2  A8                 TAY                     ; copy length to Y
00D3D1  2  68                 PLA                     ; get string start offset back
00D3D2  2  18                 CLC                     ; clear carry for add
00D3D3  2  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
00D3D5  2  85 71              STA   ut1_pl            ; save string start pointer low byte
00D3D7  2  90 02              BCC   LAB_2335          ; branch if no overflow
00D3D9  2               
00D3D9  2  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
00D3DB  2               LAB_2335:
00D3DB  2  98                 TYA                     ; copy length to A
00D3DC  2  20 37 D3           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
00D3DF  2  4C 95 D1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00D3E2  2                                             ; address and length on descriptor stack and update stack
00D3E2  2                                             ; pointers
00D3E2  2               
00D3E2  2               ; perform MID$()
00D3E2  2               
00D3E2  2               LAB_MIDS:
00D3E2  2  48                 PHA                     ; push byte parameter
00D3E3  2  A9 FF              LDA   #$FF              ; set default length = 255
00D3E5  2  85 AF              STA   mids_l            ; save default length
00D3E7  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D3EA  2  C9 29              CMP   #')'              ; compare with ")"
00D3EC  2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
00D3EE  2               
00D3EE  2  20 FE CB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D3F1  2  20 A0 D4           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
00D3F4  2               LAB_2358:
00D3F4  2  20 0B D4           JSR   LAB_236F          ; pull string data and byte parameter from stack
00D3F7  2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
00D3F7  2  CA                 DEX                     ; decrement start index
00D3F8  2  8A                 TXA                     ; copy to A
00D3F9  2  48                 PHA                     ; save string start offset
00D3FA  2  18                 CLC                     ; clear carry for sub-1
00D3FB  2  A2 00              LDX   #$00              ; clear output string length
00D3FD  2  F1 9E              SBC   (des_2l),Y        ; subtract string length
00D3FF  2  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
00D401  2               
00D401  2  49 FF              EOR   #$FF              ; complement -length
00D403  2  C5 AF              CMP   mids_l            ; compare byte parameter
00D405  2  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
00D407  2               
00D407  2  A5 AF              LDA   mids_l            ; get length byte
00D409  2  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
00D40B  2               
00D40B  2               ; pull string data and byte parameter from stack
00D40B  2               ; return pointer in des_2l/h, byte in A (and X), Y=0
00D40B  2               
00D40B  2               LAB_236F:
00D40B  2  20 EF CB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00D40E  2  68                 PLA                     ; pull return address low byte (return address)
00D40F  2  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
00D411  2  68                 PLA                     ; pull return address high byte (return address)
00D412  2  85 A3              STA   Fnxjph            ; save functions jump vector high byte
00D414  2  68                 PLA                     ; pull byte parameter
00D415  2  AA                 TAX                     ; copy byte parameter to X
00D416  2  68                 PLA                     ; pull string pointer low byte
00D417  2  85 9E              STA   des_2l            ; save it
00D419  2  68                 PLA                     ; pull string pointer high byte
00D41A  2  85 9F              STA   des_2h            ; save it
00D41C  2  A0 00              LDY   #$00              ; clear index
00D41E  2  8A                 TXA                     ; copy byte parameter
00D41F  2  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
00D421  2               
00D421  2  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
00D423  2                                             ; (JSR pushes return addr-1. this is all very nice
00D423  2                                             ; but will go tits up if either call is on a page
00D423  2                                             ; boundary!)
00D423  2  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
00D426  2               
00D426  2               ; perform LCASE$()
00D426  2               
00D426  2               LAB_LCASE:
00D426  2  20 4F D3           JSR   LAB_EVST          ; evaluate string
00D429  2  85 AC              STA   str_ln            ; set string length
00D42B  2  A8                 TAY                     ; copy length to Y
00D42C  2  F0 38              BEQ   NoString          ; branch if null string
00D42E  2               
00D42E  2  20 48 D1           JSR   LAB_MSSP          ; make string space A bytes long A=length,
00D431  2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D431  2  86 AD              STX   str_pl            ; save string pointer low byte
00D433  2  84 AE              STY   str_ph            ; save string pointer high byte
00D435  2  A8                 TAY                     ; get string length back
00D436  2               
00D436  2               LC_loop:
00D436  2  88                 DEY                     ; decrement index
00D437  2  B1 71              LDA   (ut1_pl),Y        ; get byte from string
00D439  2  20 30 CE           JSR   LAB_1D82          ; is character "A" to "Z"
00D43C  2  90 02              BCC   NoUcase           ; branch if not upper case alpha
00D43E  2               
00D43E  2  09 20              ORA   #$20              ; convert upper to lower case
00D440  2               NoUcase:
00D440  2  91 83              STA   (Sutill),Y        ; save byte back to string
00D442  2  98                 TYA                     ; test index
00D443  2  D0 F1              BNE   LC_loop           ; loop if not all done
00D445  2               
00D445  2  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
00D447  2               
00D447  2               ; perform UCASE$()
00D447  2               
00D447  2               LAB_UCASE:
00D447  2  20 4F D3           JSR   LAB_EVST          ; evaluate string
00D44A  2  85 AC              STA   str_ln            ; set string length
00D44C  2  A8                 TAY                     ; copy length to Y
00D44D  2  F0 17              BEQ   NoString          ; branch if null string
00D44F  2               
00D44F  2  20 48 D1           JSR   LAB_MSSP          ; make string space A bytes long A=length,
00D452  2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00D452  2  86 AD              STX   str_pl            ; save string pointer low byte
00D454  2  84 AE              STY   str_ph            ; save string pointer high byte
00D456  2  A8                 TAY                     ; get string length back
00D457  2               
00D457  2               UC_loop:
00D457  2  88                 DEY                     ; decrement index
00D458  2  B1 71              LDA   (ut1_pl),Y        ; get byte from string
00D45A  2  20 2C CE           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
00D45D  2  90 02              BCC   NoLcase           ; branch if not alpha
00D45F  2               
00D45F  2  29 DF              AND   #$DF              ; convert lower to upper case
00D461  2               NoLcase:
00D461  2  91 83              STA   (Sutill),Y        ; save byte back to string
00D463  2  98                 TYA                     ; test index
00D464  2  D0 F1              BNE   UC_loop           ; loop if not all done
00D466  2               
00D466  2               NoString:
00D466  2  4C 95 D1           JMP   LAB_RTST          ; check for space on descriptor stack then put string
00D469  2                                             ; address and length on descriptor stack and update stack
00D469  2                                             ; pointers
00D469  2               
00D469  2               ; perform SADD()
00D469  2               
00D469  2               LAB_SADD:
00D469  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D46C  2  20 B8 CD           JSR   LAB_GVAR          ; get var address
00D46F  2               
00D46F  2  20 EF CB           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00D472  2  20 D2 CA           JSR   LAB_CTST          ; check if source is string, else do type mismatch
00D475  2               
00D475  2  A0 02              LDY   #$02              ; index to string pointer high byte
00D477  2  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
00D479  2  AA                 TAX                     ; copy string pointer high byte to X
00D47A  2  88                 DEY                     ; index to string pointer low byte
00D47B  2  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
00D47D  2  A8                 TAY                     ; copy string pointer low byte to Y
00D47E  2  8A                 TXA                     ; copy string pointer high byte to A
00D47F  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00D482  2               
00D482  2               ; perform LEN()
00D482  2               
00D482  2               LAB_LENS:
00D482  2  20 88 D4           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00D485  2  4C 74 D0           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00D488  2               
00D488  2               ; evaluate string, get length in Y
00D488  2               
00D488  2               LAB_ESGL:
00D488  2  20 4F D3           JSR   LAB_EVST          ; evaluate string
00D48B  2  A8                 TAY                     ; copy length to Y
00D48C  2  60                 RTS
00D48D  2               
00D48D  2               ; perform ASC()
00D48D  2               
00D48D  2               LAB_ASC:
00D48D  2  20 88 D4           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00D490  2  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
00D492  2               
00D492  2  A0 00              LDY   #$00              ; set index to first character
00D494  2  B1 71              LDA   (ut1_pl),Y        ; get byte
00D496  2  A8                 TAY                     ; copy to Y
00D497  2  4C 74 D0           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00D49A  2               
00D49A  2               ; do function call error then warm start
00D49A  2               
00D49A  2               LAB_23A8:
00D49A  2  4C 37 CF           JMP   LAB_FCER          ; do function call error then warm start
00D49D  2               
00D49D  2               ; scan and get byte parameter
00D49D  2               
00D49D  2               LAB_SGBY:
00D49D  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D4A0  2               
00D4A0  2               ; get byte parameter
00D4A0  2               
00D4A0  2               LAB_GTBY:
00D4A0  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D4A3  2                                             ; else do type mismatch
00D4A3  2               
00D4A3  2               ; evaluate byte expression, result in X
00D4A3  2               
00D4A3  2               LAB_EVBY:
00D4A3  2  20 B0 CE           JSR   LAB_EVPI          ; evaluate integer expression (no check)
00D4A6  2               
00D4A6  2  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
00D4A8  2  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
00D4AA  2               
00D4AA  2  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
00D4AC  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D4AF  2               
00D4AF  2               ; perform VAL()
00D4AF  2               
00D4AF  2               LAB_VAL:
00D4AF  2  20 88 D4           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
00D4B2  2  D0 03              BNE   LAB_23C5          ; branch if not null string
00D4B4  2               
00D4B4  2                                             ; string was null so set result = $00
00D4B4  2  4C 5D D6           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
00D4B7  2               
00D4B7  2               LAB_23C5:
00D4B7  2               ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
00D4B7  2               ; *** replace
00D4B7  2               ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
00D4B7  2               ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
00D4B7  2               ;      STX   Btmpl             ; save BASIC execute pointer low byte
00D4B7  2               ;      STY   Btmph             ; save BASIC execute pointer high byte
00D4B7  2               ;      LDX   ut1_pl            ; get string pointer low byte
00D4B7  2               ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
00D4B7  2               ;      CLC                     ; clear carry
00D4B7  2               ;      ADC   ut1_pl            ; add string length
00D4B7  2               ;      STA   ut2_pl            ; save string end low byte
00D4B7  2               ;      LDA   ut1_ph            ; get string pointer high byte
00D4B7  2               ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
00D4B7  2               ;      ADC   #$00              ; add carry to high byte
00D4B7  2               ;      STA   ut2_ph            ; save string end high byte
00D4B7  2               ;      LDY   #$00              ; set index to $00
00D4B7  2               ;      LDA   (ut2_pl),Y        ; get string end +1 byte
00D4B7  2               ;      PHA                     ; push it
00D4B7  2               ;      TYA                     ; clear A
00D4B7  2               ;      STA   (ut2_pl),Y        ; terminate string with $00
00D4B7  2               ;      JSR   LAB_GBYT          ; scan memory
00D4B7  2               ;      JSR   LAB_2887          ; get FAC1 from string
00D4B7  2               ;      PLA                     ; restore string end +1 byte
00D4B7  2               ;      LDY   #$00              ; set index to zero
00D4B7  2               ;      STA   (ut2_pl),Y        ; put string end byte back
00D4B7  2               ; *** with
00D4B7  2  48                 PHA                     ; save length
00D4B8  2  C8                 INY                     ; string length +1
00D4B9  2  98                 TYA
00D4BA  2  20 48 D1           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
00D4BD  2  68                 PLA                     ; get length back
00D4BE  2  20 37 D3           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
00D4C1  2  A9 00              LDA   #0                ; add delimiter to end of string
00D4C3  2  A8                 TAY
00D4C4  2  91 83              STA   (Sutill),Y
00D4C6  2  A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
00D4C8  2  A4 C4              LDY   Bpntrh
00D4CA  2  86 BA              STX   Btmpl
00D4CC  2  84 BB              STY   Btmph
00D4CE  2  A6 AD              LDX   str_pl            ; point to temporary string
00D4D0  2  A4 AE              LDY   str_ph
00D4D2  2  86 C3              STX   Bpntrl
00D4D4  2  84 C4              STY   Bpntrh
00D4D6  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D4D9  2  20 B3 D9           JSR   LAB_2887          ; get FAC1 from string
00D4DC  2               ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
00D4DC  2               
00D4DC  2               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
00D4DC  2               
00D4DC  2               LAB_23F3:
00D4DC  2  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
00D4DE  2  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
00D4E0  2  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
00D4E2  2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
00D4E4  2  60                 RTS
00D4E5  2               
00D4E5  2               ; get two parameters for POKE or WAIT
00D4E5  2               
00D4E5  2               LAB_GADB:
00D4E5  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D4E8  2                                             ; else do type mismatch
00D4E8  2  20 FE D4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00D4EB  2               
00D4EB  2               ; scan for "," and get byte, else do Syntax error then warm start
00D4EB  2               
00D4EB  2               LAB_SCGB:
00D4EB  2  20 FE CB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D4EE  2  A5 12              LDA   Itemph            ; save temporary integer high byte
00D4F0  2  48                 PHA                     ; on stack
00D4F1  2  A5 11              LDA   Itempl            ; save temporary integer low byte
00D4F3  2  48                 PHA                     ; on stack
00D4F4  2  20 A0 D4           JSR   LAB_GTBY          ; get byte parameter
00D4F7  2  68                 PLA                     ; pull low byte
00D4F8  2  85 11              STA   Itempl            ; restore temporary integer low byte
00D4FA  2  68                 PLA                     ; pull high byte
00D4FB  2  85 12              STA   Itemph            ; restore temporary integer high byte
00D4FD  2  60                 RTS
00D4FE  2               
00D4FE  2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
00D4FE  2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
00D4FE  2               
00D4FE  2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
00D4FE  2               
00D4FE  2               LAB_F2FX:
00D4FE  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D500  2  C9 98              CMP   #$98              ; compare with exponent = 2^24
00D502  2  B0 96              BCS   LAB_23A8          ; if >= do function call error then warm start
00D504  2               
00D504  2               LAB_F2FU:
00D504  2  20 5D D9           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00D507  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D509  2  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
00D50B  2  84 11              STY   Itempl            ; save temporary integer low byte
00D50D  2  85 12              STA   Itemph            ; save temporary integer high byte
00D50F  2  60                 RTS
00D510  2               
00D510  2               ; perform PEEK()
00D510  2               
00D510  2               LAB_PEEK:
00D510  2  20 FE D4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00D513  2  A2 00              LDX   #$00              ; clear index
00D515  2  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
00D517  2  A8                 TAY                     ; copy byte to Y
00D518  2  4C 74 D0           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00D51B  2               
00D51B  2               ; perform POKE
00D51B  2               
00D51B  2               LAB_POKE:
00D51B  2  20 E5 D4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00D51E  2  8A                 TXA                     ; copy byte argument to A
00D51F  2  A2 00              LDX   #$00              ; clear index
00D521  2  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
00D523  2  60                 RTS
00D524  2               
00D524  2               ; perform DEEK()
00D524  2               
00D524  2               LAB_DEEK:
00D524  2  20 FE D4           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
00D527  2  A2 00              LDX   #$00              ; clear index
00D529  2  A1 11              LDA   (Itempl,X)        ; PEEK low byte
00D52B  2  A8                 TAY                     ; copy to Y
00D52C  2  E6 11              INC   Itempl            ; increment pointer low byte
00D52E  2  D0 02              BNE   Deekh             ; skip high increment if no rollover
00D530  2               
00D530  2  E6 12              INC   Itemph            ; increment pointer high byte
00D532  2               Deekh:
00D532  2  A1 11              LDA   (Itempl,X)        ; PEEK high byte
00D534  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00D537  2               
00D537  2               ; perform DOKE
00D537  2               
00D537  2               LAB_DOKE:
00D537  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D53A  2                                             ; else do type mismatch
00D53A  2  20 FE D4           JSR   LAB_F2FX          ; convert floating-to-fixed
00D53D  2               
00D53D  2  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
00D53F  2  85 98              STA   Frnxth            ; save pointer high byte
00D541  2               
00D541  2  20 FE CB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D544  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D547  2                                             ; else do type mismatch
00D547  2  20 FE D4           JSR   LAB_F2FX          ; convert floating-to-fixed
00D54A  2               
00D54A  2  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
00D54B  2  A2 00              LDX   #$00              ; clear index
00D54D  2  81 97              STA   (Frnxtl,X)        ; POKE low byte
00D54F  2  E6 97              INC   Frnxtl            ; increment pointer low byte
00D551  2  D0 02              BNE   Dokeh             ; skip high increment if no rollover
00D553  2               
00D553  2  E6 98              INC   Frnxth            ; increment pointer high byte
00D555  2               Dokeh:
00D555  2  A5 12              LDA   Itemph            ; get value high byte
00D557  2  81 97              STA   (Frnxtl,X)        ; POKE high byte
00D559  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D55C  2               
00D55C  2               ; perform SWAP
00D55C  2               
00D55C  2               LAB_SWAP:
00D55C  2  20 B8 CD           JSR   LAB_GVAR          ; get var1 address
00D55F  2  85 97              STA   Lvarpl            ; save var1 address low byte
00D561  2  84 98              STY   Lvarph            ; save var1 address high byte
00D563  2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
00D565  2  48                 PHA                     ; save data type flag
00D566  2               
00D566  2  20 FE CB           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
00D569  2  20 B8 CD           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
00D56C  2  68                 PLA                     ; pull var1 data type flag
00D56D  2  45 5F              EOR   Dtypef            ; compare with var2 data type
00D56F  2  10 10              BPL   SwapErr           ; exit if not both the same type
00D571  2               
00D571  2  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
00D573  2               SwapLp:
00D573  2  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
00D575  2  AA                 TAX                     ; save var1 byte
00D576  2  B1 95              LDA   (Cvaral),Y        ; get byte from var2
00D578  2  91 97              STA   (Lvarpl),Y        ; save byte to var1
00D57A  2  8A                 TXA                     ; restore var1 byte
00D57B  2  91 95              STA   (Cvaral),Y        ; save byte to var2
00D57D  2  88                 DEY                     ; decrement index
00D57E  2  10 F3              BPL   SwapLp            ; loop until done
00D580  2               
00D580  2  60                 RTS
00D581  2               
00D581  2               SwapErr:
00D581  2  4C DC CA           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
00D584  2               
00D584  2               ; perform CALL
00D584  2               
00D584  2               LAB_CALL:
00D584  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00D587  2                                             ; else do type mismatch
00D587  2  20 FE D4           JSR   LAB_F2FX          ; convert floating-to-fixed
00D58A  2  A9 D5              LDA   #>CallExit        ; set return address high byte
00D58C  2  48                 PHA                     ; put on stack
00D58D  2  A9 92              LDA   #<CallExit-1      ; set return address low byte
00D58F  2  48                 PHA                     ; put on stack
00D590  2  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
00D593  2               
00D593  2               ; if the called routine exits correctly then it will return to here. this will then get
00D593  2               ; the next byte for the interpreter and return
00D593  2               
00D593  2               CallExit:
00D593  2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00D596  2               
00D596  2               ; perform WAIT
00D596  2               
00D596  2               LAB_WAIT:
00D596  2  20 E5 D4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00D599  2  86 97              STX   Frnxtl            ; save byte
00D59B  2  A2 00              LDX   #$00              ; clear mask
00D59D  2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00D5A0  2  F0 03              BEQ   LAB_2441          ; skip if no third argument
00D5A2  2               
00D5A2  2  20 EB D4           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
00D5A5  2               LAB_2441:
00D5A5  2  86 98              STX   Frnxth            ; save EOR argument
00D5A7  2               LAB_2445:
00D5A7  2  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
00D5A9  2  45 98              EOR   Frnxth            ; EOR with second argument (mask)
00D5AB  2  25 97              AND   Frnxtl            ; AND with first argument (byte)
00D5AD  2  F0 F8              BEQ   LAB_2445          ; loop if result is zero
00D5AF  2               
00D5AF  2               LAB_244D:
00D5AF  2  60                 RTS
00D5B0  2               
00D5B0  2               ; perform subtraction, FAC1 from (AY)
00D5B0  2               
00D5B0  2               LAB_2455:
00D5B0  2  20 98 D7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00D5B3  2               
00D5B3  2               ; perform subtraction, FAC1 from FAC2
00D5B3  2               
00D5B3  2               LAB_SUBTRACT:
00D5B3  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D5B5  2  49 FF              EOR   #$FF              ; complement it
00D5B7  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D5B9  2  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
00D5BB  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00D5BD  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D5BF  2  4C CE D5           JMP   LAB_ADD           ; go add FAC2 to FAC1
00D5C2  2               
00D5C2  2               ; perform addition
00D5C2  2               
00D5C2  2               LAB_2467:
00D5C2  2  20 E7 D6           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
00D5C5  2  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
00D5C7  2               
00D5C7  2               ; add 0.5 to FAC1
00D5C7  2               
00D5C7  2               LAB_244E:
00D5C7  2  A9 F8              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
00D5C9  2  A0 E1              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
00D5CB  2               
00D5CB  2               ; add (AY) to FAC1
00D5CB  2               
00D5CB  2               LAB_246C:
00D5CB  2  20 98 D7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00D5CE  2               
00D5CE  2               ; add FAC2 to FAC1
00D5CE  2               
00D5CE  2               LAB_ADD:
00D5CE  2  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
00D5D0  2               
00D5D0  2               ; copy FAC2 to FAC1
00D5D0  2               
00D5D0  2               LAB_279B:
00D5D0  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00D5D2  2               
00D5D2  2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
00D5D2  2               
00D5D2  2               LAB_279D:
00D5D2  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D5D4  2  A2 04              LDX   #$04              ; 4 bytes to copy
00D5D6  2               LAB_27A1:
00D5D6  2  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
00D5D8  2  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
00D5DA  2  CA                 DEX                     ; decrement count
00D5DB  2  D0 F9              BNE   LAB_27A1          ; loop if not all done
00D5DD  2               
00D5DD  2  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
00D5DF  2  60                 RTS
00D5E0  2               
00D5E0  2                                             ; FAC1 is non zero
00D5E0  2               LAB_2474:
00D5E0  2  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
00D5E2  2  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
00D5E4  2  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
00D5E6  2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
00D5E8  2               LAB_247C:
00D5E8  2  A8                 TAY                     ; copy exponent
00D5E9  2  F0 C4              BEQ   LAB_244D          ; exit if zero
00D5EB  2               
00D5EB  2  38                 SEC                     ; set carry for subtract
00D5EC  2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
00D5EE  2  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
00D5F0  2               
00D5F0  2  90 12              BCC   LAB_2498          ; branch if <
00D5F2  2               
00D5F2  2                                             ; FAC2>FAC1
00D5F2  2  84 AC              STY   FAC1_e            ; save FAC1 exponent
00D5F4  2  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
00D5F6  2  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
00D5F8  2  49 FF              EOR   #$FF              ; complement A
00D5FA  2  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
00D5FC  2  A0 00              LDY   #$00              ; clear Y
00D5FE  2  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
00D600  2  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
00D602  2  D0 04              BNE   LAB_249C          ; branch always
00D604  2               
00D604  2               LAB_2498:
00D604  2  A0 00              LDY   #$00              ; clear Y
00D606  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00D608  2               LAB_249C:
00D608  2  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
00D60A  2  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
00D60C  2               
00D60C  2  A8                 TAY                     ; copy exponent difference to Y
00D60D  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00D60F  2  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
00D611  2  20 FE D6           JSR   LAB_2592          ; shift FACX Y times right
00D614  2               
00D614  2                                             ; exponents are equal now do mantissa subtract
00D614  2               LAB_24A8:
00D614  2  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
00D616  2  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
00D618  2               
00D618  2  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
00D61A  2  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
00D61C  2  F0 02              BEQ   LAB_24B4          ; branch if =
00D61E  2               
00D61E  2  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
00D620  2               
00D620  2                                             ; subtract smaller from bigger (take sign of bigger)
00D620  2               LAB_24B4:
00D620  2  38                 SEC                     ; set carry for subtract
00D621  2  49 FF              EOR   #$FF              ; ones complement A
00D623  2  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
00D625  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00D627  2  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
00D62A  2  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
00D62C  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D62E  2  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
00D631  2  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
00D633  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D635  2  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
00D638  2  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
00D63A  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D63C  2               
00D63C  2               ; do ABS and normalise FAC1
00D63C  2               
00D63C  2               LAB_24D0:
00D63C  2  B0 03              BCS   LAB_24D5          ; branch if number is +ve
00D63E  2               
00D63E  2  20 A3 D6           JSR   LAB_2537          ; negate FAC1
00D641  2               
00D641  2               ; normalise FAC1
00D641  2               
00D641  2               LAB_24D5:
00D641  2  A0 00              LDY   #$00              ; clear Y
00D643  2  98                 TYA                     ; clear A
00D644  2  18                 CLC                     ; clear carry for add
00D645  2               LAB_24D9:
00D645  2  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
00D647  2  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
00D649  2               
00D649  2  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
00D64B  2  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
00D64D  2  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
00D64F  2  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
00D651  2  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
00D653  2  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
00D655  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00D657  2  69 08              ADC   #$08              ; add x to exponent offset
00D659  2  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
00D65B  2  D0 E8              BNE   LAB_24D9          ; loop if not max
00D65D  2               
00D65D  2               ; clear FAC1 exponent and sign
00D65D  2               
00D65D  2               LAB_24F1:
00D65D  2  A9 00              LDA   #$00              ; clear A
00D65F  2               LAB_24F3:
00D65F  2  85 AC              STA   FAC1_e            ; set FAC1 exponent
00D661  2               
00D661  2               ; save FAC1 sign
00D661  2               
00D661  2               LAB_24F5:
00D661  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D663  2  60                 RTS
00D664  2               
00D664  2               ; add FAC2 mantissa to FAC1 mantissa
00D664  2               
00D664  2               LAB_24F8:
00D664  2  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
00D666  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00D668  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00D66A  2  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
00D66C  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D66E  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D670  2  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
00D672  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D674  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00D676  2  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
00D678  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D67A  2  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
00D67C  2               
00D67C  2  60                 RTS                     ; else just exit
00D67D  2               
00D67D  2               LAB_2511:
00D67D  2  69 01              ADC   #$01              ; add 1 to exponent offset
00D67F  2  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
00D681  2  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
00D683  2  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
00D685  2  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
00D687  2               
00D687  2               ; normalise FAC1
00D687  2               
00D687  2               LAB_251B:
00D687  2  10 F4              BPL   LAB_2511          ; loop if not normalised
00D689  2               
00D689  2  38                 SEC                     ; set carry for subtract
00D68A  2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
00D68C  2  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
00D68E  2               
00D68E  2  49 FF              EOR   #$FF              ; complement exponent
00D690  2  69 01              ADC   #$01              ; +1 (twos complement)
00D692  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00D694  2               
00D694  2               ; test and normalise FAC1 for C=0/1
00D694  2               
00D694  2               LAB_2528:
00D694  2  90 0C              BCC   LAB_2536          ; exit if no overflow
00D696  2               
00D696  2               ; normalise FAC1 for C=1
00D696  2               
00D696  2               LAB_252A:
00D696  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
00D698  2  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
00D69A  2               
00D69A  2  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
00D69C  2  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
00D69E  2  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
00D6A0  2  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
00D6A2  2               LAB_2536:
00D6A2  2  60                 RTS
00D6A3  2               
00D6A3  2               ; negate FAC1
00D6A3  2               
00D6A3  2               LAB_2537:
00D6A3  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D6A5  2  49 FF              EOR   #$FF              ; complement it
00D6A7  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D6A9  2               
00D6A9  2               ; twos complement FAC1 mantissa
00D6A9  2               
00D6A9  2               LAB_253D:
00D6A9  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00D6AB  2  49 FF              EOR   #$FF              ; complement it
00D6AD  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D6AF  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D6B1  2  49 FF              EOR   #$FF              ; complement it
00D6B3  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D6B5  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00D6B7  2  49 FF              EOR   #$FF              ; complement it
00D6B9  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D6BB  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00D6BD  2  49 FF              EOR   #$FF              ; complement it
00D6BF  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00D6C1  2  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
00D6C3  2  D0 0A              BNE   LAB_2563          ; exit if no overflow
00D6C5  2               
00D6C5  2               ; increment FAC1 mantissa
00D6C5  2               
00D6C5  2               LAB_2559:
00D6C5  2  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
00D6C7  2  D0 06              BNE   LAB_2563          ; finished if no rollover
00D6C9  2               
00D6C9  2  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
00D6CB  2  D0 02              BNE   LAB_2563          ; finished if no rollover
00D6CD  2               
00D6CD  2  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
00D6CF  2               LAB_2563:
00D6CF  2  60                 RTS
00D6D0  2               
00D6D0  2               ; do overflow error (overflow exit)
00D6D0  2               
00D6D0  2               LAB_2564:
00D6D0  2  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
00D6D2  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00D6D5  2               
00D6D5  2               ; shift FCAtemp << A+8 times
00D6D5  2               
00D6D5  2               LAB_2569:
00D6D5  2  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
00D6D7  2               LAB_256B:
00D6D7  2  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
00D6D9  2  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
00D6DB  2  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
00D6DD  2  94 03              STY   PLUS_3,X          ; save FACX mantissa3
00D6DF  2  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
00D6E1  2  94 02              STY   PLUS_2,X          ; save FACX mantissa2
00D6E3  2  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
00D6E5  2  94 01              STY   PLUS_1,X          ; save FACX mantissa1
00D6E7  2               
00D6E7  2               ; shift FACX -A times right (> 8 shifts)
00D6E7  2               
00D6E7  2               LAB_257B:
00D6E7  2  69 08              ADC   #$08              ; add 8 to shift count
00D6E9  2  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
00D6EB  2               
00D6EB  2  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
00D6ED  2               
00D6ED  2  E9 08              SBC   #$08              ; else subtract 8 again
00D6EF  2  A8                 TAY                     ; save count to Y
00D6F0  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00D6F2  2  B0 12              BCS   LAB_259A          ;.
00D6F4  2               
00D6F4  2               LAB_2588:
00D6F4  2  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
00D6F6  2  90 02              BCC   LAB_258E          ; branch if +ve
00D6F8  2               
00D6F8  2  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
00D6FA  2               LAB_258E:
00D6FA  2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
00D6FC  2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
00D6FE  2               
00D6FE  2               ; shift FACX Y times right
00D6FE  2               
00D6FE  2               LAB_2592:
00D6FE  2  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
00D700  2  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
00D702  2  6A                 ROR                     ; shift FACX rounding byte
00D703  2  C8                 INY                     ; increment exponent diff
00D704  2  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
00D706  2               
00D706  2               LAB_259A:
00D706  2  18                 CLC                     ; just clear it
00D707  2  60                 RTS
00D708  2               
00D708  2               ; perform LOG()
00D708  2               
00D708  2               LAB_LOG:
00D708  2  20 F6 D8           JSR   LAB_27CA          ; test sign and zero
00D70B  2  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
00D70D  2               
00D70D  2  10 03              BPL   LAB_25C7          ; skip error if +ve
00D70F  2               
00D70F  2               LAB_25C4:
00D70F  2  4C 37 CF           JMP   LAB_FCER          ; do function call error then warm start (-ve)
00D712  2               
00D712  2               LAB_25C7:
00D712  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D714  2  E9 7F              SBC   #$7F              ; normalise it
00D716  2  48                 PHA                     ; save it
00D717  2  A9 80              LDA   #$80              ; set exponent to zero
00D719  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00D71B  2  A9 78              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
00D71D  2  A0 E1              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
00D71F  2  20 CB D5           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
00D722  2  A9 7C              LDA   #<LAB_25B1        ; set root2 pointer low byte
00D724  2  A0 E1              LDY   #>LAB_25B1        ; set root2 pointer high byte
00D726  2  20 0E D8           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
00D729  2  A9 EF              LDA   #<LAB_259C        ; set 1 pointer low byte
00D72B  2  A0 E1              LDY   #>LAB_259C        ; set 1 pointer high byte
00D72D  2  20 B0 D5           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
00D730  2  A9 6B              LDA   #<LAB_25A0        ; set pointer low byte to counter
00D732  2  A0 E1              LDY   #>LAB_25A0        ; set pointer high byte to counter
00D734  2  20 5E DC           JSR   LAB_2B6E          ; ^2 then series evaluation
00D737  2  A9 80              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
00D739  2  A0 E1              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
00D73B  2  20 CB D5           JSR   LAB_246C          ; add (AY) to FAC1
00D73E  2  68                 PLA                     ; restore FAC1 exponent
00D73F  2  20 52 DA           JSR   LAB_2912          ; evaluate new ASCII digit
00D742  2  A9 84              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
00D744  2  A0 E1              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
00D746  2               
00D746  2               ; do convert AY, FCA1*(AY)
00D746  2               
00D746  2               LAB_25FB:
00D746  2  20 98 D7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00D749  2               LAB_MULTIPLY:
00D749  2  F0 4C              BEQ   LAB_264C          ; exit if zero
00D74B  2               
00D74B  2  20 BE D7           JSR   LAB_2673          ; test and adjust accumulators
00D74E  2  A9 00              LDA   #$00              ; clear A
00D750  2  85 75              STA   FACt_1            ; clear temp mantissa1
00D752  2  85 76              STA   FACt_2            ; clear temp mantissa2
00D754  2  85 77              STA   FACt_3            ; clear temp mantissa3
00D756  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00D758  2  20 6D D7           JSR   LAB_2622          ; go do shift/add FAC2
00D75B  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00D75D  2  20 6D D7           JSR   LAB_2622          ; go do shift/add FAC2
00D760  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D762  2  20 6D D7           JSR   LAB_2622          ; go do shift/add FAC2
00D765  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00D767  2  20 73 D7           JSR   LAB_2627          ; go do shift/add FAC2
00D76A  2  4C 7B D8           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
00D76D  2               
00D76D  2               LAB_2622:
00D76D  2  D0 04              BNE   LAB_2627          ; branch if byte <> zero
00D76F  2               ; *** begin patch  2.22p5.6  floating point multiply rounding bug
00D76F  2               ; *** replace
00D76F  2               ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
00D76F  2               ;
00D76F  2               ;                              ; else do shift and add
00D76F  2               ;LAB_2627
00D76F  2               ;      LSR                     ; shift byte
00D76F  2               ;      ORA   #$80              ; set top bit (mark for 8 times)
00D76F  2               ; *** with
00D76F  2  38                 SEC
00D770  2  4C D5 D6           JMP   LAB_2569          ; shift FACtemp << A+8 times
00D773  2               
00D773  2                                             ; else do shift and add
00D773  2               LAB_2627:
00D773  2  38                 SEC                     ; set top bit (mark for 8 times)
00D774  2  6A                 ROR
00D775  2               ; *** end patch    2.22p5.6  floating point multiply rounding bug
00D775  2               LAB_262A:
00D775  2  A8                 TAY                     ; copy result
00D776  2  90 13              BCC   LAB_2640          ; skip next if bit was zero
00D778  2               
00D778  2  18                 CLC                     ; clear carry for add
00D779  2  A5 77              LDA   FACt_3            ; get temp mantissa3
00D77B  2  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
00D77D  2  85 77              STA   FACt_3            ; save temp mantissa3
00D77F  2  A5 76              LDA   FACt_2            ; get temp mantissa2
00D781  2  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
00D783  2  85 76              STA   FACt_2            ; save temp mantissa2
00D785  2  A5 75              LDA   FACt_1            ; get temp mantissa1
00D787  2  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
00D789  2  85 75              STA   FACt_1            ; save temp mantissa1
00D78B  2               LAB_2640:
00D78B  2  66 75              ROR   FACt_1            ; shift temp mantissa1
00D78D  2  66 76              ROR   FACt_2            ; shift temp mantissa2
00D78F  2  66 77              ROR   FACt_3            ; shift temp mantissa3
00D791  2  66 B9              ROR   FAC1_r            ; shift temp rounding byte
00D793  2  98                 TYA                     ; get byte back
00D794  2  4A                 LSR                     ; shift byte
00D795  2  D0 DE              BNE   LAB_262A          ; loop if all bits not done
00D797  2               
00D797  2               LAB_264C:
00D797  2  60                 RTS
00D798  2               
00D798  2               ; unpack memory (AY) into FAC2
00D798  2               
00D798  2               LAB_264D:
00D798  2  85 71              STA   ut1_pl            ; save pointer low byte
00D79A  2  84 72              STY   ut1_ph            ; save pointer high byte
00D79C  2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
00D79E  2  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
00D7A0  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00D7A2  2  88                 DEY                     ; decrement index
00D7A3  2  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
00D7A5  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00D7A7  2  88                 DEY                     ; decrement index
00D7A8  2  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
00D7AA  2  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
00D7AC  2  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
00D7AE  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00D7B0  2  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
00D7B2  2  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
00D7B4  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00D7B6  2  88                 DEY                     ; decrement index
00D7B7  2  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
00D7B9  2  85 B3              STA   FAC2_e            ; save FAC2 exponent
00D7BB  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D7BD  2  60                 RTS
00D7BE  2               
00D7BE  2               ; test and adjust accumulators
00D7BE  2               
00D7BE  2               LAB_2673:
00D7BE  2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
00D7C0  2               LAB_2675:
00D7C0  2  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
00D7C2  2               
00D7C2  2  18                 CLC                     ; clear carry for add
00D7C3  2  65 AC              ADC   FAC1_e            ; add FAC1 exponent
00D7C5  2  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
00D7C7  2               
00D7C7  2  30 31              BMI   LAB_269B          ; do overflow error
00D7C9  2               
00D7C9  2  18                 CLC                     ; clear carry for the add
00D7CA  2  2C                 .byte $2C               ; makes next line BIT $1410
00D7CB  2               LAB_2680:
00D7CB  2  10 12              BPL   LAB_2696          ; if +ve go handle underflow
00D7CD  2               
00D7CD  2  69 80              ADC   #$80              ; adjust exponent
00D7CF  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00D7D1  2  D0 03              BNE   LAB_268B          ; branch if not zero
00D7D3  2               
00D7D3  2  4C 61 D6           JMP   LAB_24F5          ; save FAC1 sign and return
00D7D6  2               
00D7D6  2               LAB_268B:
00D7D6  2  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
00D7D8  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D7DA  2               LAB_268F:
00D7DA  2  60                 RTS
00D7DB  2               
00D7DB  2               ; handle overflow and underflow
00D7DB  2               
00D7DB  2               LAB_2690:
00D7DB  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D7DD  2  10 1B              BPL   LAB_269B          ; do overflow error
00D7DF  2               
00D7DF  2                                             ; handle underflow
00D7DF  2               LAB_2696:
00D7DF  2  68                 PLA                     ; pop return address low byte
00D7E0  2  68                 PLA                     ; pop return address high byte
00D7E1  2  4C 5D D6           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
00D7E4  2               
00D7E4  2               ; multiply by 10
00D7E4  2               
00D7E4  2               LAB_269E:
00D7E4  2  20 D7 D8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00D7E7  2  AA                 TAX                     ; copy exponent (set the flags)
00D7E8  2  F0 F0              BEQ   LAB_268F          ; exit if zero
00D7EA  2               
00D7EA  2  18                 CLC                     ; clear carry for add
00D7EB  2  69 02              ADC   #$02              ; add two to exponent (*4)
00D7ED  2  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
00D7EF  2               
00D7EF  2  A2 00              LDX   #$00              ; clear byte
00D7F1  2  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00D7F3  2  20 E8 D5           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
00D7F6  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
00D7F8  2  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
00D7FA  2               
00D7FA  2               LAB_269B:
00D7FA  2  4C D0 D6           JMP   LAB_2564          ; do overflow error and warm start
00D7FD  2               
00D7FD  2               ; divide by 10
00D7FD  2               
00D7FD  2               LAB_26B9:
00D7FD  2  20 D7 D8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00D800  2  A9 00              LDA   #<LAB_26B5        ; set pointer to 10d low addr
00D802  2  A0 E2              LDY   #>LAB_26B5        ; set pointer to 10d high addr
00D804  2  A2 00              LDX   #$00              ; clear sign
00D806  2               
00D806  2               ; divide by (AY) (X=sign)
00D806  2               
00D806  2               LAB_26C2:
00D806  2  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00D808  2  20 8A D8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00D80B  2  4C 11 D8           JMP   LAB_DIVIDE        ; do FAC2/FAC1
00D80E  2               
00D80E  2                                             ; Perform divide-by
00D80E  2               ; convert AY and do (AY)/FAC1
00D80E  2               
00D80E  2               LAB_26CA:
00D80E  2  20 98 D7           JSR   LAB_264D          ; unpack memory (AY) into FAC2
00D811  2               
00D811  2                                             ; Perform divide-into
00D811  2               LAB_DIVIDE:
00D811  2  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
00D813  2               
00D813  2  20 E6 D8           JSR   LAB_27BA          ; round FAC1
00D816  2  A9 00              LDA   #$00              ; clear A
00D818  2  38                 SEC                     ; set carry for subtract
00D819  2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
00D81B  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00D81D  2  20 BE D7           JSR   LAB_2673          ; test and adjust accumulators
00D820  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
00D822  2  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
00D824  2               
00D824  2  A2 FF              LDX   #$FF              ; set index for pre increment
00D826  2  A9 01              LDA   #$01              ; set bit to flag byte save
00D828  2               LAB_26E4:
00D828  2  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
00D82A  2  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
00D82C  2  D0 0A              BNE   LAB_26F4          ; branch if <>
00D82E  2               
00D82E  2  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
00D830  2  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
00D832  2  D0 04              BNE   LAB_26F4          ; branch if <>
00D834  2               
00D834  2  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
00D836  2  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
00D838  2               LAB_26F4:
00D838  2  08                 PHP                     ; save FAC2-FAC1 compare status
00D839  2  2A                 ROL                     ; shift the result byte
00D83A  2  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
00D83C  2               
00D83C  2  A0 01              LDY   #$01              ; set bit to flag byte save
00D83E  2  E8                 INX                     ; else increment the index to FACt
00D83F  2  E0 02              CPX   #$02              ; compare with the index to FACt_3
00D841  2  30 04              BMI   LAB_2701          ; if not last byte just go save it
00D843  2               
00D843  2  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
00D845  2                                             ; return
00D845  2               
00D845  2  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
00D847  2               LAB_2701:
00D847  2  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
00D849  2  98                 TYA                     ; copy the next save byte flag
00D84A  2               LAB_2702:
00D84A  2  28                 PLP                     ; restore FAC2-FAC1 compare status
00D84B  2  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
00D84D  2               
00D84D  2  A8                 TAY                     ; save FAC2-FAC1 compare status
00D84E  2  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
00D850  2  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
00D852  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00D854  2  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
00D856  2  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
00D858  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00D85A  2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00D85C  2  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
00D85E  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00D860  2  98                 TYA                     ; restore FAC2-FAC1 compare status
00D861  2               
00D861  2                                             ; FAC2 = FAC2*2
00D861  2               LAB_2704:
00D861  2  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
00D863  2  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
00D865  2  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
00D867  2  B0 CF              BCS   LAB_26F4          ; loop with no compare
00D869  2               
00D869  2  30 BD              BMI   LAB_26E4          ; loop with compare
00D86B  2               
00D86B  2  10 CB              BPL   LAB_26F4          ; loop always with no compare
00D86D  2               
00D86D  2               ; do A<<6, save as FAC1 rounding byte, normalise and return
00D86D  2               
00D86D  2               LAB_272B:
00D86D  2  4A                 LSR                     ; shift b1 - b0 ..
00D86E  2  6A                 ROR                     ; ..
00D86F  2  6A                 ROR                     ; .. to b7 - b6
00D870  2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
00D872  2  28                 PLP                     ; dump FAC2-FAC1 compare status
00D873  2  4C 7B D8           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
00D876  2               
00D876  2               ; do "Divide by zero" error
00D876  2               
00D876  2               LAB_2737:
00D876  2  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
00D878  2  4C 3F C1           JMP   LAB_XERR          ; do error #X, then warm start
00D87B  2               
00D87B  2               ; copy temp to FAC1 and normalise
00D87B  2               
00D87B  2               LAB_273C:
00D87B  2  A5 75              LDA   FACt_1            ; get temp mantissa1
00D87D  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D87F  2  A5 76              LDA   FACt_2            ; get temp mantissa2
00D881  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D883  2  A5 77              LDA   FACt_3            ; get temp mantissa3
00D885  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D887  2  4C 41 D6           JMP   LAB_24D5          ; normalise FAC1 and return
00D88A  2               
00D88A  2               ; unpack memory (AY) into FAC1
00D88A  2               
00D88A  2               LAB_UFAC:
00D88A  2  85 71              STA   ut1_pl            ; save pointer low byte
00D88C  2  84 72              STY   ut1_ph            ; save pointer high byte
00D88E  2  A0 03              LDY   #$03              ; 4 bytes to do
00D890  2  B1 71              LDA   (ut1_pl),Y        ; get last byte
00D892  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00D894  2  88                 DEY                     ; decrement index
00D895  2  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
00D897  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00D899  2  88                 DEY                     ; decrement index
00D89A  2  B1 71              LDA   (ut1_pl),Y        ; get second byte
00D89C  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00D89E  2  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
00D8A0  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D8A2  2  88                 DEY                     ; decrement index
00D8A3  2  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
00D8A5  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00D8A7  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00D8A9  2  60                 RTS
00D8AA  2               
00D8AA  2               ; pack FAC1 into Adatal
00D8AA  2               
00D8AA  2               LAB_276E:
00D8AA  2  A2 A4              LDX   #<Adatal          ; set pointer low byte
00D8AC  2               LAB_2770:
00D8AC  2  A0 00              LDY   #>Adatal          ; set pointer high byte
00D8AE  2  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
00D8B0  2               
00D8B0  2               ; pack FAC1 into (Lvarpl)
00D8B0  2               
00D8B0  2               LAB_PFAC:
00D8B0  2  A6 97              LDX   Lvarpl            ; get destination pointer low byte
00D8B2  2  A4 98              LDY   Lvarph            ; get destination pointer high byte
00D8B4  2               
00D8B4  2               ; pack FAC1 into (XY)
00D8B4  2               
00D8B4  2               LAB_2778:
00D8B4  2  20 E6 D8           JSR   LAB_27BA          ; round FAC1
00D8B7  2  86 71              STX   ut1_pl            ; save pointer low byte
00D8B9  2  84 72              STY   ut1_ph            ; save pointer high byte
00D8BB  2  A0 03              LDY   #$03              ; set index
00D8BD  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00D8BF  2  91 71              STA   (ut1_pl),Y        ; store in destination
00D8C1  2  88                 DEY                     ; decrement index
00D8C2  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00D8C4  2  91 71              STA   (ut1_pl),Y        ; store in destination
00D8C6  2  88                 DEY                     ; decrement index
00D8C7  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D8C9  2  09 7F              ORA   #$7F              ; set bits x111 1111
00D8CB  2  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
00D8CD  2  91 71              STA   (ut1_pl),Y        ; store in destination
00D8CF  2  88                 DEY                     ; decrement index
00D8D0  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D8D2  2  91 71              STA   (ut1_pl),Y        ; store in destination
00D8D4  2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
00D8D6  2  60                 RTS
00D8D7  2               
00D8D7  2               ; round and copy FAC1 to FAC2
00D8D7  2               
00D8D7  2               LAB_27AB:
00D8D7  2  20 E6 D8           JSR   LAB_27BA          ; round FAC1
00D8DA  2               
00D8DA  2               ; copy FAC1 to FAC2
00D8DA  2               
00D8DA  2               LAB_27AE:
00D8DA  2  A2 05              LDX   #$05              ; 5 bytes to copy
00D8DC  2               LAB_27B0:
00D8DC  2  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
00D8DE  2  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
00D8E0  2  CA                 DEX                     ; decrement count
00D8E1  2  D0 F9              BNE   LAB_27B0          ; loop if not all done
00D8E3  2               
00D8E3  2  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
00D8E5  2               LAB_27B9:
00D8E5  2  60                 RTS
00D8E6  2               
00D8E6  2               ; round FAC1
00D8E6  2               
00D8E6  2               LAB_27BA:
00D8E6  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D8E8  2  F0 FB              BEQ   LAB_27B9          ; exit if zero
00D8EA  2               
00D8EA  2  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
00D8EC  2  90 F7              BCC   LAB_27B9          ; exit if no overflow
00D8EE  2               
00D8EE  2               ; round FAC1 (no check)
00D8EE  2               
00D8EE  2               LAB_27C2:
00D8EE  2  20 C5 D6           JSR   LAB_2559          ; increment FAC1 mantissa
00D8F1  2  D0 F2              BNE   LAB_27B9          ; branch if no overflow
00D8F3  2               
00D8F3  2  4C 96 D6           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
00D8F6  2               
00D8F6  2               ; get FAC1 sign
00D8F6  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00D8F6  2               
00D8F6  2               LAB_27CA:
00D8F6  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D8F8  2  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
00D8FA  2               
00D8FA  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00D8FA  2               ; no = 0 check
00D8FA  2               
00D8FA  2               LAB_27CE:
00D8FA  2  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
00D8FC  2               
00D8FC  2               ; return A=FF,C=1/-ve A=01,C=0/+ve
00D8FC  2               ; no = 0 check, sign in A
00D8FC  2               
00D8FC  2               LAB_27D0:
00D8FC  2  2A                 ROL                     ; move sign bit to carry
00D8FD  2  A9 FF              LDA   #$FF              ; set byte for -ve result
00D8FF  2  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
00D901  2               
00D901  2  A9 01              LDA   #$01              ; else set byte for +ve result
00D903  2               LAB_27D7:
00D903  2  60                 RTS
00D904  2               
00D904  2               ; perform SGN()
00D904  2               
00D904  2               LAB_SGN:
00D904  2  20 F6 D8           JSR   LAB_27CA          ; get FAC1 sign
00D907  2                                             ; return A=$FF/-ve A=$01/+ve
00D907  2               ; save A as integer byte
00D907  2               
00D907  2               LAB_27DB:
00D907  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D909  2  A9 00              LDA   #$00              ; clear A
00D90B  2  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
00D90D  2  A2 88              LDX   #$88              ; set exponent
00D90F  2               
00D90F  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00D90F  2               
00D90F  2               LAB_27E3:
00D90F  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00D911  2  49 FF              EOR   #$FF              ; complement it
00D913  2  2A                 ROL                     ; sign bit into carry
00D914  2               
00D914  2               ; set exp=X, clearFAC1 mantissa3 and normalise
00D914  2               
00D914  2               LAB_STFA:
00D914  2  A9 00              LDA   #$00              ; clear A
00D916  2  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
00D918  2  86 AC              STX   FAC1_e            ; set FAC1 exponent
00D91A  2  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
00D91C  2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00D91E  2  4C 3C D6           JMP   LAB_24D0          ; do ABS and normalise FAC1
00D921  2               
00D921  2               ; perform ABS()
00D921  2               
00D921  2               LAB_ABS:
00D921  2  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
00D923  2  60                 RTS
00D924  2               
00D924  2               ; compare FAC1 with (AY)
00D924  2               ; returns A=$00 if FAC1 = (AY)
00D924  2               ; returns A=$01 if FAC1 > (AY)
00D924  2               ; returns A=$FF if FAC1 < (AY)
00D924  2               
00D924  2               LAB_27F8:
00D924  2  85 73              STA   ut2_pl            ; save pointer low byte
00D926  2               LAB_27FA:
00D926  2  84 74              STY   ut2_ph            ; save pointer high byte
00D928  2  A0 00              LDY   #$00              ; clear index
00D92A  2  B1 73              LDA   (ut2_pl),Y        ; get exponent
00D92C  2  C8                 INY                     ; increment index
00D92D  2  AA                 TAX                     ; copy (AY) exponent to X
00D92E  2  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
00D930  2                                             ; A=FF,C=1/-ve A=01,C=0/+ve
00D930  2               
00D930  2  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
00D932  2  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
00D934  2  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
00D936  2                                             ; A=01,C=0/+ve and return
00D936  2               
00D936  2  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
00D938  2  D0 1A              BNE   LAB_2828          ; branch if different
00D93A  2               
00D93A  2  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
00D93C  2  09 80              ORA   #$80              ; normalise top bit
00D93E  2  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
00D940  2  D0 12              BNE   LAB_2828          ; branch if different
00D942  2               
00D942  2  C8                 INY                     ; increment index
00D943  2  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
00D945  2  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
00D947  2  D0 0B              BNE   LAB_2828          ; branch if different
00D949  2               
00D949  2  C8                 INY                     ; increment index
00D94A  2  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
00D94C  2  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
00D94E  2  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
00D950  2  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
00D952  2  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
00D954  2               
00D954  2               ; gets here if number <> FAC1
00D954  2               
00D954  2               LAB_2828:
00D954  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D956  2  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
00D958  2               
00D958  2  49 FF              EOR   #$FF              ; else toggle FAC1 sign
00D95A  2               LAB_282E:
00D95A  2  4C FC D8           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
00D95D  2               
00D95D  2               ; convert FAC1 floating-to-fixed
00D95D  2               
00D95D  2               LAB_2831:
00D95D  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D95F  2  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
00D961  2               
00D961  2  38                 SEC                     ; set carry for subtract
00D962  2  E9 98              SBC   #$98              ; subtract maximum integer range exponent
00D964  2  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
00D966  2  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
00D968  2               
00D968  2                                             ; FAC1 was -ve
00D968  2  AA                 TAX                     ; copy subtracted exponent
00D969  2  A9 FF              LDA   #$FF              ; overflow for -ve number
00D96B  2  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
00D96D  2  20 A9 D6           JSR   LAB_253D          ; twos complement FAC1 mantissa
00D970  2  8A                 TXA                     ; restore subtracted exponent
00D971  2               LAB_2845:
00D971  2  A2 AC              LDX   #FAC1_e           ; set index to FAC1
00D973  2  C9 F9              CMP   #$F9              ; compare exponent result
00D975  2  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
00D977  2               
00D977  2  20 E7 D6           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
00D97A  2  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
00D97C  2               LAB_2850:
00D97C  2  60                 RTS
00D97D  2               
00D97D  2               ; shift FAC1 A times right
00D97D  2               
00D97D  2               LAB_2851:
00D97D  2  A8                 TAY                     ; copy shift count
00D97E  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D980  2  29 80              AND   #$80              ; mask sign bit only (x000 0000)
00D982  2  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
00D984  2  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
00D986  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00D988  2  20 FE D6           JSR   LAB_2592          ; shift FAC1 Y times right
00D98B  2  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
00D98D  2  60                 RTS
00D98E  2               
00D98E  2               ; perform INT()
00D98E  2               
00D98E  2               LAB_INT:
00D98E  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00D990  2  C9 98              CMP   #$98              ; compare with max int
00D992  2  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
00D994  2               
00D994  2  20 5D D9           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00D997  2  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
00D999  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00D99B  2  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
00D99D  2  49 80              EOR   #$80              ; toggle FAC1 sign
00D99F  2  2A                 ROL                     ; shift into carry
00D9A0  2  A9 98              LDA   #$98              ; set new exponent
00D9A2  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00D9A4  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00D9A6  2  85 5B              STA   Temp3             ; save for EXP() function
00D9A8  2  4C 3C D6           JMP   LAB_24D0          ; do ABS and normalise FAC1
00D9AB  2               
00D9AB  2               ; clear FAC1 and return
00D9AB  2               
00D9AB  2               LAB_287F:
00D9AB  2  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
00D9AD  2  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
00D9AF  2  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
00D9B1  2  A8                 TAY                     ; clear Y
00D9B2  2               LAB_2886:
00D9B2  2  60                 RTS
00D9B3  2               
00D9B3  2               ; get FAC1 from string
00D9B3  2               ; this routine now handles hex and binary values from strings
00D9B3  2               ; starting with "$" and "%" respectively
00D9B3  2               
00D9B3  2               LAB_2887:
00D9B3  2  A0 00              LDY   #$00              ; clear Y
00D9B5  2  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
00D9B7  2  A2 09              LDX   #$09              ; set index
00D9B9  2               LAB_288B:
00D9B9  2  94 A8              STY   numexp,X          ; clear byte
00D9BB  2  CA                 DEX                     ; decrement index
00D9BC  2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
00D9BE  2               
00D9BE  2  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
00D9C0  2               
00D9C0  2               ; get FAC1 from string .. first character wasn't numeric
00D9C0  2               
00D9C0  2  C9 2D              CMP   #'-'              ; else compare with "-"
00D9C2  2  D0 04              BNE   LAB_289A          ; branch if not "-"
00D9C4  2               
00D9C4  2  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
00D9C6  2  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
00D9C8  2               
00D9C8  2               ; get FAC1 from string .. first character wasn't numeric or -
00D9C8  2               
00D9C8  2               LAB_289A:
00D9C8  2  C9 2B              CMP   #'+'              ; else compare with "+"
00D9CA  2  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
00D9CC  2               
00D9CC  2               ; was "+" or "-" to start, so get next character
00D9CC  2               
00D9CC  2               LAB_289C:
00D9CC  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D9CF  2  90 6E              BCC   LAB_28FE          ; branch if numeric character
00D9D1  2               
00D9D1  2               ; code here for hex and binary numbers
00D9D1  2               
00D9D1  2               LAB_289D:
00D9D1  2  C9 24              CMP   #'$'              ; else compare with "$"
00D9D3  2  D0 03              BNE   LAB_NHEX          ; branch if not "$"
00D9D5  2               
00D9D5  2  4C 7D DE           JMP   LAB_CHEX          ; branch if "$"
00D9D8  2               
00D9D8  2               LAB_NHEX:
00D9D8  2  C9 25              CMP   #'%'              ; else compare with "%"
00D9DA  2  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
00D9DC  2               
00D9DC  2  4C AB DE           JMP   LAB_CBIN          ; branch if "%"
00D9DF  2               
00D9DF  2               LAB_289E:
00D9DF  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
00D9E2  2               LAB_28A1:
00D9E2  2  90 5B              BCC   LAB_28FE          ; branch if numeric character
00D9E4  2               
00D9E4  2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
00D9E4  2               
00D9E4  2               LAB_28A3:
00D9E4  2  C9 2E              CMP   #'.'              ; else compare with "."
00D9E6  2  F0 2E              BEQ   LAB_28D5          ; branch if "."
00D9E8  2               
00D9E8  2               ; get FAC1 from string .. character wasn't numeric, -, + or .
00D9E8  2               
00D9E8  2  C9 45              CMP   #'E'              ; else compare with "E"
00D9EA  2  D0 30              BNE   LAB_28DB          ; branch if not "E"
00D9EC  2               
00D9EC  2                                             ; was "E" so evaluate exponential part
00D9EC  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00D9EF  2  90 17              BCC   LAB_28C7          ; branch if numeric character
00D9F1  2               
00D9F1  2  C9 B7              CMP   #TK_MINUS         ; else compare with token for -
00D9F3  2  F0 0E              BEQ   LAB_28C2          ; branch if token for -
00D9F5  2               
00D9F5  2  C9 2D              CMP   #'-'              ; else compare with "-"
00D9F7  2  F0 0A              BEQ   LAB_28C2          ; branch if "-"
00D9F9  2               
00D9F9  2  C9 B6              CMP   #TK_PLUS          ; else compare with token for +
00D9FB  2  F0 08              BEQ   LAB_28C4          ; branch if token for +
00D9FD  2               
00D9FD  2  C9 2B              CMP   #'+'              ; else compare with "+"
00D9FF  2  F0 04              BEQ   LAB_28C4          ; branch if "+"
00DA01  2               
00DA01  2  D0 07              BNE   LAB_28C9          ; branch always
00DA03  2               
00DA03  2               LAB_28C2:
00DA03  2  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
00DA05  2               LAB_28C4:
00DA05  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00DA08  2               LAB_28C7:
00DA08  2  90 5B              BCC   LAB_2925          ; branch if numeric character
00DA0A  2               
00DA0A  2               LAB_28C9:
00DA0A  2  24 AB              BIT   expneg            ; test exponent -ve flag
00DA0C  2  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
00DA0E  2               
00DA0E  2                                             ; else do exponent = -exponent
00DA0E  2  A9 00              LDA   #$00              ; clear result
00DA10  2  38                 SEC                     ; set carry for subtract
00DA11  2  E5 A9              SBC   expcnt            ; subtract exponent byte
00DA13  2  4C 1E DA           JMP   LAB_28DD          ; go evaluate exponent
00DA16  2               
00DA16  2               LAB_28D5:
00DA16  2  66 AA              ROR   numdpf            ; set decimal point flag
00DA18  2  24 AA              BIT   numdpf            ; test decimal point flag
00DA1A  2  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
00DA1C  2               
00DA1C  2                                             ; evaluate exponent
00DA1C  2               LAB_28DB:
00DA1C  2  A5 A9              LDA   expcnt            ; get exponent count byte
00DA1E  2               LAB_28DD:
00DA1E  2  38                 SEC                     ; set carry for subtract
00DA1F  2  E5 A8              SBC   numexp            ; subtract numerator exponent
00DA21  2  85 A9              STA   expcnt            ; save exponent count byte
00DA23  2  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
00DA25  2               
00DA25  2  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
00DA27  2               
00DA27  2                                             ; else go do FAC1/10^(0-expcnt)
00DA27  2               LAB_28E6:
00DA27  2  20 FD D7           JSR   LAB_26B9          ; divide by 10
00DA2A  2  E6 A9              INC   expcnt            ; increment exponent count byte
00DA2C  2  D0 F9              BNE   LAB_28E6          ; loop until all done
00DA2E  2               
00DA2E  2  F0 07              BEQ   LAB_28F6          ; branch always
00DA30  2               
00DA30  2               LAB_28EF:
00DA30  2  20 E4 D7           JSR   LAB_269E          ; multiply by 10
00DA33  2  C6 A9              DEC   expcnt            ; decrement exponent count byte
00DA35  2  D0 F9              BNE   LAB_28EF          ; loop until all done
00DA37  2               
00DA37  2               LAB_28F6:
00DA37  2  A5 B1              LDA   negnum            ; get -ve flag
00DA39  2  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
00DA3B  2               
00DA3B  2  60                 RTS
00DA3C  2               
00DA3C  2               ; do - FAC1 and return
00DA3C  2               
00DA3C  2               LAB_28FB:
00DA3C  2  4C 01 DC           JMP   LAB_GTHAN         ; do - FAC1 and return
00DA3F  2               
00DA3F  2               ; do unsigned FAC1*10+number
00DA3F  2               
00DA3F  2               LAB_28FE:
00DA3F  2  48                 PHA                     ; save character
00DA40  2  24 AA              BIT   numdpf            ; test decimal point flag
00DA42  2  10 02              BPL   LAB_2905          ; skip exponent increment if not set
00DA44  2               
00DA44  2  E6 A8              INC   numexp            ; else increment number exponent
00DA46  2               LAB_2905:
00DA46  2  20 E4 D7           JSR   LAB_269E          ; multiply FAC1 by 10
00DA49  2  68                 PLA                     ; restore character
00DA4A  2  29 0F              AND   #$0F              ; convert to binary
00DA4C  2  20 52 DA           JSR   LAB_2912          ; evaluate new ASCII digit
00DA4F  2  4C DF D9           JMP   LAB_289E          ; go do next character
00DA52  2               
00DA52  2               ; evaluate new ASCII digit
00DA52  2               
00DA52  2               LAB_2912:
00DA52  2  48                 PHA                     ; save digit
00DA53  2  20 D7 D8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DA56  2  68                 PLA                     ; restore digit
00DA57  2  20 07 D9           JSR   LAB_27DB          ; save A as integer byte
00DA5A  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00DA5C  2  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
00DA5E  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00DA60  2  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
00DA62  2  4C CE D5           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
00DA65  2               
00DA65  2               ; evaluate next character of exponential part of number
00DA65  2               
00DA65  2               LAB_2925:
00DA65  2  A5 A9              LDA   expcnt            ; get exponent count byte
00DA67  2  C9 0A              CMP   #$0A              ; compare with 10 decimal
00DA69  2  90 09              BCC   LAB_2934          ; branch if less
00DA6B  2               
00DA6B  2  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
00DA6D  2  24 AB              BIT   expneg            ; test exponent -ve flag
00DA6F  2  30 0E              BMI   LAB_2942          ; branch if -ve
00DA71  2               
00DA71  2  4C D0 D6           JMP   LAB_2564          ; else do overflow error
00DA74  2               
00DA74  2               LAB_2934:
00DA74  2  0A                 ASL                     ; * 2
00DA75  2  0A                 ASL                     ; * 4
00DA76  2  65 A9              ADC   expcnt            ; * 5
00DA78  2  0A                 ASL                     ; * 10
00DA79  2  A0 00              LDY   #$00              ; set index
00DA7B  2  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
00DA7D  2  E9 2F              SBC   #'0'-1            ; convert character to binary
00DA7F  2               LAB_2942:
00DA7F  2  85 A9              STA   expcnt            ; save exponent count byte
00DA81  2  4C 05 DA           JMP   LAB_28C4          ; go get next character
00DA84  2               
00DA84  2               ; print " in line [LINE #]"
00DA84  2               
00DA84  2               LAB_2953:
00DA84  2  A9 FC              LDA   #<LAB_LMSG        ; point to " in line " message low byte
00DA86  2  A0 E7              LDY   #>LAB_LMSG        ; point to " in line " message high byte
00DA88  2  20 D4 C8           JSR   LAB_18C3          ; print null terminated string from memory
00DA8B  2               
00DA8B  2                                             ; print Basic line #
00DA8B  2  A5 88              LDA   Clineh            ; get current line high byte
00DA8D  2  A6 87              LDX   Clinel            ; get current line low byte
00DA8F  2               
00DA8F  2               ; print XA as unsigned integer
00DA8F  2               
00DA8F  2               LAB_295E:
00DA8F  2  85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
00DA91  2  86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
00DA93  2  A2 90              LDX   #$90              ; set exponent to 16d bits
00DA95  2  38                 SEC                     ; set integer is +ve flag
00DA96  2  20 14 D9           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
00DA99  2  A0 00              LDY   #$00              ; clear index
00DA9B  2  98                 TYA                     ; clear A
00DA9C  2  20 AF DA           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
00DA9F  2  4C D4 C8           JMP   LAB_18C3          ; print null terminated string from memory and return
00DAA2  2               
00DAA2  2               ; convert FAC1 to ASCII string result in (AY)
00DAA2  2               ; not any more, moved scratchpad to page 0
00DAA2  2               
00DAA2  2               LAB_296E:
00DAA2  2  A0 01              LDY   #$01              ; set index = 1
00DAA4  2  A9 20              LDA   #$20              ; character = " " (assume +ve)
00DAA6  2  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
00DAA8  2  10 02              BPL   LAB_2978          ; branch if +ve
00DAAA  2               
00DAAA  2  A9 2D              LDA   #$2D              ; else character = "-"
00DAAC  2               LAB_2978:
00DAAC  2  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
00DAAF  2               LAB_297B:
00DAAF  2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00DAB1  2  84 BA              STY   Sendl             ; save index
00DAB3  2  C8                 INY                     ; increment index
00DAB4  2  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
00DAB6  2  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
00DAB8  2               
00DAB8  2                                             ; exponent was $00 so FAC1 is 0
00DAB8  2  A9 30              LDA   #'0'              ; set character = "0"
00DABA  2  4C BB DB           JMP   LAB_2A89          ; save last character, [EOT] and exit
00DABD  2               
00DABD  2                                             ; FAC1 is some non zero value
00DABD  2               LAB_2989:
00DABD  2  A9 00              LDA   #$00              ; clear (number exponent count)
00DABF  2  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
00DAC1  2               
00DAC1  2  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
00DAC3  2               
00DAC3  2                                             ; FAC1<1
00DAC3  2  A9 90              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
00DAC5  2  A0 E1              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
00DAC7  2  20 46 D7           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DACA  2  A9 FA              LDA   #$FA              ; set number exponent count (-6)
00DACC  2               LAB_299A:
00DACC  2  85 A8              STA   numexp            ; save number exponent count
00DACE  2               LAB_299C:
00DACE  2  A9 8C              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
00DAD0  2  A0 E1              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
00DAD2  2  20 24 D9           JSR   LAB_27F8          ; compare FAC1 with (AY)
00DAD5  2  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
00DAD7  2               
00DAD7  2  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
00DAD9  2               
00DAD9  2                                             ; FAC1 < (AY)
00DAD9  2               LAB_29A7:
00DAD9  2  A9 88              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
00DADB  2  A0 E1              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
00DADD  2  20 24 D9           JSR   LAB_27F8          ; compare FAC1 with (AY)
00DAE0  2  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
00DAE2  2               
00DAE2  2  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
00DAE4  2               
00DAE4  2                                             ; FAC1 <= (AY)
00DAE4  2               LAB_29B2:
00DAE4  2  20 E4 D7           JSR   LAB_269E          ; multiply by 10
00DAE7  2  C6 A8              DEC   numexp            ; decrement number exponent count
00DAE9  2  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
00DAEB  2               
00DAEB  2               LAB_29B9:
00DAEB  2  20 FD D7           JSR   LAB_26B9          ; divide by 10
00DAEE  2  E6 A8              INC   numexp            ; increment number exponent count
00DAF0  2  D0 DC              BNE   LAB_299C          ; go test again (branch always)
00DAF2  2               
00DAF2  2               ; now we have just the digits to do
00DAF2  2               
00DAF2  2               LAB_29C0:
00DAF2  2  20 C7 D5           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
00DAF5  2               LAB_29C3:
00DAF5  2  20 5D D9           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
00DAF8  2  A2 01              LDX   #$01              ; set default digits before dp = 1
00DAFA  2  A5 A8              LDA   numexp            ; get number exponent count
00DAFC  2  18                 CLC                     ; clear carry for add
00DAFD  2  69 07              ADC   #$07              ; up to 6 digits before point
00DAFF  2  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
00DB01  2               
00DB01  2  C9 08              CMP   #$08              ; A>=8 if n>=1E6
00DB03  2  B0 06              BCS   LAB_29D9          ; branch if >= $08
00DB05  2               
00DB05  2                                             ; carry is clear
00DB05  2  69 FF              ADC   #$FF              ; take 1 from digit count
00DB07  2  AA                 TAX                     ; copy to A
00DB08  2  A9 02              LDA   #$02              ;.set exponent adjust
00DB0A  2               LAB_29D8:
00DB0A  2  38                 SEC                     ; set carry for subtract
00DB0B  2               LAB_29D9:
00DB0B  2  E9 02              SBC   #$02              ; -2
00DB0D  2  85 A9              STA   expcnt            ;.save exponent adjust
00DB0F  2  86 A8              STX   numexp            ; save digits before dp count
00DB11  2  8A                 TXA                     ; copy to A
00DB12  2  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
00DB14  2               
00DB14  2  10 13              BPL   LAB_29F7          ; branch if digits before dp
00DB16  2               
00DB16  2               LAB_29E4:
00DB16  2  A4 BA              LDY   Sendl             ; get output string index
00DB18  2  A9 2E              LDA   #$2E              ; character "."
00DB1A  2  C8                 INY                     ; increment index
00DB1B  2  99 EF 00           STA   Decss,Y           ; save to output string
00DB1E  2  8A                 TXA                     ;.
00DB1F  2  F0 06              BEQ   LAB_29F5          ;.
00DB21  2               
00DB21  2  A9 30              LDA   #'0'              ; character "0"
00DB23  2  C8                 INY                     ; increment index
00DB24  2  99 EF 00           STA   Decss,Y           ; save to output string
00DB27  2               LAB_29F5:
00DB27  2  84 BA              STY   Sendl             ; save output string index
00DB29  2               LAB_29F7:
00DB29  2  A0 00              LDY   #$00              ; clear index (point to 100,000)
00DB2B  2  A2 80              LDX   #$80              ;
00DB2D  2               LAB_29FB:
00DB2D  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00DB2F  2  18                 CLC                     ; clear carry for add
00DB30  2  79 06 E2           ADC   LAB_2A9C,Y        ; add -ve LSB
00DB33  2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00DB35  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00DB37  2  79 05 E2           ADC   LAB_2A9B,Y        ; add -ve NMSB
00DB3A  2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
00DB3C  2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
00DB3E  2  79 04 E2           ADC   LAB_2A9A,Y        ; add -ve MSB
00DB41  2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00DB43  2  E8                 INX                     ;
00DB44  2  B0 04              BCS   LAB_2A18          ;
00DB46  2               
00DB46  2  10 E5              BPL   LAB_29FB          ; not -ve so try again
00DB48  2               
00DB48  2  30 02              BMI   LAB_2A1A          ;
00DB4A  2               
00DB4A  2               LAB_2A18:
00DB4A  2  30 E1              BMI   LAB_29FB          ;
00DB4C  2               
00DB4C  2               LAB_2A1A:
00DB4C  2  8A                 TXA                     ;
00DB4D  2  90 04              BCC   LAB_2A21          ;
00DB4F  2               
00DB4F  2  49 FF              EOR   #$FF              ;
00DB51  2  69 0A              ADC   #$0A              ;
00DB53  2               LAB_2A21:
00DB53  2  69 2F              ADC   #'0'-1            ; add "0"-1 to result
00DB55  2  C8                 INY                     ; increment index ..
00DB56  2  C8                 INY                     ; .. to next less ..
00DB57  2  C8                 INY                     ; .. power of ten
00DB58  2  84 95              STY   Cvaral            ; save as current var address low byte
00DB5A  2  A4 BA              LDY   Sendl             ; get output string index
00DB5C  2  C8                 INY                     ; increment output string index
00DB5D  2  AA                 TAX                     ; copy character to X
00DB5E  2  29 7F              AND   #$7F              ; mask out top bit
00DB60  2  99 EF 00           STA   Decss,Y           ; save to output string
00DB63  2  C6 A8              DEC   numexp            ; decrement # of characters before the dp
00DB65  2  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
00DB67  2               
00DB67  2                                             ; else output the point
00DB67  2  A9 2E              LDA   #$2E              ; character "."
00DB69  2  C8                 INY                     ; increment output string index
00DB6A  2  99 EF 00           STA   Decss,Y           ; save to output string
00DB6D  2               LAB_2A3B:
00DB6D  2  84 BA              STY   Sendl             ; save output string index
00DB6F  2  A4 95              LDY   Cvaral            ; get current var address low byte
00DB71  2  8A                 TXA                     ; get character back
00DB72  2  49 FF              EOR   #$FF              ;
00DB74  2  29 80              AND   #$80              ;
00DB76  2  AA                 TAX                     ;
00DB77  2  C0 12              CPY   #$12              ; compare index with max
00DB79  2  D0 B2              BNE   LAB_29FB          ; loop if not max
00DB7B  2               
00DB7B  2                                             ; now remove trailing zeroes
00DB7B  2  A4 BA              LDY   Sendl             ; get output string index
00DB7D  2               LAB_2A4B:
00DB7D  2  B9 EF 00           LDA   Decss,Y           ; get character from output string
00DB80  2  88                 DEY                     ; decrement output string index
00DB81  2  C9 30              CMP   #'0'              ; compare with "0"
00DB83  2  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
00DB85  2               
00DB85  2  C9 2E              CMP   #'.'              ; compare with "."
00DB87  2  F0 01              BEQ   LAB_2A58          ; branch if was dp
00DB89  2               
00DB89  2                                             ; restore last character
00DB89  2  C8                 INY                     ; increment output string index
00DB8A  2               LAB_2A58:
00DB8A  2  A9 2B              LDA   #$2B              ; character "+"
00DB8C  2  A6 A9              LDX   expcnt            ; get exponent count
00DB8E  2  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
00DB90  2               
00DB90  2                                             ; exponent isn't zero so write exponent
00DB90  2  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
00DB92  2               
00DB92  2  A9 00              LDA   #$00              ; clear A
00DB94  2  38                 SEC                     ; set carry for subtract
00DB95  2  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
00DB97  2  AA                 TAX                     ; copy exponent count to X
00DB98  2  A9 2D              LDA   #'-'              ; character "-"
00DB9A  2               LAB_2A68:
00DB9A  2  99 F1 00           STA   Decss+2,Y         ; save to output string
00DB9D  2  A9 45              LDA   #$45              ; character "E"
00DB9F  2  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
00DBA2  2  8A                 TXA                     ; get exponent count back
00DBA3  2  A2 2F              LDX   #'0'-1            ; one less than "0" character
00DBA5  2  38                 SEC                     ; set carry for subtract
00DBA6  2               LAB_2A74:
00DBA6  2  E8                 INX                     ; increment 10's character
00DBA7  2  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
00DBA9  2  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
00DBAB  2               
00DBAB  2  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
00DBAD  2  99 F3 00           STA   Decss+4,Y         ; save to output string
00DBB0  2  8A                 TXA                     ; copy 10's character
00DBB1  2  99 F2 00           STA   Decss+3,Y         ; save to output string
00DBB4  2  A9 00              LDA   #$00              ; set null terminator
00DBB6  2  99 F4 00           STA   Decss+5,Y         ; save to output string
00DBB9  2  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
00DBBB  2               
00DBBB  2                                             ; save last character, [EOT] and exit
00DBBB  2               LAB_2A89:
00DBBB  2  99 EF 00           STA   Decss,Y           ; save last character to output string
00DBBE  2               
00DBBE  2                                             ; set null terminator and exit
00DBBE  2               LAB_2A8C:
00DBBE  2  A9 00              LDA   #$00              ; set null terminator
00DBC0  2  99 F0 00           STA   Decss+1,Y         ; save after last character
00DBC3  2               
00DBC3  2                                             ; set string pointer (AY) and exit
00DBC3  2               LAB_2A91:
00DBC3  2  A9 F0              LDA   #<Decssp1         ; set result string low pointer
00DBC5  2  A0 00              LDY   #>Decssp1         ; set result string high pointer
00DBC7  2  60                 RTS
00DBC8  2               
00DBC8  2               ; perform power function
00DBC8  2               
00DBC8  2               LAB_POWER:
00DBC8  2  F0 42              BEQ   LAB_EXP           ; go do  EXP()
00DBCA  2               
00DBCA  2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
00DBCC  2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
00DBCE  2               
00DBCE  2  4C 5F D6           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
00DBD1  2               
00DBD1  2               LAB_2ABF:
00DBD1  2  A2 9C              LDX   #<func_l          ; set destination pointer low byte
00DBD3  2  A0 00              LDY   #>func_l          ; set destination pointer high byte
00DBD5  2  20 B4 D8           JSR   LAB_2778          ; pack FAC1 into (XY)
00DBD8  2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
00DBDA  2  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
00DBDC  2               
00DBDC  2                                             ; else FAC2 is -ve and can only be raised to an
00DBDC  2                                             ; integer power which gives an x +j0 result
00DBDC  2  20 8E D9           JSR   LAB_INT           ; perform INT
00DBDF  2  A9 9C              LDA   #<func_l          ; set source pointer low byte
00DBE1  2  A0 00              LDY   #>func_l          ; set source pointer high byte
00DBE3  2  20 24 D9           JSR   LAB_27F8          ; compare FAC1 with (AY)
00DBE6  2  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
00DBE8  2                                             ; this will leave FAC1 -ve and cause a Function Call
00DBE8  2                                             ; error when LOG() is called
00DBE8  2               
00DBE8  2  98                 TYA                     ; clear sign b7
00DBE9  2  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
00DBEB  2                                             ; for possible later negation, b0
00DBEB  2               LAB_2AD9:
00DBEB  2  20 D2 D5           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
00DBEE  2  98                 TYA                     ; copy sign back ..
00DBEF  2  48                 PHA                     ; .. and save it
00DBF0  2  20 08 D7           JSR   LAB_LOG           ; do LOG(n)
00DBF3  2  A9 9C              LDA   #<garb_l          ; set pointer low byte
00DBF5  2  A0 00              LDY   #>garb_l          ; set pointer high byte
00DBF7  2  20 46 D7           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
00DBFA  2  20 0C DC           JSR   LAB_EXP           ; go do EXP(n)
00DBFD  2  68                 PLA                     ; pull sign from stack
00DBFE  2  4A                 LSR                     ; b0 is to be tested, shift to Cb
00DBFF  2  90 0A              BCC   LAB_2AF9          ; if no bit then exit
00DC01  2               
00DC01  2                                             ; Perform negation
00DC01  2               ; do - FAC1
00DC01  2               
00DC01  2               LAB_GTHAN:
00DC01  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DC03  2  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
00DC05  2               
00DC05  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DC07  2  49 FF              EOR   #$FF              ; complement it
00DC09  2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00DC0B  2               LAB_2AF9:
00DC0B  2  60                 RTS
00DC0C  2               
00DC0C  2               ; perform EXP()   (x^e)
00DC0C  2               
00DC0C  2               LAB_EXP:
00DC0C  2  A9 94              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
00DC0E  2  A0 E1              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
00DC10  2  20 46 D7           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DC13  2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00DC15  2  69 50              ADC   #$50              ; +$50/$100
00DC17  2  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
00DC19  2               
00DC19  2  20 EE D8           JSR   LAB_27C2          ; round FAC1 (no check)
00DC1C  2               LAB_2B2B:
00DC1C  2  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
00DC1E  2  20 DA D8           JSR   LAB_27AE          ; copy FAC1 to FAC2
00DC21  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DC23  2  C9 88              CMP   #$88              ; compare with EXP limit (256d)
00DC25  2  90 03              BCC   LAB_2B39          ; branch if less
00DC27  2               
00DC27  2               LAB_2B36:
00DC27  2  20 DB D7           JSR   LAB_2690          ; handle overflow and underflow
00DC2A  2               LAB_2B39:
00DC2A  2  20 8E D9           JSR   LAB_INT           ; perform INT
00DC2D  2  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
00DC2F  2  18                 CLC                     ; clear carry for add
00DC30  2  69 81              ADC   #$81              ; normalise +1
00DC32  2  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
00DC34  2               
00DC34  2  38                 SEC                     ; set carry for subtract
00DC35  2  E9 01              SBC   #$01              ; now correct for exponent
00DC37  2  48                 PHA                     ; save FAC2 exponent
00DC38  2               
00DC38  2                                             ; swap FAC1 and FAC2
00DC38  2  A2 04              LDX   #$04              ; 4 bytes to do
00DC3A  2               LAB_2B49:
00DC3A  2  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
00DC3C  2  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
00DC3E  2  95 AC              STA   FAC1_e,X          ; save FAC1,X
00DC40  2  94 B3              STY   FAC2_e,X          ; save FAC2,X
00DC42  2  CA                 DEX                     ; decrement count/index
00DC43  2  10 F5              BPL   LAB_2B49          ; loop if not all done
00DC45  2               
00DC45  2  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
00DC47  2  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
00DC49  2  20 B3 D5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
00DC4C  2  20 01 DC           JSR   LAB_GTHAN         ; do - FAC1
00DC4F  2  A9 98              LDA   #<LAB_2AFE        ; set counter pointer low byte
00DC51  2  A0 E1              LDY   #>LAB_2AFE        ; set counter pointer high byte
00DC53  2  20 74 DC           JSR   LAB_2B84          ; go do series evaluation
00DC56  2  A9 00              LDA   #$00              ; clear A
00DC58  2  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00DC5A  2  68                 PLA                     ;.get saved FAC2 exponent
00DC5B  2  4C C0 D7           JMP   LAB_2675          ; test and adjust accumulators and return
00DC5E  2               
00DC5E  2               ; ^2 then series evaluation
00DC5E  2               
00DC5E  2               LAB_2B6E:
00DC5E  2  85 BA              STA   Cptrl             ; save count pointer low byte
00DC60  2  84 BB              STY   Cptrh             ; save count pointer high byte
00DC62  2  20 AA D8           JSR   LAB_276E          ; pack FAC1 into Adatal
00DC65  2  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
00DC67  2  20 46 D7           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DC6A  2  20 78 DC           JSR   LAB_2B88          ; go do series evaluation
00DC6D  2  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
00DC6F  2  A0 00              LDY   #>Adatal          ; pointer to original # high byte
00DC71  2  4C 46 D7           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
00DC74  2               
00DC74  2               ; series evaluation
00DC74  2               
00DC74  2               LAB_2B84:
00DC74  2  85 BA              STA   Cptrl             ; save count pointer low byte
00DC76  2  84 BB              STY   Cptrh             ; save count pointer high byte
00DC78  2               LAB_2B88:
00DC78  2  A2 A8              LDX   #<numexp          ; set pointer low byte
00DC7A  2  20 AC D8           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
00DC7D  2  B1 BA              LDA   (Cptrl),Y         ; get constants count
00DC7F  2  85 B1              STA   numcon            ; save constants count
00DC81  2  A4 BA              LDY   Cptrl             ; get count pointer low byte
00DC83  2  C8                 INY                     ; increment it (now constants pointer)
00DC84  2  98                 TYA                     ; copy it
00DC85  2  D0 02              BNE   LAB_2B97          ; skip next if no overflow
00DC87  2               
00DC87  2  E6 BB              INC   Cptrh             ; else increment high byte
00DC89  2               LAB_2B97:
00DC89  2  85 BA              STA   Cptrl             ; save low byte
00DC8B  2  A4 BB              LDY   Cptrh             ; get high byte
00DC8D  2               LAB_2B9B:
00DC8D  2  20 46 D7           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
00DC90  2  A5 BA              LDA   Cptrl             ; get constants pointer low byte
00DC92  2  A4 BB              LDY   Cptrh             ; get constants pointer high byte
00DC94  2  18                 CLC                     ; clear carry for add
00DC95  2  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
00DC97  2  90 01              BCC   LAB_2BA8          ; skip next if no overflow
00DC99  2               
00DC99  2  C8                 INY                     ; increment high byte
00DC9A  2               LAB_2BA8:
00DC9A  2  85 BA              STA   Cptrl             ; save pointer low byte
00DC9C  2  84 BB              STY   Cptrh             ; save pointer high byte
00DC9E  2  20 CB D5           JSR   LAB_246C          ; add (AY) to FAC1
00DCA1  2  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
00DCA3  2  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
00DCA5  2  C6 B1              DEC   numcon            ; decrement constants count
00DCA7  2  D0 E4              BNE   LAB_2B9B          ; loop until all done
00DCA9  2               
00DCA9  2  60                 RTS
00DCAA  2               
00DCAA  2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
00DCAA  2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
00DCAA  2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
00DCAA  2               
00DCAA  2               ; Entropy = 7.997442 bits per byte
00DCAA  2               ; Optimum compression would reduce these 65536 bytes by 0 percent
00DCAA  2               
00DCAA  2               ; Chi square distribution for 65536 samples is 232.01, and
00DCAA  2               ; randomly would exceed this value 75.00 percent of the time
00DCAA  2               
00DCAA  2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00DCAA  2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00DCAA  2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00DCAA  2               
00DCAA  2               LAB_RND:
00DCAA  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DCAC  2  F0 07              BEQ   NextPRN           ; do next random # if zero
00DCAE  2               
00DCAE  2                                             ; else get seed into random number store
00DCAE  2  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
00DCB0  2  A0 00              LDY   #$00              ; set PRNG pointer high byte
00DCB2  2  20 B4 D8           JSR   LAB_2778          ; pack FAC1 into (XY)
00DCB5  2               NextPRN:
00DCB5  2  A2 AF              LDX   #$AF              ; set EOR byte
00DCB7  2  A0 13              LDY   #$13              ; do this nineteen times
00DCB9  2               LoopPRN:
00DCB9  2  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
00DCBB  2  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
00DCBD  2  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
00DCBF  2  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
00DCC1  2  90 05              BCC   Ninc1             ; branch if bit 32 clear
00DCC3  2               
00DCC3  2  8A                 TXA                     ; set EOR byte
00DCC4  2  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
00DCC6  2  85 D9              STA   Rbyte1            ; save new PRNG extra byte
00DCC8  2               Ninc1:
00DCC8  2  88                 DEY                     ; decrement loop count
00DCC9  2  D0 EE              BNE   LoopPRN           ; loop if not all done
00DCCB  2               
00DCCB  2  A2 02              LDX   #$02              ; three bytes to copy
00DCCD  2               CopyPRNG:
00DCCD  2  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
00DCCF  2  95 AD              STA   FAC1_1,X          ; save FAC1 byte
00DCD1  2  CA                 DEX
00DCD2  2  10 F9              BPL   CopyPRNG          ; loop if not complete
00DCD4  2               
00DCD4  2  A9 80              LDA   #$80              ; set the exponent
00DCD6  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DCD8  2               
00DCD8  2  0A                 ASL                     ; clear A
00DCD9  2  85 B0              STA   FAC1_s            ; save FAC1 sign
00DCDB  2               
00DCDB  2  4C 41 D6           JMP   LAB_24D5          ; normalise FAC1 and return
00DCDE  2               
00DCDE  2               ; perform COS()
00DCDE  2               
00DCDE  2               LAB_COS:
00DCDE  2  A9 B5              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
00DCE0  2  A0 E1              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
00DCE2  2  20 CB D5           JSR   LAB_246C          ; add (AY) to FAC1
00DCE5  2               
00DCE5  2               ; perform SIN()
00DCE5  2               
00DCE5  2               LAB_SIN:
00DCE5  2  20 D7 D8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DCE8  2  A9 CA              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00DCEA  2  A0 E1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00DCEC  2  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
00DCEE  2  20 06 D8           JSR   LAB_26C2          ; divide by (AY) (X=sign)
00DCF1  2  20 D7 D8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00DCF4  2  20 8E D9           JSR   LAB_INT           ; perform INT
00DCF7  2  A9 00              LDA   #$00              ; clear byte
00DCF9  2  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
00DCFB  2  20 B3 D5           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
00DCFE  2  A9 FC              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
00DD00  2  A0 E1              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
00DD02  2  20 B0 D5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
00DD05  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DD07  2  48                 PHA                     ; save FAC1 sign
00DD08  2  10 0D              BPL   LAB_2C35          ; branch if +ve
00DD0A  2               
00DD0A  2                                             ; FAC1 sign was -ve
00DD0A  2  20 C7 D5           JSR   LAB_244E          ; add 0.5 to FAC1
00DD0D  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DD0F  2  30 09              BMI   LAB_2C38          ; branch if -ve
00DD11  2               
00DD11  2  A5 63              LDA   Cflag             ; get comparison evaluation flag
00DD13  2  49 FF              EOR   #$FF              ; toggle flag
00DD15  2  85 63              STA   Cflag             ; save comparison evaluation flag
00DD17  2               LAB_2C35:
00DD17  2  20 01 DC           JSR   LAB_GTHAN         ; do - FAC1
00DD1A  2               LAB_2C38:
00DD1A  2  A9 FC              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
00DD1C  2  A0 E1              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
00DD1E  2  20 CB D5           JSR   LAB_246C          ; add (AY) to FAC1
00DD21  2  68                 PLA                     ; restore FAC1 sign
00DD22  2  10 03              BPL   LAB_2C45          ; branch if was +ve
00DD24  2               
00DD24  2                                             ; else correct FAC1
00DD24  2  20 01 DC           JSR   LAB_GTHAN         ; do - FAC1
00DD27  2               LAB_2C45:
00DD27  2  A9 B9              LDA   #<LAB_2C84        ; set pointer low byte to counter
00DD29  2  A0 E1              LDY   #>LAB_2C84        ; set pointer high byte to counter
00DD2B  2  4C 5E DC           JMP   LAB_2B6E          ; ^2 then series evaluation and return
00DD2E  2               
00DD2E  2               ; perform TAN()
00DD2E  2               
00DD2E  2               LAB_TAN:
00DD2E  2  20 AA D8           JSR   LAB_276E          ; pack FAC1 into Adatal
00DD31  2  A9 00              LDA   #$00              ; clear byte
00DD33  2  85 63              STA   Cflag             ; clear comparison evaluation flag
00DD35  2  20 E5 DC           JSR   LAB_SIN           ; go do SIN(n)
00DD38  2  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
00DD3A  2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
00DD3C  2  20 B4 D8           JSR   LAB_2778          ; pack FAC1 into (XY)
00DD3F  2  A9 A4              LDA   #<Adatal          ; set n pointer low addr
00DD41  2  A0 00              LDY   #>Adatal          ; set n pointer high addr
00DD43  2  20 8A D8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00DD46  2  A9 00              LDA   #$00              ; clear byte
00DD48  2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00DD4A  2  A5 63              LDA   Cflag             ; get comparison evaluation flag
00DD4C  2  20 56 DD           JSR   LAB_2C74          ; save flag and go do series evaluation
00DD4F  2               
00DD4F  2  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
00DD51  2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
00DD53  2  4C 0E D8           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
00DD56  2               
00DD56  2               LAB_2C74:
00DD56  2  48                 PHA                     ; save comparison evaluation flag
00DD57  2  4C 17 DD           JMP   LAB_2C35          ; go do series evaluation
00DD5A  2               
00DD5A  2               ; perform USR()
00DD5A  2               
00DD5A  2               LAB_USR:
00DD5A  2  20 0A 00           JSR   Usrjmp            ; call user code
00DD5D  2  4C EF CB           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
00DD60  2               
00DD60  2               ; perform ATN()
00DD60  2               
00DD60  2               LAB_ATN:
00DD60  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00DD62  2  48                 PHA                     ; save sign
00DD63  2  10 03              BPL   LAB_2CA1          ; branch if +ve
00DD65  2               
00DD65  2  20 01 DC           JSR   LAB_GTHAN         ; else do - FAC1
00DD68  2               LAB_2CA1:
00DD68  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DD6A  2  48                 PHA                     ; push exponent
00DD6B  2  C9 81              CMP   #$81              ; compare with 1
00DD6D  2  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
00DD6F  2               
00DD6F  2  A9 EF              LDA   #<LAB_259C        ; set 1 pointer low byte
00DD71  2  A0 E1              LDY   #>LAB_259C        ; set 1 pointer high byte
00DD73  2  20 0E D8           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
00DD76  2               LAB_2CAF:
00DD76  2  A9 CE              LDA   #<LAB_2CC9        ; set pointer low byte to counter
00DD78  2  A0 E1              LDY   #>LAB_2CC9        ; set pointer high byte to counter
00DD7A  2  20 5E DC           JSR   LAB_2B6E          ; ^2 then series evaluation
00DD7D  2  68                 PLA                     ; restore old FAC1 exponent
00DD7E  2  C9 81              CMP   #$81              ; compare with 1
00DD80  2  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
00DD82  2               
00DD82  2  A9 B5              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
00DD84  2  A0 E1              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
00DD86  2  20 B0 D5           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
00DD89  2               LAB_2CC2:
00DD89  2  68                 PLA                     ; restore FAC1 sign
00DD8A  2  10 16              BPL   LAB_2D04          ; exit if was +ve
00DD8C  2               
00DD8C  2  4C 01 DC           JMP   LAB_GTHAN         ; else do - FAC1 and return
00DD8F  2               
00DD8F  2               ; perform BITSET
00DD8F  2               
00DD8F  2               LAB_BITSET:
00DD8F  2  20 E5 D4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00DD92  2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
00DD94  2  B0 20              BCS   FCError           ; branch if > 7
00DD96  2               
00DD96  2  A9 00              LDA   #$00              ; clear A
00DD98  2  38                 SEC                     ; set the carry
00DD99  2               S_Bits:
00DD99  2  2A                 ROL                     ; shift bit
00DD9A  2  CA                 DEX                     ; decrement bit number
00DD9B  2  10 FC              BPL   S_Bits            ; loop if still +ve
00DD9D  2               
00DD9D  2  E8                 INX                     ; make X = $00
00DD9E  2  01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
00DDA0  2  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
00DDA2  2               LAB_2D04:
00DDA2  2  60                 RTS
00DDA3  2               
00DDA3  2               ; perform BITCLR
00DDA3  2               
00DDA3  2               LAB_BITCLR:
00DDA3  2  20 E5 D4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00DDA6  2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
00DDA8  2  B0 0C              BCS   FCError           ; branch if > 7
00DDAA  2               
00DDAA  2  A9 FF              LDA   #$FF              ; set A
00DDAC  2               S_Bitc:
00DDAC  2  2A                 ROL                     ; shift bit
00DDAD  2  CA                 DEX                     ; decrement bit number
00DDAE  2  10 FC              BPL   S_Bitc            ; loop if still +ve
00DDB0  2               
00DDB0  2  E8                 INX                     ; make X = $00
00DDB1  2  21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
00DDB3  2  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
00DDB5  2  60                 RTS
00DDB6  2               
00DDB6  2               FCError:
00DDB6  2  4C 37 CF           JMP   LAB_FCER          ; do function call error then warm start
00DDB9  2               
00DDB9  2               ; perform BITTST()
00DDB9  2               
00DDB9  2               LAB_BTST:
00DDB9  2  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
00DDBC  2  20 E5 D4           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00DDBF  2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
00DDC1  2  B0 F3              BCS   FCError           ; branch if > 7
00DDC3  2               
00DDC3  2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00DDC6  2  C9 29              CMP   #')'              ; is next character ")"
00DDC8  2  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
00DDCA  2               
00DDCA  2  4C 02 CC           JMP   LAB_SNER          ; do syntax error then warm start
00DDCD  2               
00DDCD  2               TST_OK:
00DDCD  2  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
00DDD0  2  A9 00              LDA   #$00              ; clear A
00DDD2  2  38                 SEC                     ; set the carry
00DDD3  2               T_Bits:
00DDD3  2  2A                 ROL                     ; shift bit
00DDD4  2  CA                 DEX                     ; decrement bit number
00DDD5  2  10 FC              BPL   T_Bits            ; loop if still +ve
00DDD7  2               
00DDD7  2  E8                 INX                     ; make X = $00
00DDD8  2  21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
00DDDA  2  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
00DDDC  2               
00DDDC  2  A9 FF              LDA   #$FF              ; set for -1 result
00DDDE  2               LAB_NOTT:
00DDDE  2  4C 07 D9           JMP   LAB_27DB          ; go do SGN tail
00DDE1  2               
00DDE1  2               ; perform BIN$()
00DDE1  2               
00DDE1  2               LAB_BINS:
00DDE1  2  E0 19              CPX   #$19              ; max + 1
00DDE3  2  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
00DDE5  2               
00DDE5  2  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
00DDE7  2  A9 18              LDA   #$18              ; need A byte long space
00DDE9  2  20 48 D1           JSR   LAB_MSSP          ; make string space A bytes long
00DDEC  2  A0 17              LDY   #$17              ; set index
00DDEE  2  A2 18              LDX   #$18              ; character count
00DDF0  2               NextB1:
00DDF0  2  46 11              LSR   nums_1            ; shift highest byte
00DDF2  2  66 12              ROR   nums_2            ; shift middle byte
00DDF4  2  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
00DDF6  2  8A                 TXA                     ; load with "0"/2
00DDF7  2  2A                 ROL                     ; shift in carry
00DDF8  2  91 AD              STA   (str_pl),Y        ; save to temp string + index
00DDFA  2  88                 DEY                     ; decrement index
00DDFB  2  10 F3              BPL   NextB1            ; loop if not done
00DDFD  2               
00DDFD  2  A5 78              LDA   TempB             ; get # of characters
00DDFF  2  F0 0A              BEQ   EndBHS            ; branch if truncate
00DE01  2               
00DE01  2  AA                 TAX                     ; copy length to X
00DE02  2  38                 SEC                     ; set carry for add !
00DE03  2  49 FF              EOR   #$FF              ; 1's complement
00DE05  2  69 18              ADC   #$18              ; add 24d
00DE07  2  F0 1C              BEQ   GoPr2             ; if zero print whole string
00DE09  2               
00DE09  2  D0 0F              BNE   GoPr1             ; else go make output string
00DE0B  2               
00DE0B  2               ; this is the exit code and is also used by HEX$()
00DE0B  2               ; truncate string to remove leading "0"s
00DE0B  2               
00DE0B  2               EndBHS:
00DE0B  2  A8                 TAY                     ; clear index (A=0, X=length here)
00DE0C  2               NextB2:
00DE0C  2  B1 AD              LDA   (str_pl),Y        ; get character from string
00DE0E  2  C9 30              CMP   #'0'              ; compare with "0"
00DE10  2  D0 07              BNE   GoPr              ; if not "0" then go print string from here
00DE12  2               
00DE12  2  CA                 DEX                     ; decrement character count
00DE13  2  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
00DE15  2               
00DE15  2  C8                 INY                     ; else increment index
00DE16  2  10 F4              BPL   NextB2            ; loop always
00DE18  2               
00DE18  2               ; make fixed length output string - ignore overflows!
00DE18  2               
00DE18  2               GoPr3:
00DE18  2  E8                 INX                     ; need at least 1 character
00DE19  2               GoPr:
00DE19  2  98                 TYA                     ; copy result
00DE1A  2               GoPr1:
00DE1A  2  18                 CLC                     ; clear carry for add
00DE1B  2  65 AD              ADC   str_pl            ; add low address
00DE1D  2  85 AD              STA   str_pl            ; save low address
00DE1F  2  A9 00              LDA   #$00              ; do high byte
00DE21  2  65 AE              ADC   str_ph            ; add high address
00DE23  2  85 AE              STA   str_ph            ; save high address
00DE25  2               GoPr2:
00DE25  2  86 AC              STX   str_ln            ; X holds string length
00DE27  2  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
00DE2A  2  4C 95 D1           JMP   LAB_RTST          ; check for space on descriptor stack then put address
00DE2D  2                                             ; and length on descriptor stack and update stack pointers
00DE2D  2               
00DE2D  2               BinFErr:
00DE2D  2  4C 37 CF           JMP   LAB_FCER          ; do function call error then warm start
00DE30  2               
00DE30  2               ; perform HEX$()
00DE30  2               
00DE30  2               LAB_HEXS:
00DE30  2  E0 07              CPX   #$07              ; max + 1
00DE32  2  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
00DE34  2               
00DE34  2  86 78              STX   TempB             ; save # of characters
00DE36  2               
00DE36  2  A9 06              LDA   #$06              ; need 6 bytes for string
00DE38  2  20 48 D1           JSR   LAB_MSSP          ; make string space A bytes long
00DE3B  2  A0 05              LDY   #$05              ; set string index
00DE3D  2               
00DE3D  2               ; *** disable decimal mode patch - comment next line ***
00DE3D  2               ;      SED                     ; need decimal mode for nibble convert
00DE3D  2  A5 13              LDA   nums_3            ; get lowest byte
00DE3F  2  20 5C DE           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00DE42  2  A5 12              LDA   nums_2            ; get middle byte
00DE44  2  20 5C DE           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00DE47  2  A5 11              LDA   nums_1            ; get highest byte
00DE49  2  20 5C DE           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
00DE4C  2               ; *** disable decimal mode patch - comment next line ***
00DE4C  2               ;      CLD                     ; back to binary
00DE4C  2               
00DE4C  2  A2 06              LDX   #$06              ; character count
00DE4E  2  A5 78              LDA   TempB             ; get # of characters
00DE50  2  F0 B9              BEQ   EndBHS            ; branch if truncate
00DE52  2               
00DE52  2  AA                 TAX                     ; copy length to X
00DE53  2  38                 SEC                     ; set carry for add !
00DE54  2  49 FF              EOR   #$FF              ; 1's complement
00DE56  2  69 06              ADC   #$06              ; add 6d
00DE58  2  F0 CB              BEQ   GoPr2             ; if zero print whole string
00DE5A  2               
00DE5A  2  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
00DE5C  2               
00DE5C  2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
00DE5C  2               
00DE5C  2               LAB_A2HX:
00DE5C  2  AA                 TAX                     ; save byte
00DE5D  2  29 0F              AND   #$0F              ; mask off top bits
00DE5F  2  20 67 DE           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
00DE62  2  8A                 TXA                     ; get byte back
00DE63  2  4A                 LSR                     ; /2  shift high nibble to low nibble
00DE64  2  4A                 LSR                     ; /4
00DE65  2  4A                 LSR                     ; /8
00DE66  2  4A                 LSR                     ; /16
00DE67  2               LAB_AL2X:
00DE67  2  C9 0A              CMP   #$0A              ; set carry for +1 if >9
00DE69  2               ; *** begin disable decimal mode patch ***
00DE69  2               ; *** insert
00DE69  2  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
00DE6B  2  69 06              ADC   #$06              ; adjust for A to F
00DE6D  2               LAB_AL20:
00DE6D  2               ; *** end   disable decimal mode patch ***
00DE6D  2  69 30              ADC   #'0'              ; add ASCII "0"
00DE6F  2  91 AD              STA   (str_pl),Y        ; save to temp string
00DE71  2  88                 DEY                     ; decrement counter
00DE72  2  60                 RTS
00DE73  2               
00DE73  2               LAB_NLTO:
00DE73  2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00DE75  2  A9 00              LDA   #$00              ; clear sign compare
00DE77  2               LAB_MLTE:
00DE77  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00DE79  2  8A                 TXA                     ; restore character
00DE7A  2  20 52 DA           JSR   LAB_2912          ; evaluate new ASCII digit
00DE7D  2               
00DE7D  2               ; gets here if the first character was "$" for hex
00DE7D  2               ; get hex number
00DE7D  2               
00DE7D  2               LAB_CHEX:
00DE7D  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00DE80  2  90 0A              BCC   LAB_ISHN          ; branch if numeric character
00DE82  2               
00DE82  2  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
00DE84  2  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
00DE86  2  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
00DE88  2  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
00DE8A  2               
00DE8A  2  69 0A              ADC   #$0A              ; convert to nibble
00DE8C  2               LAB_ISHN:
00DE8C  2  29 0F              AND   #$0F              ; convert to binary
00DE8E  2  AA                 TAX                     ; save nibble
00DE8F  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DE91  2  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
00DE93  2               
00DE93  2  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
00DE95  2  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
00DE97  2               
00DE97  2               LAB_MLTO:
00DE97  2  4C D0 D6           JMP   LAB_2564          ; do overflow error and warm start
00DE9A  2               
00DE9A  2               LAB_NXCH:
00DE9A  2  AA                 TAX                     ; save bit
00DE9B  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DE9D  2  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
00DE9F  2               
00DE9F  2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
00DEA1  2  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
00DEA3  2               
00DEA3  2  A9 00              LDA   #$00              ; clear sign compare
00DEA5  2               LAB_MLBT:
00DEA5  2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
00DEA7  2  8A                 TXA                     ; restore bit
00DEA8  2  20 52 DA           JSR   LAB_2912          ; evaluate new ASCII digit
00DEAB  2               
00DEAB  2               ; gets here if the first character was  "%" for binary
00DEAB  2               ; get binary number
00DEAB  2               
00DEAB  2               LAB_CBIN:
00DEAB  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00DEAE  2  49 30              EOR   #'0'              ; convert "0" to 0 etc.
00DEB0  2  C9 02              CMP   #$02              ; compare with max+1
00DEB2  2  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
00DEB4  2               
00DEB4  2               LAB_EXCH:
00DEB4  2  4C 37 DA           JMP   LAB_28F6          ; evaluate -ve flag and return
00DEB7  2               
00DEB7  2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
00DEB7  2               ; now also the code that checks to see if an interrupt has occurred
00DEB7  2               
00DEB7  2               CTRLC:
00DEB7  2  AD 00 08           LDA   ccflag            ; get [CTRL-C] check flag
00DEBA  2  D0 18              BNE   LAB_FBA2          ; exit if inhibited
00DEBC  2               
00DEBC  2  20 F9 E0           JSR   V_INPT            ; scan input device
00DEBF  2  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
00DEC1  2               
00DEC1  2  8D 01 08           STA   ccbyte            ; save received byte
00DEC4  2  A2 20              LDX   #$20              ; "life" timer for bytes
00DEC6  2  8E 02 08           STX   ccnull            ; set countdown
00DEC9  2  4C 19 C5           JMP   LAB_1636          ; return to BASIC
00DECC  2               
00DECC  2               LAB_FBA0:
00DECC  2  AE 02 08           LDX   ccnull            ; get countdown byte
00DECF  2  F0 03              BEQ   LAB_FBA2          ; exit if finished
00DED1  2               
00DED1  2  CE 02 08           DEC   ccnull            ; else decrement countdown
00DED4  2               LAB_FBA2:
00DED4  2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
00DED6  2  20 DF DE           JSR   LAB_CKIN          ; go check interrupt
00DED9  2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
00DEDB  2  20 DF DE           JSR   LAB_CKIN          ; go check interrupt
00DEDE  2               LAB_CRTS:
00DEDE  2  60                 RTS
00DEDF  2               
00DEDF  2               ; check whichever interrupt is indexed by X
00DEDF  2               
00DEDF  2               LAB_CKIN:
00DEDF  2  B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
00DEE1  2  10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
00DEE3  2               
00DEE3  2               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
00DEE3  2               ; automatically enable the interrupt when we exit
00DEE3  2               
00DEE3  2  0A                 ASL                     ; move happened bit to setup bit
00DEE4  2  29 40              AND   #$40              ; mask happened bits
00DEE6  2  F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
00DEE8  2               
00DEE8  2  95 00              STA   PLUS_0,X          ; save interrupt flag byte
00DEEA  2               
00DEEA  2  8A                 TXA                     ; copy index ..
00DEEB  2  A8                 TAY                     ; .. to Y
00DEEC  2               
00DEEC  2  68                 PLA                     ; dump return address low byte, call from CTRL-C
00DEED  2  68                 PLA                     ; dump return address high byte
00DEEE  2               
00DEEE  2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
00DEF0  2  20 03 C1           JSR   LAB_1212          ; check room on stack for A bytes
00DEF3  2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
00DEF5  2  48                 PHA                     ; push on stack
00DEF6  2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00DEF8  2  48                 PHA                     ; push on stack
00DEF9  2  A5 88              LDA   Clineh            ; get current line high byte
00DEFB  2  48                 PHA                     ; push on stack
00DEFC  2  A5 87              LDA   Clinel            ; get current line low byte
00DEFE  2  48                 PHA                     ; push on stack
00DEFF  2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
00DF01  2  48                 PHA                     ; push on stack
00DF02  2               
00DF02  2  B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
00DF05  2  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
00DF07  2  B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
00DF0A  2  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
00DF0C  2               
00DF0C  2  4C C0 C4           JMP   LAB_15C2          ; go do interpreter inner loop
00DF0F  2                                             ; can't RTS, we used the stack! the RTS from the ctrl-c
00DF0F  2                                             ; check will be taken when the RETIRQ/RETNMI/RETURN is
00DF0F  2                                             ; executed at the end of the subroutine
00DF0F  2               
00DF0F  2               ; get byte from input device, no waiting
00DF0F  2               ; returns with carry set if byte in A
00DF0F  2               
00DF0F  2               INGET:
00DF0F  2  20 F9 E0           JSR   V_INPT            ; call scan input device
00DF12  2  B0 09              BCS   LAB_FB95          ; if byte go reset timer
00DF14  2               
00DF14  2  AD 02 08           LDA   ccnull            ; get countdown
00DF17  2  F0 09              BEQ   LAB_FB96          ; exit if empty
00DF19  2               
00DF19  2  AD 01 08           LDA   ccbyte            ; get last received byte
00DF1C  2  38                 SEC                     ; flag we got a byte
00DF1D  2               LAB_FB95:
00DF1D  2  A2 00              LDX   #$00              ; clear X
00DF1F  2  8E 02 08           STX   ccnull            ; clear timer because we got a byte
00DF22  2               LAB_FB96:
00DF22  2  60                 RTS
00DF23  2               
00DF23  2               ; these routines only enable the interrupts if the set-up flag is set
00DF23  2               ; if not they have no effect
00DF23  2               
00DF23  2               ; perform IRQ {ON|OFF|CLEAR}
00DF23  2               
00DF23  2               LAB_IRQ:
00DF23  2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
00DF25  2  2C                 .byte $2C               ; make next line BIT abs.
00DF26  2               
00DF26  2               ; perform NMI {ON|OFF|CLEAR}
00DF26  2               
00DF26  2               LAB_NMI:
00DF26  2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
00DF28  2  C9 93              CMP   #TK_ON            ; compare with token for ON
00DF2A  2  F0 11              BEQ   LAB_INON          ; go turn on interrupt
00DF2C  2               
00DF2C  2  C9 B5              CMP   #TK_OFF           ; compare with token for OFF
00DF2E  2  F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
00DF30  2               
00DF30  2  49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
00DF32  2  F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
00DF34  2               
00DF34  2  4C 02 CC           JMP   LAB_SNER          ; do syntax error then warm start
00DF37  2               
00DF37  2               LAB_IOFF:
00DF37  2  A9 7F              LDA   #$7F              ; clear A
00DF39  2  35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
00DF3B  2  10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
00DF3D  2               
00DF3D  2               LAB_INON:
00DF3D  2  B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
00DF3F  2  0A                 ASL                     ; Shift bit to enabled flag
00DF40  2  15 00              ORA   PLUS_0,X          ; OR with flag byte
00DF42  2               LAB_INEX:
00DF42  2  95 00              STA   PLUS_0,X          ; save interrupt flag byte
00DF44  2  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
00DF47  2               
00DF47  2               ; these routines set up the pointers and flags for the interrupt routines
00DF47  2               ; note that the interrupts are also enabled by these commands
00DF47  2               
00DF47  2               ; perform ON IRQ
00DF47  2               
00DF47  2               LAB_SIRQ:
00DF47  2  58                 CLI                     ; enable interrupts
00DF48  2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
00DF4A  2  2C                 .byte $2C               ; make next line BIT abs.
00DF4B  2               
00DF4B  2               ; perform ON NMI
00DF4B  2               
00DF4B  2               LAB_SNMI:
00DF4B  2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
00DF4D  2               
00DF4D  2  86 78              STX   TempB             ; save interrupt pointer
00DF4F  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
00DF52  2  20 56 C7           JSR   LAB_GFPN          ; get fixed-point number into temp integer
00DF55  2  A5 79              LDA   Smeml             ; get start of mem low byte
00DF57  2  A6 7A              LDX   Smemh             ; get start of mem high byte
00DF59  2  20 2B C3           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00DF5C  2  B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
00DF5E  2               
00DF5E  2  4C 70 C6           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
00DF61  2               
00DF61  2               LAB_LFND:
00DF61  2  A6 78              LDX   TempB             ; get interrupt pointer
00DF63  2  A5 AA              LDA   Baslnl            ; get pointer low byte
00DF65  2  E9 01              SBC   #$01              ; -1 (carry already set for subtract)
00DF67  2  95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
00DF69  2  A5 AB              LDA   Baslnh            ; get pointer high byte
00DF6B  2  E9 00              SBC   #$00              ; subtract carry
00DF6D  2  95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
00DF6F  2               
00DF6F  2  A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
00DF71  2  95 00              STA   PLUS_0,X          ; set interrupt flags
00DF73  2               LAB_IRTS:
00DF73  2  60                 RTS
00DF74  2               
00DF74  2               ; return from IRQ service, restores the enabled flag.
00DF74  2               
00DF74  2               ; perform RETIRQ
00DF74  2               
00DF74  2               LAB_RETIRQ:
00DF74  2  D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
00DF76  2               
00DF76  2  A5 DF              LDA   IrqBase           ; get interrupt flags
00DF78  2  0A                 ASL                     ; copy setup to enabled (b7)
00DF79  2  05 DF              ORA   IrqBase           ; OR in setup flag
00DF7B  2  85 DF              STA   IrqBase           ; save enabled flag
00DF7D  2  4C 77 C6           JMP   LAB_16E8          ; go do rest of RETURN
00DF80  2               
00DF80  2               ; return from NMI service, restores the enabled flag.
00DF80  2               
00DF80  2               ; perform RETNMI
00DF80  2               
00DF80  2               LAB_RETNMI:
00DF80  2  D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
00DF82  2               
00DF82  2  A5 DC              LDA   NmiBase           ; get set-up flag
00DF84  2  0A                 ASL                     ; copy setup to enabled (b7)
00DF85  2  05 DC              ORA   NmiBase           ; OR in setup flag
00DF87  2  85 DC              STA   NmiBase           ; save enabled flag
00DF89  2  4C 77 C6           JMP   LAB_16E8          ; go do rest of RETURN
00DF8C  2               
00DF8C  2               ; MAX() MIN() pre process
00DF8C  2               
00DF8C  2               LAB_MMPP:
00DF8C  2  20 E9 CA           JSR   LAB_EVEZ          ; process expression
00DF8F  2  4C D0 CA           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
00DF92  2               
00DF92  2               ; perform MAX()
00DF92  2               
00DF92  2               LAB_MAX:
00DF92  2  20 C0 DF           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
00DF95  2                                             ; pull FAC2 and compare with FAC1
00DF95  2  10 FB              BPL   LAB_MAX           ; branch if no swap to do
00DF97  2               
00DF97  2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00DF99  2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
00DF9B  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00DF9D  2  20 D0 D5           JSR   LAB_279B          ; copy FAC2 to FAC1
00DFA0  2  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
00DFA2  2               
00DFA2  2               ; perform MIN()
00DFA2  2               
00DFA2  2               LAB_MIN:
00DFA2  2  20 C0 DF           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
00DFA5  2                                             ; pull FAC2 and compare with FAC1
00DFA5  2  30 FB              BMI   LAB_MIN           ; branch if no swap to do
00DFA7  2               
00DFA7  2  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
00DFA9  2               
00DFA9  2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00DFAB  2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
00DFAD  2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
00DFAF  2  20 D0 D5           JSR   LAB_279B          ; copy FAC2 to FAC1
00DFB2  2  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
00DFB4  2               
00DFB4  2               ; exit routine. don't bother returning to the loop code
00DFB4  2               ; check for correct exit, else so syntax error
00DFB4  2               
00DFB4  2               LAB_MMEC:
00DFB4  2  C9 29              CMP   #')'              ; is it end of function?
00DFB6  2  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
00DFB8  2               
00DFB8  2  68                 PLA                     ; dump return address low byte
00DFB9  2  68                 PLA                     ; dump return address high byte
00DFBA  2  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
00DFBD  2               
00DFBD  2               LAB_MMSE:
00DFBD  2  4C 02 CC           JMP   LAB_SNER          ; do syntax error then warm start
00DFC0  2               
00DFC0  2               ; check for next, evaluate and return or exit
00DFC0  2               ; this is the routine that does most of the work
00DFC0  2               
00DFC0  2               LAB_PHFA:
00DFC0  2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
00DFC3  2  C9 2C              CMP   #','              ; is there more ?
00DFC5  2  D0 ED              BNE   LAB_MMEC          ; if not go do end check
00DFC7  2               
00DFC7  2                                             ; push FAC1
00DFC7  2  20 E6 D8           JSR   LAB_27BA          ; round FAC1
00DFCA  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign
00DFCC  2  09 7F              ORA   #$7F              ; set all non sign bits
00DFCE  2  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
00DFD0  2  48                 PHA                     ; push on stack
00DFD1  2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
00DFD3  2  48                 PHA                     ; push on stack
00DFD4  2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00DFD6  2  48                 PHA                     ; push on stack
00DFD7  2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00DFD9  2  48                 PHA                     ; push on stack
00DFDA  2               
00DFDA  2  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
00DFDD  2  20 CD CA           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00DFE0  2                                             ; else do type mismatch
00DFE0  2               
00DFE0  2                                             ; pop FAC2 (MAX/MIN expression so far)
00DFE0  2  68                 PLA                     ; pop exponent
00DFE1  2  85 B3              STA   FAC2_e            ; save FAC2 exponent
00DFE3  2  68                 PLA                     ; pop mantissa3
00DFE4  2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
00DFE6  2  68                 PLA                     ; pop mantissa1
00DFE7  2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00DFE9  2  68                 PLA                     ; pop sign/mantissa1
00DFEA  2  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
00DFEC  2  85 B7              STA   FAC2_s            ; save FAC2 sign
00DFEE  2               
00DFEE  2                                             ; compare FAC1 with (packed) FAC2
00DFEE  2  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
00DFF0  2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
00DFF2  2  4C 24 D9           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
00DFF5  2                                             ; returns A=$00 if FAC1 = (AY)
00DFF5  2                                             ; returns A=$01 if FAC1 > (AY)
00DFF5  2                                             ; returns A=$FF if FAC1 < (AY)
00DFF5  2               
00DFF5  2               ; perform WIDTH
00DFF5  2               
00DFF5  2               LAB_WDTH:
00DFF5  2  C9 2C              CMP   #','              ; is next byte ","
00DFF7  2  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
00DFF9  2               
00DFF9  2  20 A0 D4           JSR   LAB_GTBY          ; get byte parameter
00DFFC  2  8A                 TXA                     ; copy width to A
00DFFD  2  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
00DFFF  2               
00DFFF  2  E0 10              CPX   #$10              ; else make min width = 16d
00E001  2  90 45              BCC   TabErr            ; if less do function call error and exit
00E003  2               
00E003  2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
00E003  2               ; tab size greater than the line length.
00E003  2               
00E003  2  E4 64              CPX   TabSiz            ; compare with tab size
00E005  2  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
00E007  2               
00E007  2  86 64              STX   TabSiz            ; else make tab size = terminal width
00E009  2               LAB_NSTT:
00E009  2  86 0F              STX   TWidth            ; set the terminal width
00E00B  2  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
00E00E  2  F0 1A              BEQ   WExit             ; exit if no following
00E010  2               
00E010  2  C9 2C              CMP   #','              ; else is it ","
00E012  2  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
00E014  2               
00E014  2               LAB_TBSZ:
00E014  2  20 9D D4           JSR   LAB_SGBY          ; scan and get byte parameter
00E017  2  8A                 TXA                     ; copy TAB size
00E018  2  30 2E              BMI   TabErr            ; if >127 do function call error and exit
00E01A  2               
00E01A  2  E0 01              CPX   #$01              ; compare with min-1
00E01C  2  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
00E01E  2               
00E01E  2  A5 0F              LDA   TWidth            ; set flags for width
00E020  2  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
00E022  2               
00E022  2  E4 0F              CPX   TWidth            ; compare TAB with width
00E024  2  F0 02              BEQ   LAB_SVTB          ; ok if =
00E026  2               
00E026  2  B0 20              BCS   TabErr            ; branch if too big
00E028  2               
00E028  2               LAB_SVTB:
00E028  2  86 64              STX   TabSiz            ; save TAB size
00E02A  2               
00E02A  2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00E02A  2               ; position on a line that still has at least one whole tab width between it
00E02A  2               ; and the end of the line.
00E02A  2               
00E02A  2               WExit:
00E02A  2  A5 0F              LDA   TWidth            ; get width
00E02C  2  F0 06              BEQ   LAB_SULP          ; branch if infinite line
00E02E  2               
00E02E  2  C5 64              CMP   TabSiz            ; compare with tab size
00E030  2  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
00E032  2               
00E032  2  85 64              STA   TabSiz            ; else make tab size = terminal width
00E034  2               LAB_SULP:
00E034  2  38                 SEC                     ; set carry for subtract
00E035  2               LAB_WDLP:
00E035  2  E5 64              SBC   TabSiz            ; subtract tab size
00E037  2  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
00E039  2               
00E039  2  65 64              ADC   TabSiz            ; add tab size back
00E03B  2  18                 CLC                     ; clear carry for add
00E03C  2  65 64              ADC   TabSiz            ; add tab size back again
00E03E  2  85 10              STA   Iclim             ; save for now
00E040  2  A5 0F              LDA   TWidth            ; get width back
00E042  2  38                 SEC                     ; set carry for subtract
00E043  2  E5 10              SBC   Iclim             ; subtract remainder
00E045  2  85 10              STA   Iclim             ; save tab column limit
00E047  2               LAB_NOSQ:
00E047  2  60                 RTS
00E048  2               
00E048  2               TabErr:
00E048  2  4C 37 CF           JMP   LAB_FCER          ; do function call error then warm start
00E04B  2               
00E04B  2               ; perform SQR()
00E04B  2               
00E04B  2               LAB_SQR:
00E04B  2  A5 B0              LDA   FAC1_s            ; get FAC1 sign
00E04D  2  30 F9              BMI   TabErr            ; if -ve do function call error
00E04F  2               
00E04F  2  A5 AC              LDA   FAC1_e            ; get exponent
00E051  2  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
00E053  2               
00E053  2                                             ; else do root
00E053  2  20 D7 D8           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
00E056  2  A9 00              LDA   #$00              ; clear A
00E058  2               
00E058  2  85 77              STA   FACt_3            ; clear remainder
00E05A  2  85 76              STA   FACt_2            ; ..
00E05C  2  85 75              STA   FACt_1            ; ..
00E05E  2  85 78              STA   TempB             ; ..
00E060  2               
00E060  2  85 AF              STA   FAC1_3            ; clear root
00E062  2  85 AE              STA   FAC1_2            ; ..
00E064  2  85 AD              STA   FAC1_1            ; ..
00E066  2               
00E066  2  A2 18              LDX   #$18              ; 24 pairs of bits to do
00E068  2  A5 B3              LDA   FAC2_e            ; get exponent
00E06A  2  4A                 LSR                     ; check odd/even
00E06B  2  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
00E06D  2               
00E06D  2               LAB_SQE1:
00E06D  2  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00E06F  2  26 B5              ROL   FAC2_2            ; ..
00E071  2  26 B4              ROL   FAC2_1            ; ..
00E073  2  26 77              ROL   FACt_3            ; .. into remainder
00E075  2  26 76              ROL   FACt_2            ; ..
00E077  2  26 75              ROL   FACt_1            ; ..
00E079  2  26 78              ROL   TempB             ; .. never overflows
00E07B  2               LAB_SQE2:
00E07B  2  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00E07D  2  26 B5              ROL   FAC2_2            ; ..
00E07F  2  26 B4              ROL   FAC2_1            ; ..
00E081  2  26 77              ROL   FACt_3            ; .. into remainder
00E083  2  26 76              ROL   FACt_2            ; ..
00E085  2  26 75              ROL   FACt_1            ; ..
00E087  2  26 78              ROL   TempB             ; .. never overflows
00E089  2               
00E089  2  06 AF              ASL   FAC1_3            ; root = root * 2
00E08B  2  26 AE              ROL   FAC1_2            ; ..
00E08D  2  26 AD              ROL   FAC1_1            ; .. never overflows
00E08F  2               
00E08F  2  A5 AF              LDA   FAC1_3            ; get root low byte
00E091  2  2A                 ROL                     ; *2
00E092  2  85 5B              STA   Temp3             ; save partial low byte
00E094  2  A5 AE              LDA   FAC1_2            ; get root low mid byte
00E096  2  2A                 ROL                     ; *2
00E097  2  85 5C              STA   Temp3+1           ; save partial low mid byte
00E099  2  A5 AD              LDA   FAC1_1            ; get root high mid byte
00E09B  2  2A                 ROL                     ; *2
00E09C  2  85 5D              STA   Temp3+2           ; save partial high mid byte
00E09E  2  A9 00              LDA   #$00              ; get root high byte (always $00)
00E0A0  2  2A                 ROL                     ; *2
00E0A1  2  85 5E              STA   Temp3+3           ; save partial high byte
00E0A3  2               
00E0A3  2                                             ; carry clear for subtract +1
00E0A3  2  A5 77              LDA   FACt_3            ; get remainder low byte
00E0A5  2  E5 5B              SBC   Temp3             ; subtract partial low byte
00E0A7  2  85 5B              STA   Temp3             ; save partial low byte
00E0A9  2               
00E0A9  2  A5 76              LDA   FACt_2            ; get remainder low mid byte
00E0AB  2  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
00E0AD  2  85 5C              STA   Temp3+1           ; save partial low mid byte
00E0AF  2               
00E0AF  2  A5 75              LDA   FACt_1            ; get remainder high mid byte
00E0B1  2  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
00E0B3  2  A8                 TAY                     ; copy partial high mid byte
00E0B4  2               
00E0B4  2  A5 78              LDA   TempB             ; get remainder high byte
00E0B6  2  E5 5E              SBC   Temp3+3           ; subtract partial high byte
00E0B8  2  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
00E0BA  2               
00E0BA  2  85 78              STA   TempB             ; save remainder high byte
00E0BC  2               
00E0BC  2  84 75              STY   FACt_1            ; save remainder high mid byte
00E0BE  2               
00E0BE  2  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
00E0C0  2  85 76              STA   FACt_2            ; save remainder low mid byte
00E0C2  2               
00E0C2  2  A5 5B              LDA   Temp3             ; get partial low byte
00E0C4  2  85 77              STA   FACt_3            ; save remainder low byte
00E0C6  2               
00E0C6  2  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
00E0C8  2               LAB_SQNS:
00E0C8  2  CA                 DEX                     ; decrement bit pair count
00E0C9  2  D0 A2              BNE   LAB_SQE1          ; loop if not all done
00E0CB  2               
00E0CB  2  38                 SEC                     ; set carry for subtract
00E0CC  2  A5 B3              LDA   FAC2_e            ; get exponent
00E0CE  2  E9 80              SBC   #$80              ; normalise
00E0D0  2  6A                 ROR                     ; /2 and re-bias to $80
00E0D1  2  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
00E0D3  2  85 AC              STA   FAC1_e            ; save it
00E0D5  2  4C 41 D6           JMP   LAB_24D5          ; normalise FAC1 and return
00E0D8  2               
00E0D8  2               ; perform VARPTR()
00E0D8  2               
00E0D8  2               LAB_VARPTR:
00E0D8  2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00E0DB  2  20 B8 CD           JSR   LAB_GVAR          ; get var address
00E0DE  2  20 EF CB           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00E0E1  2  A4 95              LDY   Cvaral            ; get var address low byte
00E0E3  2  A5 96              LDA   Cvarah            ; get var address high byte
00E0E5  2  4C 67 D0           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
00E0E8  2               
00E0E8  2               ; perform PI
00E0E8  2               
00E0E8  2               LAB_PI:
00E0E8  2  A9 CA              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00E0EA  2  A0 E1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00E0EC  2  20 8A D8           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00E0EF  2  C6 AC              DEC   FAC1_e            ; make result = PI
00E0F1  2  60                 RTS
00E0F2  2               
00E0F2  2               ; perform TWOPI
00E0F2  2               
00E0F2  2               LAB_TWOPI:
00E0F2  2  A9 CA              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
00E0F4  2  A0 E1              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
00E0F6  2  4C 8A D8           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
00E0F9  2               
00E0F9  2               ; system dependant i/o vectors
00E0F9  2               ; these are in RAM and are set by the monitor at start-up
00E0F9  2               
00E0F9  2               V_INPT:
00E0F9  2  6C 05 08           JMP   (VEC_IN)          ; non halting scan input device
00E0FC  2               V_OUTP:
00E0FC  2  6C 07 08           JMP   (VEC_OUT)         ; send byte to output device
00E0FF  2               V_LOAD:
00E0FF  2  6C 09 08           JMP   (VEC_LD)          ; load BASIC program
00E102  2               V_SAVE:
00E102  2  6C 0B 08           JMP   (VEC_SV)          ; save BASIC program
00E105  2               
00E105  2               ; The rest are tables messages and code for RAM
00E105  2               
00E105  2               ; the rest of the code is tables and BASIC start-up code
00E105  2               
00E105  2               PG2_TABS:
00E105  2  00                 .byte $00               ; ctrl-c flag           -     $00 = enabled
00E106  2  00                 .byte $00               ; ctrl-c byte           -     GET needs this
00E107  2  00                 .byte $00               ; ctrl-c byte timeout   -     GET needs this
00E108  2  B7 DE              .word CTRLC             ; ctrl c check vector
00E10A  2               ;     .word xxxx              ; non halting key input -     monitor to set this
00E10A  2               ;     .word xxxx              ; output vector         -     monitor to set this
00E10A  2               ;     .word xxxx              ; load vector           -     monitor to set this
00E10A  2               ;     .word xxxx              ; save vector           -     monitor to set this
00E10A  2               PG2_TABE:
00E10A  2               
00E10A  2               ; character get subroutine for zero page
00E10A  2               
00E10A  2               ; For a 1.8432MHz 6502 including the JSR and RTS
00E10A  2               ; fastest (>=":") =  29 cycles =  15.7uS
00E10A  2               ; slowest (<":")  =  40 cycles =  21.7uS
00E10A  2               ; space skip      = +21 cycles = +11.4uS
00E10A  2               ; inc across page =  +4 cycles =  +2.2uS
00E10A  2               
00E10A  2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
00E10A  2               ; block is copied to it's destination, any non zero page address will do at assembly
00E10A  2               ; time, to assemble a three byte instruction.
00E10A  2               
00E10A  2               ; page 0 initialisation table from $BC
00E10A  2               ; increment and scan memory
00E10A  2               
00E10A  2               LAB_2CEE:
00E10A  2  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
00E10C  2  D0 02              BNE   LAB_2CF4          ; branch if no carry
00E10E  2                                             ; else
00E10E  2  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
00E110  2               
00E110  2               ; page 0 initialisation table from $C2
00E110  2               ; scan memory
00E110  2               
00E110  2               LAB_2CF4:
00E110  2  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
00E113  2  C9 AC              CMP   #TK_ELSE          ; compare with the token for ELSE
00E115  2  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
00E117  2               
00E117  2  C9 3A              CMP   #':'              ; compare with ":"
00E119  2  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
00E11B  2               
00E11B  2  C9 20              CMP   #' '              ; compare with " "
00E11D  2  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
00E11F  2               
00E11F  2  38                 SEC                     ; set carry for SBC
00E120  2  E9 30              SBC   #'0'              ; subtract "0"
00E122  2  38                 SEC                     ; set carry for SBC
00E123  2  E9 D0              SBC   #$D0              ; subtract -"0"
00E125  2                                             ; clear carry if byte = "0"-"9"
00E125  2               LAB_2D05:
00E125  2  60                 RTS
00E126  2               
00E126  2               ; page zero initialisation table $00-$12 inclusive
00E126  2               
00E126  2               StrTab:
00E126  2  4C                 .byte $4C               ; JMP opcode
00E127  2  00 C0              .word LAB_COLD          ; initial warm start vector (cold start)
00E129  2               
00E129  2  00                 .byte $00               ; these bytes are not used by BASIC
00E12A  2  00 00              .word $0000             ;
00E12C  2  00 00              .word $0000             ;
00E12E  2  00 00              .word $0000             ;
00E130  2               
00E130  2  4C                 .byte $4C               ; JMP opcode
00E131  2  37 CF              .word LAB_FCER          ; initial user function vector ("Function call" error)
00E133  2  00                 .byte $00               ; default NULL count
00E134  2  00                 .byte $00               ; clear terminal position
00E135  2  00                 .byte $00               ; default terminal width byte
00E136  2  F2                 .byte $F2               ; default limit for TAB = 14
00E137  2  00 09              .word Ram_base          ; start of user RAM
00E139  2               EndTab:
00E139  2               
00E139  2               LAB_MSZM:
00E139  2  0D 0A 4D 65        .byte $0D,$0A,"Memory size ",$00
00E13D  2  6D 6F 72 79  
00E141  2  20 73 69 7A  
00E148  2               
00E148  2               LAB_SMSG:
00E148  2  20 42 79 74        .byte " Bytes free",$0D,$0A,$0A
00E14C  2  65 73 20 66  
00E150  2  72 65 65 0D  
00E156  2  45 6E 68 61        .byte "Enhanced BASIC 2.23",$0A,$00
00E15A  2  6E 63 65 64  
00E15E  2  20 42 41 53  
00E16B  2               
00E16B  2               ; numeric constants and series
00E16B  2               
00E16B  2                                             ; constants and series for LOG(n)
00E16B  2               LAB_25A0:
00E16B  2  02                 .byte $02               ; counter
00E16C  2  80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
00E170  2  80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
00E174  2               ;##   .byte $80,$76,$22,$F1   ; 0.96147
00E174  2  82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
00E178  2               ;##   .byte $82,$38,$AA,$45   ; 2.88539
00E178  2               
00E178  2               LAB_25AD:
00E178  2  80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
00E17C  2               LAB_25B1:
00E17C  2  81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
00E180  2               LAB_25B5:
00E180  2  80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
00E184  2               LAB_25B9:
00E184  2  80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
00E188  2               
00E188  2                                             ; numeric PRINT constants
00E188  2               LAB_2947:
00E188  2  91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
00E18C  2               LAB_294B:
00E18C  2  94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
00E190  2               LAB_294F:
00E190  2  94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
00E194  2               
00E194  2                                             ; EXP(n) constants and series
00E194  2               LAB_2AFA:
00E194  2  81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
00E198  2               LAB_2AFE:
00E198  2  06                 .byte $06               ; counter
00E199  2  74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
00E19D  2  77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
00E1A1  2  7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
00E1A5  2  7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
00E1A9  2  7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
00E1AD  2  80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
00E1B1  2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
00E1B5  2               
00E1B5  2               ;##   .byte $07               ; counter
00E1B5  2               ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
00E1B5  2               ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
00E1B5  2               ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
00E1B5  2               ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
00E1B5  2               ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
00E1B5  2               ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
00E1B5  2               ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
00E1B5  2               ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
00E1B5  2               
00E1B5  2                                             ; trigonometric constants and series
00E1B5  2               LAB_2C78:
00E1B5  2  81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
00E1B9  2               LAB_2C84:
00E1B9  2  04                 .byte $04               ; counter
00E1BA  2  86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
00E1BE  2               ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
00E1BE  2  87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
00E1C2  2               ;##   .byte $87,$99,$26,$64   ;-76.575
00E1C2  2  87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
00E1C6  2  86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
00E1CA  2               ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
00E1CA  2               LAB_2C7C:
00E1CA  2  83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
00E1CE  2               ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
00E1CE  2               
00E1CE  2               LAB_2CC9:
00E1CE  2  08                 .byte $08               ; counter
00E1CF  2  78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
00E1D3  2  7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
00E1D7  2  7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
00E1DB  2  7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
00E1DF  2  7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
00E1E3  2  7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
00E1E7  2  7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
00E1EB  2  7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
00E1EF  2               
00E1EF  2               ;##   .byte $08               ; counter
00E1EF  2               ;##   .byte $78,$3B,$D7,$4A   ; 1/17
00E1EF  2               ;##   .byte $7B,$84,$6E,$02   ;-1/15
00E1EF  2               ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
00E1EF  2               ;##   .byte $7D,$9A,$31,$74   ;-1/11
00E1EF  2               ;##   .byte $7D,$5A,$3D,$84   ; 1/9
00E1EF  2               ;##   .byte $7E,$91,$7F,$C8   ;-1/7
00E1EF  2               ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
00E1EF  2               ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
00E1EF  2               
00E1EF  2               LAB_1D96    = *+1             ; $00,$00 used for undefined variables
00E1EF  2               LAB_259C:
00E1EF  2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
00E1F3  2               LAB_2AFD:
00E1F3  2  81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
00E1F7  2               
00E1F7  2                                             ; misc constants
00E1F7  2               LAB_1DF7:
00E1F7  2  90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
00E1F8  2               LAB_2A96:
00E1F8  2  80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
00E1FC  2               LAB_2C80:
00E1FC  2  7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
00E200  2               LAB_26B5:
00E200  2  84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
00E204  2               
00E204  2               ; This table is used in converting numbers to ASCII.
00E204  2               
00E204  2               LAB_2A9A:
00E204  2               LAB_2A9B = LAB_2A9A+1
00E204  2               LAB_2A9C = LAB_2A9B+1
00E204  2  FE 79 60           .byte $FE,$79,$60       ; -100000
00E207  2  00 27 10           .byte $00,$27,$10       ; 10000
00E20A  2  FF FC 18           .byte $FF,$FC,$18       ; -1000
00E20D  2  00 00 64           .byte $00,$00,$64       ; 100
00E210  2  FF FF F6           .byte $FF,$FF,$F6       ; -10
00E213  2  00 00 01           .byte $00,$00,$01       ; 1
00E216  2               
00E216  2               LAB_CTBL:
00E216  2  1C C5              .word LAB_END-1         ; END
00E218  2  58 C4              .word LAB_FOR-1         ; FOR
00E21A  2  64 CA              .word LAB_NEXT-1        ; NEXT
00E21C  2  89 C6              .word LAB_DATA-1        ; DATA
00E21E  2  47 C9              .word LAB_INPUT-1       ; INPUT
00E220  2  6C CD              .word LAB_DIM-1         ; DIM
00E222  2  66 C9              .word LAB_READ-1        ; READ
00E224  2  B4 C7              .word LAB_LET-1         ; LET
00E226  2  86 C7              .word LAB_DEC-1         ; DEC             new command
00E228  2  E8 C5              .word LAB_GOTO-1        ; GOTO
00E22A  2  A7 C5              .word LAB_RUN-1         ; RUN
00E22C  2  B7 C6              .word LAB_IF-1          ; IF
00E22E  2  3D C5              .word LAB_RESTORE-1     ; RESTORE         modified command
00E230  2  CB C5              .word LAB_GOSUB-1       ; GOSUB
00E232  2  73 DF              .word LAB_RETIRQ-1      ; RETIRQ          new command
00E234  2  7F DF              .word LAB_RETNMI-1      ; RETNMI          new command
00E236  2  74 C6              .word LAB_RETURN-1      ; RETURN
00E238  2  1E C7              .word LAB_REM-1         ; REM
00E23A  2  1A C5              .word LAB_STOP-1        ; STOP
00E23C  2  27 C7              .word LAB_ON-1          ; ON              modified command
00E23E  2  7B C5              .word LAB_NULL-1        ; NULL            modified command
00E240  2  89 C7              .word LAB_INC-1         ; INC             new command
00E242  2  95 D5              .word LAB_WAIT-1        ; WAIT
00E244  2  FE E0              .word V_LOAD-1          ; LOAD
00E246  2  01 E1              .word V_SAVE-1          ; SAVE
00E248  2  81 D0              .word LAB_DEF-1         ; DEF
00E24A  2  1A D5              .word LAB_POKE-1        ; POKE
00E24C  2  36 D5              .word LAB_DOKE-1        ; DOKE            new command
00E24E  2  83 D5              .word LAB_CALL-1        ; CALL            new command
00E250  2  B1 C5              .word LAB_DO-1          ; DO              new command
00E252  2  1A C6              .word LAB_LOOP-1        ; LOOP            new command
00E254  2  55 C8              .word LAB_PRINT-1       ; PRINT
00E256  2  81 C5              .word LAB_CONT-1        ; CONT
00E258  2  A3 C3              .word LAB_LIST-1        ; LIST
00E25A  2  A0 C3              .word LAB_CLEAR-1       ; CLEAR
00E25C  2  50 C3              .word LAB_NEW-1         ; NEW
00E25E  2  F4 DF              .word LAB_WDTH-1        ; WIDTH           new command
00E260  2  24 C8              .word LAB_GET-1         ; GET             new command
00E262  2  5B D5              .word LAB_SWAP-1        ; SWAP            new command
00E264  2  8E DD              .word LAB_BITSET-1      ; BITSET          new command
00E266  2  A2 DD              .word LAB_BITCLR-1      ; BITCLR          new command
00E268  2  22 DF              .word LAB_IRQ-1         ; IRQ             new command
00E26A  2  25 DF              .word LAB_NMI-1         ; NMI             new command
00E26C  2               
00E26C  2               ; function pre process routine table
00E26C  2               
00E26C  2               LAB_FTPL:
00E26C  2               LAB_FTPM    = LAB_FTPL+$01
00E26C  2  72 CC              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
00E26E  2  72 CC              .word LAB_PPFN-1        ; INT(n)          "
00E270  2  72 CC              .word LAB_PPFN-1        ; ABS(n)          "
00E272  2  E8 CA              .word LAB_EVEZ-1        ; USR(x)    process any expression
00E274  2  EB CB              .word LAB_1BF7-1        ; FRE(x)          "
00E276  2  EB CB              .word LAB_1BF7-1        ; POS(x)          "
00E278  2  72 CC              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
00E27A  2  72 CC              .word LAB_PPFN-1        ; RND(n)          "
00E27C  2  72 CC              .word LAB_PPFN-1        ; LOG(n)          "
00E27E  2  72 CC              .word LAB_PPFN-1        ; EXP(n)          "
00E280  2  72 CC              .word LAB_PPFN-1        ; COS(n)          "
00E282  2  72 CC              .word LAB_PPFN-1        ; SIN(n)          "
00E284  2  72 CC              .word LAB_PPFN-1        ; TAN(n)          "
00E286  2  72 CC              .word LAB_PPFN-1        ; ATN(n)          "
00E288  2  72 CC              .word LAB_PPFN-1        ; PEEK(n)         "
00E28A  2  72 CC              .word LAB_PPFN-1        ; DEEK(n)         "
00E28C  2  00 00              .word $0000             ; SADD()    none
00E28E  2  6C CC              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
00E290  2  72 CC              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
00E292  2  6C CC              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
00E294  2  6C CC              .word LAB_PPFS-1        ; ASC($)          "
00E296  2  6C CC              .word LAB_PPFS-1        ; UCASE$($)       "
00E298  2  6C CC              .word LAB_PPFS-1        ; LCASE$($)       "
00E29A  2  72 CC              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
00E29C  2  99 CC              .word LAB_BHSS-1        ; HEX$(n)         "
00E29E  2  99 CC              .word LAB_BHSS-1        ; BIN$(n)         "
00E2A0  2  00 00              .word $0000             ; BITTST()  none
00E2A2  2  8B DF              .word LAB_MMPP-1        ; MAX()     process numeric expression
00E2A4  2  8B DF              .word LAB_MMPP-1        ; MIN()           "
00E2A6  2  78 CC              .word LAB_PPBI-1        ; PI        advance pointer
00E2A8  2  78 CC              .word LAB_PPBI-1        ; TWOPI           "
00E2AA  2  00 00              .word $0000             ; VARPTR()  none
00E2AC  2  7D CC              .word LAB_LRMS-1        ; LEFT$()   process string expression
00E2AE  2  7D CC              .word LAB_LRMS-1        ; RIGHT$()        "
00E2B0  2  7D CC              .word LAB_LRMS-1        ; MID$()          "
00E2B2  2               
00E2B2  2               ; action addresses for functions
00E2B2  2               
00E2B2  2               LAB_FTBL:
00E2B2  2               LAB_FTBM    = LAB_FTBL+$01
00E2B2  2  03 D9              .word LAB_SGN-1         ; SGN()
00E2B4  2  8D D9              .word LAB_INT-1         ; INT()
00E2B6  2  20 D9              .word LAB_ABS-1         ; ABS()
00E2B8  2  59 DD              .word LAB_USR-1         ; USR()
00E2BA  2  52 D0              .word LAB_FRE-1         ; FRE()
00E2BC  2  71 D0              .word LAB_POS-1         ; POS()
00E2BE  2  4A E0              .word LAB_SQR-1         ; SQR()
00E2C0  2  A9 DC              .word LAB_RND-1         ; RND()           modified function
00E2C2  2  07 D7              .word LAB_LOG-1         ; LOG()
00E2C4  2  0B DC              .word LAB_EXP-1         ; EXP()
00E2C6  2  DD DC              .word LAB_COS-1         ; COS()
00E2C8  2  E4 DC              .word LAB_SIN-1         ; SIN()
00E2CA  2  2D DD              .word LAB_TAN-1         ; TAN()
00E2CC  2  5F DD              .word LAB_ATN-1         ; ATN()
00E2CE  2  0F D5              .word LAB_PEEK-1        ; PEEK()
00E2D0  2  23 D5              .word LAB_DEEK-1        ; DEEK()          new function
00E2D2  2  68 D4              .word LAB_SADD-1        ; SADD()          new function
00E2D4  2  81 D4              .word LAB_LENS-1        ; LEN()
00E2D6  2  33 D1              .word LAB_STRS-1        ; STR$()
00E2D8  2  AE D4              .word LAB_VAL-1         ; VAL()
00E2DA  2  8C D4              .word LAB_ASC-1         ; ASC()
00E2DC  2  46 D4              .word LAB_UCASE-1       ; UCASE$()        new function
00E2DE  2  25 D4              .word LAB_LCASE-1       ; LCASE$()        new function
00E2E0  2  97 D3              .word LAB_CHRS-1        ; CHR$()
00E2E2  2  2F DE              .word LAB_HEXS-1        ; HEX$()          new function
00E2E4  2  E0 DD              .word LAB_BINS-1        ; BIN$()          new function
00E2E6  2  B8 DD              .word LAB_BTST-1        ; BITTST()        new function
00E2E8  2  91 DF              .word LAB_MAX-1         ; MAX()           new function
00E2EA  2  A1 DF              .word LAB_MIN-1         ; MIN()           new function
00E2EC  2  E7 E0              .word LAB_PI-1          ; PI              new function
00E2EE  2  F1 E0              .word LAB_TWOPI-1       ; TWOPI           new function
00E2F0  2  D7 E0              .word LAB_VARPTR-1      ; VARPTR()        new function
00E2F2  2  A9 D3              .word LAB_LEFT-1        ; LEFT$()
00E2F4  2  B2 D3              .word LAB_RIGHT-1       ; RIGHT$()
00E2F6  2  E1 D3              .word LAB_MIDS-1        ; MID$()
00E2F8  2               
00E2F8  2               ; hierarchy and action addresses for operator
00E2F8  2               
00E2F8  2               LAB_OPPT:
00E2F8  2  79                 .byte $79               ; +
00E2F9  2  CD D5              .word LAB_ADD-1
00E2FB  2  79                 .byte $79               ; -
00E2FC  2  B2 D5              .word LAB_SUBTRACT-1
00E2FE  2  7B                 .byte $7B               ; *
00E2FF  2  48 D7              .word LAB_MULTIPLY-1
00E301  2  7B                 .byte $7B               ; /
00E302  2  10 D8              .word LAB_DIVIDE-1
00E304  2  7F                 .byte $7F               ; ^
00E305  2  C7 DB              .word LAB_POWER-1
00E307  2  50                 .byte $50               ; AND
00E308  2  E2 CC              .word LAB_AND-1
00E30A  2  46                 .byte $46               ; EOR             new operator
00E30B  2  C8 CC              .word LAB_EOR-1
00E30D  2  46                 .byte $46               ; OR
00E30E  2  D5 CC              .word LAB_OR-1
00E310  2  56                 .byte $56               ; >>              new operator
00E311  2  8E CD              .word LAB_RSHIFT-1
00E313  2  56                 .byte $56               ; <<              new operator
00E314  2  76 CD              .word LAB_LSHIFT-1
00E316  2  7D                 .byte $7D               ; >
00E317  2  00 DC              .word LAB_GTHAN-1
00E319  2  5A                 .byte $5A               ; =
00E31A  2  16 CC              .word LAB_EQUAL-1
00E31C  2  64                 .byte $64               ; <
00E31D  2  03 CD              .word LAB_LTHAN-1
00E31F  2               
00E31F  2               ; keywords start with ..
00E31F  2               ; this is the first character table and must be in alphabetic order
00E31F  2               
00E31F  2               TAB_1STC:
00E31F  2  2A                 .byte "*"
00E320  2  2B                 .byte "+"
00E321  2  2D                 .byte "-"
00E322  2  2F                 .byte "/"
00E323  2  3C                 .byte "<"
00E324  2  3D                 .byte "="
00E325  2  3E                 .byte ">"
00E326  2  3F                 .byte "?"
00E327  2  41                 .byte "A"
00E328  2  42                 .byte "B"
00E329  2  43                 .byte "C"
00E32A  2  44                 .byte "D"
00E32B  2  45                 .byte "E"
00E32C  2  46                 .byte "F"
00E32D  2  47                 .byte "G"
00E32E  2  48                 .byte "H"
00E32F  2  49                 .byte "I"
00E330  2  4C                 .byte "L"
00E331  2  4D                 .byte "M"
00E332  2  4E                 .byte "N"
00E333  2  4F                 .byte "O"
00E334  2  50                 .byte "P"
00E335  2  52                 .byte "R"
00E336  2  53                 .byte "S"
00E337  2  54                 .byte "T"
00E338  2  55                 .byte "U"
00E339  2  56                 .byte "V"
00E33A  2  57                 .byte "W"
00E33B  2  5E                 .byte "^"
00E33C  2  00                 .byte $00               ; table terminator
00E33D  2               
00E33D  2               ; pointers to keyword tables
00E33D  2               
00E33D  2               TAB_CHRT:
00E33D  2  77 E3              .word TAB_STAR          ; table for "*"
00E33F  2  79 E3              .word TAB_PLUS          ; table for "+"
00E341  2  7B E3              .word TAB_MNUS          ; table for "-"
00E343  2  7D E3              .word TAB_SLAS          ; table for "/"
00E345  2  7F E3              .word TAB_LESS          ; table for "<"
00E347  2  83 E3              .word TAB_EQUL          ; table for "="
00E349  2  85 E3              .word TAB_MORE          ; table for ">"
00E34B  2  89 E3              .word TAB_QEST          ; table for "?"
00E34D  2  8B E3              .word TAB_ASCA          ; table for "A"
00E34F  2  9B E3              .word TAB_ASCB          ; table for "B"
00E351  2  B4 E3              .word TAB_ASCC          ; table for "C"
00E353  2  CB E3              .word TAB_ASCD          ; table for "D"
00E355  2  E4 E3              .word TAB_ASCE          ; table for "E"
00E357  2  F3 E3              .word TAB_ASCF          ; table for "F"
00E359  2  FD E3              .word TAB_ASCG          ; table for "G"
00E35B  2  0A E4              .word TAB_ASCH          ; table for "H"
00E35D  2  10 E4              .word TAB_ASCI          ; table for "I"
00E35F  2  22 E4              .word TAB_ASCL          ; table for "L"
00E361  2  47 E4              .word TAB_ASCM          ; table for "M"
00E363  2  55 E4              .word TAB_ASCN          ; table for "N"
00E365  2  67 E4              .word TAB_ASCO          ; table for "O"
00E367  2  6F E4              .word TAB_ASCP          ; table for "P"
00E369  2  84 E4              .word TAB_ASCR          ; table for "R"
00E36B  2  B3 E4              .word TAB_ASCS          ; table for "S"
00E36D  2  DE E4              .word TAB_ASCT          ; table for "T"
00E36F  2  F2 E4              .word TAB_ASCU          ; table for "U"
00E371  2  03 E5              .word TAB_ASCV          ; table for "V"
00E373  2  0F E5              .word TAB_ASCW          ; table for "W"
00E375  2  1E E5              .word TAB_POWR          ; table for "^"
00E377  2               
00E377  2               ; tables for each start character, note if a longer keyword with the same start
00E377  2               ; letters as a shorter one exists then it must come first, else the list is in
00E377  2               ; alphabetical order as follows ..
00E377  2               
00E377  2               ; [keyword,token
00E377  2               ; [keyword,token]]
00E377  2               ; end marker (#$00)
00E377  2               
00E377  2               TAB_STAR:
00E377  2  B8 00              .byte TK_MUL,$00        ; *
00E379  2               TAB_PLUS:
00E379  2  B6 00              .byte TK_PLUS,$00       ; +
00E37B  2               TAB_MNUS:
00E37B  2  B7 00              .byte TK_MINUS,$00      ; -
00E37D  2               TAB_SLAS:
00E37D  2  B9 00              .byte TK_DIV,$00        ; /
00E37F  2               TAB_LESS:
00E37F  2               LBB_LSHIFT:
00E37F  2  3C BF              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
00E381  2  C2                 .byte TK_LT             ; <
00E382  2  00                 .byte $00
00E383  2               TAB_EQUL:
00E383  2  C1 00              .byte TK_EQUAL,$00      ; =
00E385  2               TAB_MORE:
00E385  2               LBB_RSHIFT:
00E385  2  3E BE              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
00E387  2  C0                 .byte TK_GT             ; >
00E388  2  00                 .byte $00
00E389  2               TAB_QEST:
00E389  2  9F 00              .byte TK_PRINT,$00      ; ?
00E38B  2               TAB_ASCA:
00E38B  2               LBB_ABS:
00E38B  2  42 53 28 C5        .byte "BS(",TK_ABS      ; ABS(
00E38F  2               LBB_AND:
00E38F  2  4E 44 BB           .byte "ND",TK_AND       ; AND
00E392  2               LBB_ASC:
00E392  2  53 43 28 D7        .byte "SC(",TK_ASC      ; ASC(
00E396  2               LBB_ATN:
00E396  2  54 4E 28 D0        .byte "TN(",TK_ATN      ; ATN(
00E39A  2  00                 .byte $00
00E39B  2               TAB_ASCB:
00E39B  2               LBB_BINS:
00E39B  2  49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
00E39F  2  DC           
00E3A0  2               LBB_BITCLR:
00E3A0  2  49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
00E3A4  2  52 A8        
00E3A6  2               LBB_BITSET:
00E3A6  2  49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
00E3AA  2  54 A7        
00E3AC  2               LBB_BITTST:
00E3AC  2  49 54 54 53        .byte "ITTST(",TK_BITTST
00E3B0  2  54 28 DD     
00E3B3  2                                             ; BITTST(
00E3B3  2  00                 .byte $00
00E3B4  2               TAB_ASCC:
00E3B4  2               LBB_CALL:
00E3B4  2  41 4C 4C 9C        .byte "ALL",TK_CALL     ; CALL
00E3B8  2               LBB_CHRS:
00E3B8  2  48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
00E3BC  2  DA           
00E3BD  2               LBB_CLEAR:
00E3BD  2  4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
00E3C1  2  A2           
00E3C2  2               LBB_CONT:
00E3C2  2  4F 4E 54 A0        .byte "ONT",TK_CONT     ; CONT
00E3C6  2               LBB_COS:
00E3C6  2  4F 53 28 CD        .byte "OS(",TK_COS      ; COS(
00E3CA  2  00                 .byte $00
00E3CB  2               TAB_ASCD:
00E3CB  2               LBB_DATA:
00E3CB  2  41 54 41 83        .byte "ATA",TK_DATA     ; DATA
00E3CF  2               LBB_DEC:
00E3CF  2  45 43 88           .byte "EC",TK_DEC       ; DEC
00E3D2  2               LBB_DEEK:
00E3D2  2  45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
00E3D6  2  D2           
00E3D7  2               LBB_DEF:
00E3D7  2  45 46 99           .byte "EF",TK_DEF       ; DEF
00E3DA  2               LBB_DIM:
00E3DA  2  49 4D 85           .byte "IM",TK_DIM       ; DIM
00E3DD  2               LBB_DOKE:
00E3DD  2  4F 4B 45 9B        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
00E3E1  2               LBB_DO:
00E3E1  2  4F 9D              .byte "O",TK_DO         ; DO
00E3E3  2  00                 .byte $00
00E3E4  2               TAB_ASCE:
00E3E4  2               LBB_ELSE:
00E3E4  2  4C 53 45 AC        .byte "LSE",TK_ELSE     ; ELSE
00E3E8  2               LBB_END:
00E3E8  2  4E 44 80           .byte "ND",TK_END       ; END
00E3EB  2               LBB_EOR:
00E3EB  2  4F 52 BC           .byte "OR",TK_EOR       ; EOR
00E3EE  2               LBB_EXP:
00E3EE  2  58 50 28 CC        .byte "XP(",TK_EXP      ; EXP(
00E3F2  2  00                 .byte $00
00E3F3  2               TAB_ASCF:
00E3F3  2               LBB_FN:
00E3F3  2  4E AE              .byte "N",TK_FN         ; FN
00E3F5  2               LBB_FOR:
00E3F5  2  4F 52 81           .byte "OR",TK_FOR       ; FOR
00E3F8  2               LBB_FRE:
00E3F8  2  52 45 28 C7        .byte "RE(",TK_FRE      ; FRE(
00E3FC  2  00                 .byte $00
00E3FD  2               TAB_ASCG:
00E3FD  2               LBB_GET:
00E3FD  2  45 54 A5           .byte "ET",TK_GET       ; GET
00E400  2               LBB_GOSUB:
00E400  2  4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
00E404  2  8D           
00E405  2               LBB_GOTO:
00E405  2  4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
00E409  2  00                 .byte $00
00E40A  2               TAB_ASCH:
00E40A  2               LBB_HEXS:
00E40A  2  45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
00E40E  2  DB           
00E40F  2  00                 .byte $00
00E410  2               TAB_ASCI:
00E410  2               LBB_IF:
00E410  2  46 8B              .byte "F",TK_IF         ; IF
00E412  2               LBB_INC:
00E412  2  4E 43 95           .byte "NC",TK_INC       ; INC
00E415  2               LBB_INPUT:
00E415  2  4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
00E419  2  84           
00E41A  2               LBB_INT:
00E41A  2  4E 54 28 C4        .byte "NT(",TK_INT      ; INT(
00E41E  2               LBB_IRQ:
00E41E  2  52 51 A9           .byte "RQ",TK_IRQ       ; IRQ
00E421  2  00                 .byte $00
00E422  2               TAB_ASCL:
00E422  2               LBB_LCASES:
00E422  2  43 41 53 45        .byte "CASE$(",TK_LCASES
00E426  2  24 28 D9     
00E429  2                                             ; LCASE$(
00E429  2               LBB_LEFTS:
00E429  2  45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
00E42D  2  28 E3        
00E42F  2               LBB_LEN:
00E42F  2  45 4E 28 D4        .byte "EN(",TK_LEN      ; LEN(
00E433  2               LBB_LET:
00E433  2  45 54 87           .byte "ET",TK_LET       ; LET
00E436  2               LBB_LIST:
00E436  2  49 53 54 A1        .byte "IST",TK_LIST     ; LIST
00E43A  2               LBB_LOAD:
00E43A  2  4F 41 44 97        .byte "OAD",TK_LOAD     ; LOAD
00E43E  2               LBB_LOG:
00E43E  2  4F 47 28 CB        .byte "OG(",TK_LOG      ; LOG(
00E442  2               LBB_LOOP:
00E442  2  4F 4F 50 9E        .byte "OOP",TK_LOOP     ; LOOP
00E446  2  00                 .byte $00
00E447  2               TAB_ASCM:
00E447  2               LBB_MAX:
00E447  2  41 58 28 DE        .byte "AX(",TK_MAX      ; MAX(
00E44B  2               LBB_MIDS:
00E44B  2  49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
00E44F  2  E5           
00E450  2               LBB_MIN:
00E450  2  49 4E 28 DF        .byte "IN(",TK_MIN      ; MIN(
00E454  2  00                 .byte $00
00E455  2               TAB_ASCN:
00E455  2               LBB_NEW:
00E455  2  45 57 A3           .byte "EW",TK_NEW       ; NEW
00E458  2               LBB_NEXT:
00E458  2  45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
00E45C  2               LBB_NMI:
00E45C  2  4D 49 AA           .byte "MI",TK_NMI       ; NMI
00E45F  2               LBB_NOT:
00E45F  2  4F 54 B1           .byte "OT",TK_NOT       ; NOT
00E462  2               LBB_NULL:
00E462  2  55 4C 4C 94        .byte "ULL",TK_NULL     ; NULL
00E466  2  00                 .byte $00
00E467  2               TAB_ASCO:
00E467  2               LBB_OFF:
00E467  2  46 46 B5           .byte "FF",TK_OFF       ; OFF
00E46A  2               LBB_ON:
00E46A  2  4E 93              .byte "N",TK_ON         ; ON
00E46C  2               LBB_OR:
00E46C  2  52 BD              .byte "R",TK_OR         ; OR
00E46E  2  00                 .byte $00
00E46F  2               TAB_ASCP:
00E46F  2               LBB_PEEK:
00E46F  2  45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
00E473  2  D1           
00E474  2               LBB_PI:
00E474  2  49 E0              .byte "I",TK_PI         ; PI
00E476  2               LBB_POKE:
00E476  2  4F 4B 45 9A        .byte "OKE",TK_POKE     ; POKE
00E47A  2               LBB_POS:
00E47A  2  4F 53 28 C8        .byte "OS(",TK_POS      ; POS(
00E47E  2               LBB_PRINT:
00E47E  2  52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
00E482  2  9F           
00E483  2  00                 .byte $00
00E484  2               TAB_ASCR:
00E484  2               LBB_READ:
00E484  2  45 41 44 86        .byte "EAD",TK_READ     ; READ
00E488  2               LBB_REM:
00E488  2  45 4D 91           .byte "EM",TK_REM       ; REM
00E48B  2               LBB_RESTORE:
00E48B  2  45 53 54 4F        .byte "ESTORE",TK_RESTORE
00E48F  2  52 45 8C     
00E492  2                                             ; RESTORE
00E492  2               LBB_RETIRQ:
00E492  2  45 54 49 52        .byte "ETIRQ",TK_RETIRQ ; RETIRQ
00E496  2  51 8E        
00E498  2               LBB_RETNMI:
00E498  2  45 54 4E 4D        .byte "ETNMI",TK_RETNMI ; RETNMI
00E49C  2  49 8F        
00E49E  2               LBB_RETURN:
00E49E  2  45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
00E4A2  2  4E 90        
00E4A4  2               LBB_RIGHTS:
00E4A4  2  49 47 48 54        .byte "IGHT$(",TK_RIGHTS
00E4A8  2  24 28 E4     
00E4AB  2                                             ; RIGHT$(
00E4AB  2               LBB_RND:
00E4AB  2  4E 44 28 CA        .byte "ND(",TK_RND      ; RND(
00E4AF  2               LBB_RUN:
00E4AF  2  55 4E 8A           .byte "UN",TK_RUN       ; RUN
00E4B2  2  00                 .byte $00
00E4B3  2               TAB_ASCS:
00E4B3  2               LBB_SADD:
00E4B3  2  41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
00E4B7  2  D3           
00E4B8  2               LBB_SAVE:
00E4B8  2  41 56 45 98        .byte "AVE",TK_SAVE     ; SAVE
00E4BC  2               LBB_SGN:
00E4BC  2  47 4E 28 C3        .byte "GN(",TK_SGN      ; SGN(
00E4C0  2               LBB_SIN:
00E4C0  2  49 4E 28 CE        .byte "IN(",TK_SIN      ; SIN(
00E4C4  2               LBB_SPC:
00E4C4  2  50 43 28 AF        .byte "PC(",TK_SPC      ; SPC(
00E4C8  2               LBB_SQR:
00E4C8  2  51 52 28 C9        .byte "QR(",TK_SQR      ; SQR(
00E4CC  2               LBB_STEP:
00E4CC  2  54 45 50 B2        .byte "TEP",TK_STEP     ; STEP
00E4D0  2               LBB_STOP:
00E4D0  2  54 4F 50 92        .byte "TOP",TK_STOP     ; STOP
00E4D4  2               LBB_STRS:
00E4D4  2  54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
00E4D8  2  D5           
00E4D9  2               LBB_SWAP:
00E4D9  2  57 41 50 A6        .byte "WAP",TK_SWAP     ; SWAP
00E4DD  2  00                 .byte $00
00E4DE  2               TAB_ASCT:
00E4DE  2               LBB_TAB:
00E4DE  2  41 42 28 AB        .byte "AB(",TK_TAB      ; TAB(
00E4E2  2               LBB_TAN:
00E4E2  2  41 4E 28 CF        .byte "AN(",TK_TAN      ; TAN(
00E4E6  2               LBB_THEN:
00E4E6  2  48 45 4E B0        .byte "HEN",TK_THEN     ; THEN
00E4EA  2               LBB_TO:
00E4EA  2  4F AD              .byte "O",TK_TO         ; TO
00E4EC  2               LBB_TWOPI:
00E4EC  2  57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
00E4F0  2  E1           
00E4F1  2  00                 .byte $00
00E4F2  2               TAB_ASCU:
00E4F2  2               LBB_UCASES:
00E4F2  2  43 41 53 45        .byte "CASE$(",TK_UCASES
00E4F6  2  24 28 D8     
00E4F9  2                                             ; UCASE$(
00E4F9  2               LBB_UNTIL:
00E4F9  2  4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
00E4FD  2  B3           
00E4FE  2               LBB_USR:
00E4FE  2  53 52 28 C6        .byte "SR(",TK_USR      ; USR(
00E502  2  00                 .byte $00
00E503  2               TAB_ASCV:
00E503  2               LBB_VAL:
00E503  2  41 4C 28 D6        .byte "AL(",TK_VAL      ; VAL(
00E507  2               LBB_VPTR:
00E507  2  41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
00E50B  2  52 28 E2     
00E50E  2  00                 .byte $00
00E50F  2               TAB_ASCW:
00E50F  2               LBB_WAIT:
00E50F  2  41 49 54 96        .byte "AIT",TK_WAIT     ; WAIT
00E513  2               LBB_WHILE:
00E513  2  48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
00E517  2  B4           
00E518  2               LBB_WIDTH:
00E518  2  49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
00E51C  2  A4           
00E51D  2  00                 .byte $00
00E51E  2               TAB_POWR:
00E51E  2  BA 00              .byte TK_POWER,$00      ; ^
00E520  2               
00E520  2               ; new decode table for LIST
00E520  2               ; Table is ..
00E520  2               ; byte - keyword length, keyword first character
00E520  2               ; word - pointer to rest of keyword from dictionary
00E520  2               
00E520  2               ; note if length is 1 then the pointer is ignored
00E520  2               
00E520  2               LAB_KEYT:
00E520  2  03 45              .byte 3,'E'
00E522  2  E8 E3              .word LBB_END           ; END
00E524  2  03 46              .byte 3,'F'
00E526  2  F5 E3              .word LBB_FOR           ; FOR
00E528  2  04 4E              .byte 4,'N'
00E52A  2  58 E4              .word LBB_NEXT          ; NEXT
00E52C  2  04 44              .byte 4,'D'
00E52E  2  CB E3              .word LBB_DATA          ; DATA
00E530  2  05 49              .byte 5,'I'
00E532  2  15 E4              .word LBB_INPUT         ; INPUT
00E534  2  03 44              .byte 3,'D'
00E536  2  DA E3              .word LBB_DIM           ; DIM
00E538  2  04 52              .byte 4,'R'
00E53A  2  84 E4              .word LBB_READ          ; READ
00E53C  2  03 4C              .byte 3,'L'
00E53E  2  33 E4              .word LBB_LET           ; LET
00E540  2  03 44              .byte 3,'D'
00E542  2  CF E3              .word LBB_DEC           ; DEC
00E544  2  04 47              .byte 4,'G'
00E546  2  05 E4              .word LBB_GOTO          ; GOTO
00E548  2  03 52              .byte 3,'R'
00E54A  2  AF E4              .word LBB_RUN           ; RUN
00E54C  2  02 49              .byte 2,'I'
00E54E  2  10 E4              .word LBB_IF            ; IF
00E550  2  07 52              .byte 7,'R'
00E552  2  8B E4              .word LBB_RESTORE       ; RESTORE
00E554  2  05 47              .byte 5,'G'
00E556  2  00 E4              .word LBB_GOSUB         ; GOSUB
00E558  2  06 52              .byte 6,'R'
00E55A  2  92 E4              .word LBB_RETIRQ        ; RETIRQ
00E55C  2  06 52              .byte 6,'R'
00E55E  2  98 E4              .word LBB_RETNMI        ; RETNMI
00E560  2  06 52              .byte 6,'R'
00E562  2  9E E4              .word LBB_RETURN        ; RETURN
00E564  2  03 52              .byte 3,'R'
00E566  2  88 E4              .word LBB_REM           ; REM
00E568  2  04 53              .byte 4,'S'
00E56A  2  D0 E4              .word LBB_STOP          ; STOP
00E56C  2  02 4F              .byte 2,'O'
00E56E  2  6A E4              .word LBB_ON            ; ON
00E570  2  04 4E              .byte 4,'N'
00E572  2  62 E4              .word LBB_NULL          ; NULL
00E574  2  03 49              .byte 3,'I'
00E576  2  12 E4              .word LBB_INC           ; INC
00E578  2  04 57              .byte 4,'W'
00E57A  2  0F E5              .word LBB_WAIT          ; WAIT
00E57C  2  04 4C              .byte 4,'L'
00E57E  2  3A E4              .word LBB_LOAD          ; LOAD
00E580  2  04 53              .byte 4,'S'
00E582  2  B8 E4              .word LBB_SAVE          ; SAVE
00E584  2  03 44              .byte 3,'D'
00E586  2  D7 E3              .word LBB_DEF           ; DEF
00E588  2  04 50              .byte 4,'P'
00E58A  2  76 E4              .word LBB_POKE          ; POKE
00E58C  2  04 44              .byte 4,'D'
00E58E  2  DD E3              .word LBB_DOKE          ; DOKE
00E590  2  04 43              .byte 4,'C'
00E592  2  B4 E3              .word LBB_CALL          ; CALL
00E594  2  02 44              .byte 2,'D'
00E596  2  E1 E3              .word LBB_DO            ; DO
00E598  2  04 4C              .byte 4,'L'
00E59A  2  42 E4              .word LBB_LOOP          ; LOOP
00E59C  2  05 50              .byte 5,'P'
00E59E  2  7E E4              .word LBB_PRINT         ; PRINT
00E5A0  2  04 43              .byte 4,'C'
00E5A2  2  C2 E3              .word LBB_CONT          ; CONT
00E5A4  2  04 4C              .byte 4,'L'
00E5A6  2  36 E4              .word LBB_LIST          ; LIST
00E5A8  2  05 43              .byte 5,'C'
00E5AA  2  BD E3              .word LBB_CLEAR         ; CLEAR
00E5AC  2  03 4E              .byte 3,'N'
00E5AE  2  55 E4              .word LBB_NEW           ; NEW
00E5B0  2  05 57              .byte 5,'W'
00E5B2  2  18 E5              .word LBB_WIDTH         ; WIDTH
00E5B4  2  03 47              .byte 3,'G'
00E5B6  2  FD E3              .word LBB_GET           ; GET
00E5B8  2  04 53              .byte 4,'S'
00E5BA  2  D9 E4              .word LBB_SWAP          ; SWAP
00E5BC  2  06 42              .byte 6,'B'
00E5BE  2  A6 E3              .word LBB_BITSET        ; BITSET
00E5C0  2  06 42              .byte 6,'B'
00E5C2  2  A0 E3              .word LBB_BITCLR        ; BITCLR
00E5C4  2  03 49              .byte 3,'I'
00E5C6  2  1E E4              .word LBB_IRQ           ; IRQ
00E5C8  2  03 4E              .byte 3,'N'
00E5CA  2  5C E4              .word LBB_NMI           ; NMI
00E5CC  2               
00E5CC  2               ; secondary commands (can't start a statement)
00E5CC  2               
00E5CC  2  04 54              .byte 4,'T'
00E5CE  2  DE E4              .word LBB_TAB           ; TAB
00E5D0  2  04 45              .byte 4,'E'
00E5D2  2  E4 E3              .word LBB_ELSE          ; ELSE
00E5D4  2  02 54              .byte 2,'T'
00E5D6  2  EA E4              .word LBB_TO            ; TO
00E5D8  2  02 46              .byte 2,'F'
00E5DA  2  F3 E3              .word LBB_FN            ; FN
00E5DC  2  04 53              .byte 4,'S'
00E5DE  2  C4 E4              .word LBB_SPC           ; SPC
00E5E0  2  04 54              .byte 4,'T'
00E5E2  2  E6 E4              .word LBB_THEN          ; THEN
00E5E4  2  03 4E              .byte 3,'N'
00E5E6  2  5F E4              .word LBB_NOT           ; NOT
00E5E8  2  04 53              .byte 4,'S'
00E5EA  2  CC E4              .word LBB_STEP          ; STEP
00E5EC  2  05 55              .byte 5,'U'
00E5EE  2  F9 E4              .word LBB_UNTIL         ; UNTIL
00E5F0  2  05 57              .byte 5,'W'
00E5F2  2  13 E5              .word LBB_WHILE         ; WHILE
00E5F4  2  03 4F              .byte 3,'O'
00E5F6  2  67 E4              .word LBB_OFF           ; OFF
00E5F8  2               
00E5F8  2               ; opperators
00E5F8  2               
00E5F8  2  01 2B              .byte 1,'+'
00E5FA  2  00 00              .word $0000             ; +
00E5FC  2  01 2D              .byte 1,'-'
00E5FE  2  00 00              .word $0000             ; -
00E600  2  01 2A              .byte 1,'*'
00E602  2  00 00              .word $0000             ; *
00E604  2  01 2F              .byte 1,'/'
00E606  2  00 00              .word $0000             ; /
00E608  2  01 5E              .byte 1,'^'
00E60A  2  00 00              .word $0000             ; ^
00E60C  2  03 41              .byte 3,'A'
00E60E  2  8F E3              .word LBB_AND           ; AND
00E610  2  03 45              .byte 3,'E'
00E612  2  EB E3              .word LBB_EOR           ; EOR
00E614  2  02 4F              .byte 2,'O'
00E616  2  6C E4              .word LBB_OR            ; OR
00E618  2  02 3E              .byte 2,'>'
00E61A  2  85 E3              .word LBB_RSHIFT        ; >>
00E61C  2  02 3C              .byte 2,'<'
00E61E  2  7F E3              .word LBB_LSHIFT        ; <<
00E620  2  01 3E              .byte 1,'>'
00E622  2  00 00              .word $0000             ; >
00E624  2  01 3D              .byte 1,'='
00E626  2  00 00              .word $0000             ; =
00E628  2  01 3C              .byte 1,'<'
00E62A  2  00 00              .word $0000             ; <
00E62C  2               
00E62C  2               ; functions
00E62C  2               
00E62C  2  04 53              .byte 4,'S'             ;
00E62E  2  BC E4              .word LBB_SGN           ; SGN
00E630  2  04 49              .byte 4,'I'             ;
00E632  2  1A E4              .word LBB_INT           ; INT
00E634  2  04 41              .byte 4,'A'             ;
00E636  2  8B E3              .word LBB_ABS           ; ABS
00E638  2  04 55              .byte 4,'U'             ;
00E63A  2  FE E4              .word LBB_USR           ; USR
00E63C  2  04 46              .byte 4,'F'             ;
00E63E  2  F8 E3              .word LBB_FRE           ; FRE
00E640  2  04 50              .byte 4,'P'             ;
00E642  2  7A E4              .word LBB_POS           ; POS
00E644  2  04 53              .byte 4,'S'             ;
00E646  2  C8 E4              .word LBB_SQR           ; SQR
00E648  2  04 52              .byte 4,'R'             ;
00E64A  2  AB E4              .word LBB_RND           ; RND
00E64C  2  04 4C              .byte 4,'L'             ;
00E64E  2  3E E4              .word LBB_LOG           ; LOG
00E650  2  04 45              .byte 4,'E'             ;
00E652  2  EE E3              .word LBB_EXP           ; EXP
00E654  2  04 43              .byte 4,'C'             ;
00E656  2  C6 E3              .word LBB_COS           ; COS
00E658  2  04 53              .byte 4,'S'             ;
00E65A  2  C0 E4              .word LBB_SIN           ; SIN
00E65C  2  04 54              .byte 4,'T'             ;
00E65E  2  E2 E4              .word LBB_TAN           ; TAN
00E660  2  04 41              .byte 4,'A'             ;
00E662  2  96 E3              .word LBB_ATN           ; ATN
00E664  2  05 50              .byte 5,'P'             ;
00E666  2  6F E4              .word LBB_PEEK          ; PEEK
00E668  2  05 44              .byte 5,'D'             ;
00E66A  2  D2 E3              .word LBB_DEEK          ; DEEK
00E66C  2  05 53              .byte 5,'S'             ;
00E66E  2  B3 E4              .word LBB_SADD          ; SADD
00E670  2  04 4C              .byte 4,'L'             ;
00E672  2  2F E4              .word LBB_LEN           ; LEN
00E674  2  05 53              .byte 5,'S'             ;
00E676  2  D4 E4              .word LBB_STRS          ; STR$
00E678  2  04 56              .byte 4,'V'             ;
00E67A  2  03 E5              .word LBB_VAL           ; VAL
00E67C  2  04 41              .byte 4,'A'             ;
00E67E  2  92 E3              .word LBB_ASC           ; ASC
00E680  2  07 55              .byte 7,'U'             ;
00E682  2  F2 E4              .word LBB_UCASES        ; UCASE$
00E684  2  07 4C              .byte 7,'L'             ;
00E686  2  22 E4              .word LBB_LCASES        ; LCASE$
00E688  2  05 43              .byte 5,'C'             ;
00E68A  2  B8 E3              .word LBB_CHRS          ; CHR$
00E68C  2  05 48              .byte 5,'H'             ;
00E68E  2  0A E4              .word LBB_HEXS          ; HEX$
00E690  2  05 42              .byte 5,'B'             ;
00E692  2  9B E3              .word LBB_BINS          ; BIN$
00E694  2  07 42              .byte 7,'B'             ;
00E696  2  AC E3              .word LBB_BITTST        ; BITTST
00E698  2  04 4D              .byte 4,'M'             ;
00E69A  2  47 E4              .word LBB_MAX           ; MAX
00E69C  2  04 4D              .byte 4,'M'             ;
00E69E  2  50 E4              .word LBB_MIN           ; MIN
00E6A0  2  02 50              .byte 2,'P'             ;
00E6A2  2  74 E4              .word LBB_PI            ; PI
00E6A4  2  05 54              .byte 5,'T'             ;
00E6A6  2  EC E4              .word LBB_TWOPI         ; TWOPI
00E6A8  2  07 56              .byte 7,'V'             ;
00E6AA  2  07 E5              .word LBB_VPTR          ; VARPTR
00E6AC  2  06 4C              .byte 6,'L'             ;
00E6AE  2  29 E4              .word LBB_LEFTS         ; LEFT$
00E6B0  2  07 52              .byte 7,'R'             ;
00E6B2  2  A4 E4              .word LBB_RIGHTS        ; RIGHT$
00E6B4  2  05 4D              .byte 5,'M'             ;
00E6B6  2  4B E4              .word LBB_MIDS          ; MID$
00E6B8  2               
00E6B8  2               ; BASIC messages, mostly error messages
00E6B8  2               
00E6B8  2               LAB_BAER:
00E6B8  2  DC E6              .word ERR_NF            ;$00 NEXT without FOR
00E6BA  2  ED E6              .word ERR_SN            ;$02 syntax
00E6BC  2  F4 E6              .word ERR_RG            ;$04 RETURN without GOSUB
00E6BE  2  09 E7              .word ERR_OD            ;$06 out of data
00E6C0  2  15 E7              .word ERR_FC            ;$08 function call
00E6C2  2  23 E7              .word ERR_OV            ;$0A overflow
00E6C4  2  2C E7              .word ERR_OM            ;$0C out of memory
00E6C6  2  3A E7              .word ERR_US            ;$0E undefined statement
00E6C8  2  4E E7              .word ERR_BS            ;$10 array bounds
00E6CA  2  5B E7              .word ERR_DD            ;$12 double dimension array
00E6CC  2  6C E7              .word ERR_D0            ;$14 divide by 0
00E6CE  2  7B E7              .word ERR_ID            ;$16 illegal direct
00E6D0  2  8A E7              .word ERR_TM            ;$18 type mismatch
00E6D2  2  98 E7              .word ERR_LS            ;$1A long string
00E6D4  2  A8 E7              .word ERR_ST            ;$1C string too complex
00E6D6  2  BB E7              .word ERR_CN            ;$1E continue error
00E6D8  2  CA E7              .word ERR_UF            ;$20 undefined function
00E6DA  2  DD E7              .word ERR_LD            ;$22 LOOP without DO
00E6DC  2               
00E6DC  2               ; I may implement these two errors to force definition of variables and
00E6DC  2               ; dimensioning of arrays before use.
00E6DC  2               
00E6DC  2               ;     .word ERR_UV            ;$24 undefined variable
00E6DC  2               
00E6DC  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00E6DC  2               
00E6DC  2               ;     .word ERR_UA            ;$26 undimensioned array
00E6DC  2               
00E6DC  2  4E 45 58 54  ERR_NF:      .byte "NEXT without FOR",$00
00E6E0  2  20 77 69 74  
00E6E4  2  68 6F 75 74  
00E6ED  2  53 79 6E 74  ERR_SN:      .byte "Syntax",$00
00E6F1  2  61 78 00     
00E6F4  2  52 45 54 55  ERR_RG:      .byte "RETURN without GOSUB",$00
00E6F8  2  52 4E 20 77  
00E6FC  2  69 74 68 6F  
00E709  2  4F 75 74 20  ERR_OD:      .byte "Out of DATA",$00
00E70D  2  6F 66 20 44  
00E711  2  41 54 41 00  
00E715  2  46 75 6E 63  ERR_FC:      .byte "Function call",$00
00E719  2  74 69 6F 6E  
00E71D  2  20 63 61 6C  
00E723  2  4F 76 65 72  ERR_OV:      .byte "Overflow",$00
00E727  2  66 6C 6F 77  
00E72B  2  00           
00E72C  2  4F 75 74 20  ERR_OM:      .byte "Out of memory",$00
00E730  2  6F 66 20 6D  
00E734  2  65 6D 6F 72  
00E73A  2  55 6E 64 65  ERR_US:      .byte "Undefined statement",$00
00E73E  2  66 69 6E 65  
00E742  2  64 20 73 74  
00E74E  2  41 72 72 61  ERR_BS:      .byte "Array bounds",$00
00E752  2  79 20 62 6F  
00E756  2  75 6E 64 73  
00E75B  2  44 6F 75 62  ERR_DD:      .byte "Double dimension",$00
00E75F  2  6C 65 20 64  
00E763  2  69 6D 65 6E  
00E76C  2  44 69 76 69  ERR_D0:      .byte "Divide by zero",$00
00E770  2  64 65 20 62  
00E774  2  79 20 7A 65  
00E77B  2  49 6C 6C 65  ERR_ID:      .byte "Illegal direct",$00
00E77F  2  67 61 6C 20  
00E783  2  64 69 72 65  
00E78A  2  54 79 70 65  ERR_TM:      .byte "Type mismatch",$00
00E78E  2  20 6D 69 73  
00E792  2  6D 61 74 63  
00E798  2  53 74 72 69  ERR_LS:      .byte "String too long",$00
00E79C  2  6E 67 20 74  
00E7A0  2  6F 6F 20 6C  
00E7A8  2  53 74 72 69  ERR_ST:      .byte "String too complex",$00
00E7AC  2  6E 67 20 74  
00E7B0  2  6F 6F 20 63  
00E7BB  2  43 61 6E 27  ERR_CN:      .byte "Can't continue",$00
00E7BF  2  74 20 63 6F  
00E7C3  2  6E 74 69 6E  
00E7CA  2  55 6E 64 65  ERR_UF:      .byte "Undefined function",$00
00E7CE  2  66 69 6E 65  
00E7D2  2  64 20 66 75  
00E7DD  2  4C 4F 4F 50  ERR_LD:      .byte "LOOP without DO",$00
00E7E1  2  20 77 69 74  
00E7E5  2  68 6F 75 74  
00E7ED  2               
00E7ED  2               ;ERR_UV     .byte "Undefined variable",$00
00E7ED  2               
00E7ED  2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
00E7ED  2               
00E7ED  2               ;ERR_UA     .byte "Undimensioned array",$00
00E7ED  2               
00E7ED  2  0D 0A 42 72  LAB_BMSG:    .byte $0D,$0A,"Break",$00
00E7F1  2  65 61 6B 00  
00E7F5  2  20 45 72 72  LAB_EMSG:    .byte " Error",$00
00E7F9  2  6F 72 00     
00E7FC  2  20 69 6E 20  LAB_LMSG:    .byte " in line ",$00
00E800  2  6C 69 6E 65  
00E804  2  20 00        
00E806  2  0D 0A 52 65  LAB_RMSG:    .byte $0D,$0A,"Ready",$0D,$0A,$00
00E80A  2  61 64 79 0D  
00E80E  2  0A 00        
00E810  2               
00E810  2  20 45 78 74  LAB_IMSG:    .byte " Extra ignored",$0D,$0A,$00
00E814  2  72 61 20 69  
00E818  2  67 6E 6F 72  
00E821  2  20 52 65 64  LAB_REDO:    .byte " Redo from start",$0D,$0A,$00
00E825  2  6F 20 66 72  
00E829  2  6F 6D 20 73  
00E834  2               
00E834  2  44 65 72 69  .asciiz "Derived from EhBASIC"
00E838  2  76 65 64 20  
00E83C  2  66 72 6F 6D  
00E849  2               
00E849  2               AA_end_basic:
00E849  2               
00E849  2               .segment "VEC_EHB"
00E849  2  rr rr        .word NMI
00E84B  2  rr rr        .word RESET
00E84D  2  rr rr        .word ISR
00E84F  2               
00E84F  1               
00E84F  1               .include "msbasic.s"
00E84F  2               ; Single-File Port from https://github.com/mist64/msbasic
00E84F  2               ; with some small influence by Ben Eaters fork
00E84F  2               ;
00E84F  2               ; ToDo:
00E84F  2               ;   - remove system-specific code, that doesn't match S65
00E84F  2               ;     - Investigate CBM1
00E84F  2               ;     - Investigate CBM2
00E84F  2               ;     - Investigate CONFIG_CBM_ALL
00E84F  2               ; Done:
00E84F  2               ;   - remove CONFIG_SMALL code reductions
00E84F  2               ;   - applied all CONFIG_2C and lower (most recent MS BASIC version of the repo)
00E84F  2               ;
00E84F  2               ; Goal:
00E84F  2               ; have MS Basic on a working stand as a single file to include.
00E84F  2               ; I don't care about "byte-identical" compilation
00E84F  2               
00E84F  2               .feature force_range
00E84F  2               ;.debuginfo +
00E84F  2               
00E84F  2               ;.setcpu "6502"
00E84F  2               .macpack longbranch
00E84F  3               .macro  jeq     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                       bne     *+5
00E84F  3                       jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               beq     Target
00E84F  3                       .else
00E84F  3                               bne     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               .macro  jne     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                               beq     *+5
00E84F  3                               jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               bne     Target
00E84F  3                       .else
00E84F  3                               beq     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               .macro  jmi     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                               bpl     *+5
00E84F  3                               jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               bmi     Target
00E84F  3                       .else
00E84F  3                               bpl     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               .macro  jpl     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                               bmi     *+5
00E84F  3                               jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               bpl     Target
00E84F  3                       .else
00E84F  3                               bmi     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               .macro  jcs     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                               bcc     *+5
00E84F  3                               jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               bcs     Target
00E84F  3                       .else
00E84F  3                               bcc     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               .macro  jcc     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                               bcs     *+5
00E84F  3                               jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               bcc     Target
00E84F  3                       .else
00E84F  3                               bcs     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               .macro  jvs     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                               bvc     *+5
00E84F  3                               jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               bvs     Target
00E84F  3                       .else
00E84F  3                               bvc     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               .macro  jvc     Target
00E84F  3                       .if     .match(Target, 0)
00E84F  3                               bvs     *+5
00E84F  3                               jmp     Target
00E84F  3                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
00E84F  3                               bvc     Target
00E84F  3                       .else
00E84F  3                               bvs     *+5
00E84F  3                               jmp     Target
00E84F  3                       .endif
00E84F  3               .endmacro
00E84F  3               
00E84F  2               
00E84F  2               ; MS BASIC Defines (copied from CBM2-Defines)
00E84F  2               
00E84F  2               ;CONFIG_DATAFLG := 1
00E84F  2               CONFIG_EASTER_EGG := 1
00E84F  2               ;CONFIG_FILE := 1; support PRINT#, INPUT#, GET#, CMD
00E84F  2               CONFIG_NO_CR := 1; terminal doesn't need explicit CRs on line ends
00E84F  2               ;CONFIG_NO_LINE_EDITING := 1; support for "@", "_", BEL etc.
00E84F  2               ;CONFIG_NO_READ_Y_IS_ZERO_HACK := 1
00E84F  2               ;CONFIG_PEEK_SAVE_LINNUM := 1
00E84F  2               CONFIG_SCRTCH_ORDER := 2
00E84F  2               
00E84F  2               
00E84F  2               ZP_START0 = $00
00E84F  2               ZP_START1 = $02
00E84F  2               ZP_START2 = $0C
00E84F  2               ZP_START3 = $62
00E84F  2               ZP_START4 = $6D
00E84F  2               
00E84F  2               ; extra/override ZP variables
00E84F  2               ;CURDVC			:= $000E
00E84F  2               ;TISTR			:= $008D
00E84F  2               ;Z96				:= $0096
00E84F  2               ;POSX			:= $00C6
00E84F  2               ;TXPSV			:= LASTOP
00E84F  2               USR				:= GORESTART ; XXX
00E84F  2               
00E84F  2               ;CBM2 := 1
00E84F  2               ;CONFIG_CBM_ALL := 1
00E84F  2               
00E84F  2               ; inputbuffer
00E84F  2               ;INPUTBUFFER     := $0200
00E84F  2               
00E84F  2               ; constants
00E84F  2               SPACE_FOR_GOSUB := $3E
00E84F  2               STACK_TOP		:= $FA
00E84F  2               WIDTH			:= 40
00E84F  2               WIDTH2			:= 30
00E84F  2               
00E84F  2               RAMSTART2		:= $0900
00E84F  2               
00E84F  2               ; magic memory locations
00E84F  2               ;ENTROPY = $E844
00E84F  2               
00E84F  2               ; monitor functions
00E84F  2               ;OPEN	:= $FFC0
00E84F  2               ;CLOSE	:= $FFC3
00E84F  2               ;CHKIN	:= $FFC6
00E84F  2               ;CHKOUT	:= $FFC9
00E84F  2               ;CLRCH	:= $FFCC
00E84F  2               ;LOAD	:= $FFD5
00E84F  2               ;SAVE	:= $FFD8
00E84F  2               ;VERIFY	:= $FFDB
00E84F  2               ;SYS	:= $FFDE
00E84F  2               ;ISCNTC	:= $FFE1
00E84F  2               ;GETIN	:= $FFE4
00E84F  2               ;CLALL	:= $FFE7
00E84F  2               ;LE7F3	:= $E7F3; for CBM1
00E84F  2               MONCOUT	:= CHROUT
00E84F  2               MONRDKEY := CHRIN
00E84F  2               
00E84F  2               BYTES_FP		:= 5
00E84F  2               
00E84F  2               .ifndef BYTES_PER_ELEMENT
00E84F  2               BYTES_PER_ELEMENT := BYTES_FP
00E84F  2               .endif
00E84F  2               BYTES_PER_VARIABLE := BYTES_FP+2
00E84F  2               MANTISSA_BYTES	:= BYTES_FP-1
00E84F  2               BYTES_PER_FRAME := 2*BYTES_FP+8
00E84F  2               FOR_STACK1		:= 2*BYTES_FP+5
00E84F  2               FOR_STACK2		:= BYTES_FP+4
00E84F  2               
00E84F  2               .ifndef MAX_EXPON
00E84F  2               MAX_EXPON = 10
00E84F  2               .endif
00E84F  2               
00E84F  2               STACK           := $0100
00E84F  2               .ifndef STACK2
00E84F  2               STACK2          := STACK
00E84F  2               .endif
00E84F  2               
00E84F  2               .ifdef INPUTBUFFER
00E84F  2                 .if INPUTBUFFER >= $0100
00E84F  2               CONFIG_NO_INPUTBUFFER_ZP := 1
00E84F  2                 .endif
00E84F  2                 .if INPUTBUFFER = $0200
00E84F  2               CONFIG_INPUTBUFFER_0200 := 1
00E84F  2                 .endif
00E84F  2               .endif
00E84F  2               INPUTBUFFERX = INPUTBUFFER & $FF00
00E84F  2               
00E84F  2               CR=13
00E84F  2               LF=10
00E84F  2               
00E84F  2               .ifndef CRLF_1
00E84F  2               CRLF_1 := CR
00E84F  2               CRLF_2 := LF
00E84F  2               .endif
00E84F  2               
00E84F  2               ; Macros included for MS BASIC
00E84F  2               
00E84F  2               ; htasc - set the hi bit on the last byte of a string for termination
00E84F  2               ; (by Tom Greene)
00E84F  2               .macro htasc str
00E84F  2               	.repeat	.strlen(str)-1,I
00E84F  2               		.byte	.strat(str,I)
00E84F  2               	.endrep
00E84F  2               	.byte	.strat(str,.strlen(str)-1) | $80
00E84F  2               .endmacro
00E84F  2               
00E84F  2               ; For every token, a byte gets put into segment "DUMMY".
00E84F  2               ; This way, we count up with every token. The DUMMY segment
00E84F  2               ; doesn't get linked into the binary.
00E84F  2               .macro init_token_tables
00E84F  2                       .segment "MSBVECTORS"
00E84F  2               TOKEN_ADDRESS_TABLE:
00E84F  2                       .segment "MSBKEYWORDS"
00E84F  2               TOKEN_NAME_TABLE:
00E84F  2               		.segment "MSBDUMMY"
00E84F  2               DUMMY_START:
00E84F  2               .endmacro
00E84F  2               
00E84F  2               ; optionally define token symbol
00E84F  2               ; count up token number
00E84F  2               .macro define_token token
00E84F  2                       .segment "MSBDUMMY"
00E84F  2               		.ifnblank token
00E84F  2               			token := <(*-DUMMY_START)+$80
00E84F  2               		.endif
00E84F  2               		.res 1; count up in any case
00E84F  2               .endmacro
00E84F  2               
00E84F  2               ; lay down a keyword, optionally define a token symbol
00E84F  2               .macro keyword key, token
00E84F  2               		.segment "MSBKEYWORDS"
00E84F  2               		htasc	key
00E84F  2               		define_token token
00E84F  2               .endmacro
00E84F  2               
00E84F  2               ; lay down a keyword and an address (RTS style),
00E84F  2               ; optionally define a token symbol
00E84F  2               .macro keyword_rts key, vec, token
00E84F  2                       .segment "MSBVECTORS"
00E84F  2               		.word	vec-1
00E84F  2               		keyword key, token
00E84F  2               .endmacro
00E84F  2               
00E84F  2               ; lay down a keyword and an address,
00E84F  2               ; optionally define a token symbol
00E84F  2               .macro keyword_addr key, vec, token
00E84F  2                       .segment "MSBVECTORS"
00E84F  2               		.addr	vec
00E84F  2               		keyword key, token
00E84F  2               .endmacro
00E84F  2               
00E84F  2               .macro count_tokens
00E84F  2                       .segment "MSBDUMMY"
00E84F  2               		NUM_TOKENS := <(*-DUMMY_START)
00E84F  2               .endmacro
00E84F  2               
00E84F  2               .macro init_error_table
00E84F  2                       .segment "MSBERROR"
00E84F  2               ERROR_MESSAGES:
00E84F  2               .endmacro
00E84F  2               
00E84F  2               .macro define_error error, msg
00E84F  2                       .segment "MSBERROR"
00E84F  2               		error := <(*-ERROR_MESSAGES)
00E84F  2               		htasc msg
00E84F  2               .endmacro
00E84F  2               
00E84F  2               ;---------------------------------------------
00E84F  2               ; set the MSB of every byte of a string
00E84F  2               .macro asc80 str
00E84F  2               	.repeat	.strlen(str),I
00E84F  2               		.byte	.strat(str,I)+$80
00E84F  2               	.endrep
00E84F  2               .endmacro
00E84F  2               
00E84F  2               ; MS BASIC ZP definitions
00E84F  2               
00E84F  2               .feature org_per_seg
000006r 2               .zeropage
000000r 2               
000000r 2               .org ZP_START1
000002  2               
000002  2               GORESTART:
000002  2  xx xx xx     	.res 3      ; 0
000005  2               GOSTROUT:
000005  2  xx xx xx     	.res 3      ; 3
000008  2               GOAYINT:
000008  2  xx xx        	.res 2      ; 6
00000A  2               GOGIVEAYF:
00000A  2  xx xx        	.res 2      ; 8
00000C  2               
00000C  2               .org ZP_START2
00000C  2               Z15:
00000C  2  xx           	.res 1      ; 10
00000D  2               .ifndef POSX; allow override
00000D  2               POSX:
00000D  2               .endif
00000D  2  xx           	.res 1      ; 11
00000E  2               .ifndef Z17; allow override
00000E  2               Z17:
00000E  2               .endif
00000E  2  xx           	.res 1      ; 12
00000F  2               .ifndef Z18; allow override
00000F  2               Z18:
00000F  2               .endif
00000F  2  xx           	.res 1      ; 13
000010  2               LINNUM:
000010  2               .ifndef TXPSV; allow override
000010  2               TXPSV:
000010  2               .endif
000010  2  xx xx        	.res 2      ; 14
000012  2               .ifndef INPUTBUFFER; allow override
000012  2               INPUTBUFFER:
000012  2               .endif
000012  2               
000012  2               .org ZP_START3
000062  2               
000062  2               CHARAC:
000062  2  xx           	.res 1      ; 16
000063  2               ENDCHR:
000063  2  xx           	.res 1      ; 17
000064  2               EOLPNTR:
000064  2  xx           	.res 1      ; 18
000065  2               DIMFLG:
000065  2  xx           	.res 1      ; 19
000066  2               VALTYP:
000066  2  xx xx        	.res 2      ; 20
000068  2               DATAFLG:
000068  2  xx           	.res 1      ; 22
000069  2               SUBFLG:
000069  2  xx           	.res 1      ; 23
00006A  2               INPUTFLG:
00006A  2  xx           	.res 1      ; 24
00006B  2               CPRMASK:
00006B  2  xx           	.res 1      ; 25
00006C  2               Z14:
00006C  2  xx           	.res 1      ; 26
00006D  2               
00006D  2               .org ZP_START4
00006D  2               
00006D  2               TEMPPT:
00006D  2  xx           	.res 1      ; 27
00006E  2               LASTPT:
00006E  2  xx xx        	.res 2      ; 28
000070  2               TEMPST:
000070  2  xx xx xx xx  	.res 9      ; 30
000074  2  xx xx xx xx  
000078  2  xx           
000079  2               INDEX:
000079  2  xx xx        	.res 2      ; 39
00007B  2               DEST:
00007B  2  xx xx        	.res 2      ; 41
00007D  2               RESULT:
00007D  2  xx xx xx xx  	.res BYTES_FP
000081  2  xx           
000082  2               RESULT_LAST = RESULT + BYTES_FP-1
000082  2               TXTTAB:
000082  2  xx xx        	.res 2
000084  2               VARTAB:
000084  2  xx xx        	.res 2
000086  2               ARYTAB:
000086  2  xx xx        	.res 2
000088  2               STREND:
000088  2  xx xx        	.res 2
00008A  2               FRETOP:
00008A  2  xx xx        	.res 2
00008C  2               FRESPC:
00008C  2  xx xx        	.res 2
00008E  2               MEMSIZ:
00008E  2  xx xx        	.res 2
000090  2               CURLIN:
000090  2  xx xx        	.res 2
000092  2               OLDLIN:
000092  2  xx xx        	.res 2
000094  2               OLDTEXT:
000094  2  xx xx        	.res 2
000096  2               Z8C:
000096  2  xx xx        	.res 2
000098  2               DATPTR:
000098  2  xx xx        	.res 2
00009A  2               INPTR:
00009A  2  xx xx        	.res 2
00009C  2               VARNAM:
00009C  2  xx xx        	.res 2
00009E  2               VARPNT:
00009E  2  xx xx        	.res 2
0000A0  2               FORPNT:
0000A0  2  xx xx        	.res 2
0000A2  2               LASTOP:
0000A2  2  xx xx        	.res 2
0000A4  2               CPRTYP:
0000A4  2  xx           	.res 1
0000A5  2               FNCNAM:
0000A5  2               TEMP3:
0000A5  2  xx xx        	.res 2
0000A7  2               DSCPTR:
0000A7  2  xx xx xx     		.res 3
0000AA  2               DSCLEN:
0000AA  2  xx xx        	.res 2
0000AC  2               .ifndef JMPADRS ; allow override
0000AC  2               JMPADRS			:= DSCLEN + 1
0000AC  2               .endif
0000AC  2               Z52:
0000AC  2  xx           	.res 1
0000AD  2               ARGEXTENSION:
0000AD  2  xx           	.res 1
0000AE  2               TEMP1:
0000AE  2  xx           	.res 1
0000AF  2               HIGHDS:
0000AF  2  xx xx        	.res 2
0000B1  2               HIGHTR:
0000B1  2  xx xx        	.res 2
0000B3  2               TEMP2:
0000B3  2  xx           	.res 1
0000B4  2               INDX:
0000B4  2               TMPEXP:
0000B4  2  xx           	.res 1
0000B5  2               EXPON:
0000B5  2  xx           	.res 1
0000B6  2               LOWTR:
0000B6  2               .ifndef LOWTRX ; allow override
0000B6  2               LOWTRX:
0000B6  2               .endif
0000B6  2  xx           	.res 1
0000B7  2               EXPSGN:
0000B7  2  xx           	.res 1
0000B8  2               FAC:
0000B8  2  xx xx xx xx  	.res BYTES_FP
0000BC  2  xx           
0000BD  2               FAC_LAST = FAC + BYTES_FP-1
0000BD  2               FACSIGN:
0000BD  2  xx           	.res 1
0000BE  2               SERLEN:
0000BE  2  xx           	.res 1
0000BF  2               SHIFTSIGNEXT:
0000BF  2  xx           	.res 1
0000C0  2               ARG:
0000C0  2  xx xx xx xx  	.res BYTES_FP
0000C4  2  xx           
0000C5  2               ARG_LAST = ARG + BYTES_FP-1
0000C5  2               ARGSIGN:
0000C5  2  xx           	.res 1
0000C6  2               STRNG1:
0000C6  2  xx xx        	.res 2
0000C8  2               SGNCPR = STRNG1
0000C8  2               FACEXTENSION = STRNG1+1
0000C8  2               STRNG2:
0000C8  2  xx xx        	.res 2
0000CA  2               
0000CA  2               
0000CA  2               CHRGET:
0000CA  2               TXTPTR = <(GENERIC_TXTPTR-GENERIC_CHRGET + CHRGET)
0000CA  2               CHRGOT = <(GENERIC_CHRGOT-GENERIC_CHRGET + CHRGET)
0000CA  2               CHRGOT2 = <(GENERIC_CHRGOT2-GENERIC_CHRGET + CHRGET)
0000CA  2               RNDSEED = <(GENERIC_RNDSEED-GENERIC_CHRGET + CHRGET)
0000CA  2               
0000CA  2               ;.include "S65x_conf.s"
0000CA  2               
0000CA  2               .segment "MSBHEADER"
000000r 2  4C rr rr         jmp COLD_START
000003r 2               
000003r 2               ;.include "token.s"
000003r 2               
000003r 2               		init_token_tables
000000r 2               
000000r 2  rr rr 45 4E  		keyword_rts "END", END
000004r 2  C4 xx        
000001r 2  rr rr 46 4F  		keyword_rts "FOR", FOR
000005r 2  D2 xx        
000002r 2  rr rr 4E 45  		keyword_rts "NEXT", NEXT
000006r 2  58 D4 xx     
000003r 2  rr rr 44 41  		keyword_rts "DATA", DATA
000007r 2  54 C1 xx     
000004r 2               .ifdef CONFIG_FILE
000004r 2               		keyword_rts "INPUT#", INPUTH
000004r 2               .endif
000004r 2  rr rr 49 4E  		keyword_rts "INPUT", INPUT
000008r 2  50 55 D4 xx  
000005r 2  rr rr 44 49  		keyword_rts "DIM", DIM
000009r 2  CD xx        
000006r 2  rr rr 52 45  		keyword_rts "READ", READ
00000Ar 2  41 C4 xx     
000007r 2  rr rr 4C 45  		keyword_rts "LET", LET
00000Br 2  D4 xx        
000008r 2  rr rr 47 4F  		keyword_rts "GOTO", GOTO, TOKEN_GOTO
00000Cr 2  54 CF xx     
000009r 2  rr rr 52 55  		keyword_rts "RUN", RUN
00000Dr 2  CE xx        
00000Ar 2  rr rr 49 C6  		keyword_rts "IF", IF
00000Er 2  xx           
00000Br 2  rr rr 52 45  		keyword_rts "RESTORE", RESTORE
00000Fr 2  53 54 4F 52  
000013r 2  C5 xx        
00000Cr 2  rr rr 47 4F  		keyword_rts "GOSUB", GOSUB, TOKEN_GOSUB
000010r 2  53 55 C2 xx  
00000Dr 2  rr rr 52 45  		keyword_rts "RETURN", POP
000011r 2  54 55 52 CE  
000015r 2  xx           
00000Er 2  rr rr 52 45  		keyword_rts "REM", REM, TOKEN_REM
000012r 2  CD xx        
00000Fr 2  rr rr 53 54  		keyword_rts "STOP", STOP
000013r 2  4F D0 xx     
000010r 2  rr rr 4F CE  		keyword_rts "ON", ON
000014r 2  xx           
000011r 2               ;.ifdef CONFIG_NULL
000011r 2               ;		keyword_rts "NULL", NULL
000011r 2               ;.endif
000011r 2               .ifndef CONFIG_NO_POKE
000011r 2  rr rr 57 41  		keyword_rts "WAIT", WAIT
000015r 2  49 D4 xx     
000012r 2               .endif
000012r 2  rr rr 4C 4F  		keyword_rts "LOAD", LOAD
000016r 2  41 C4 xx     
000013r 2  rr rr 53 41  		keyword_rts "SAVE", SAVE
000017r 2  56 C5 xx     
000014r 2               ;.ifdef CONFIG_CBM_ALL
000014r 2               ;		keyword_rts "VERIFY", VERIFY
000014r 2               ;.endif
000014r 2  rr rr 44 45  		keyword_rts "DEF", DEF
000018r 2  C6 xx        
000015r 2               .ifndef CONFIG_NO_POKE
000015r 2  rr rr 50 4F  		keyword_rts "POKE", POKE
000019r 2  4B C5 xx     
000016r 2               .endif
000016r 2               .ifdef CONFIG_FILE
000016r 2               		keyword_rts "PRINT#", PRINTH
000016r 2               .endif
000016r 2  rr rr 50 52  		keyword_rts "PRINT", PRINT, TOKEN_PRINT
00001Ar 2  49 4E D4 xx  
000017r 2  rr rr 43 4F  		keyword_rts "CONT", CONT
00001Br 2  4E D4 xx     
000018r 2  rr rr 4C 49  		keyword_rts "LIST", LIST
00001Cr 2  53 D4 xx     
000019r 2               ;.ifdef CONFIG_CBM_ALL
000019r 2               ;		keyword_rts "CLR", CLEAR
000019r 2               ;.else
000019r 2  rr rr 43 4C  		keyword_rts "CLEAR", CLEAR
00001Dr 2  45 41 D2 xx  
00001Ar 2               ;.endif
00001Ar 2               .ifdef CONFIG_FILE
00001Ar 2               		keyword_rts "CMD", CMD
00001Ar 2               		keyword_rts "SYS", SYS
00001Ar 2               		keyword_rts "OPEN", OPEN
00001Ar 2               		keyword_rts "CLOSE", CLOSE
00001Ar 2               .endif
00001Ar 2  rr rr 47 45  		keyword_rts "GET", GET
00001Er 2  D4 xx        
00001Br 2  rr rr 4E 45  		keyword_rts "NEW", NEW
00001Fr 2  D7 xx        
00001Cr 2               
00001Cr 2               		count_tokens
00001Cr 2               
00001Cr 2  54 41 42 A8  		keyword	"TAB(", TOKEN_TAB
000020r 2  xx           
00001Dr 2  54 CF xx     		keyword	"TO", TOKEN_TO
00001Er 2  46 CE xx     		keyword	"FN", TOKEN_FN
00001Fr 2  53 50 43 A8  		keyword	"SPC(", TOKEN_SPC
000023r 2  xx           
000020r 2  54 48 45 CE  		keyword	"THEN", TOKEN_THEN
000024r 2  xx           
000021r 2  4E 4F D4 xx  		keyword	"NOT", TOKEN_NOT
000022r 2  53 54 45 D0  		keyword	"STEP", TOKEN_STEP
000026r 2  xx           
000023r 2  AB xx        		keyword	"+", TOKEN_PLUS
000024r 2  AD xx        		keyword	"-", TOKEN_MINUS
000025r 2  AA xx        		keyword	"*"
000026r 2  AF xx        		keyword	"/"
000027r 2  DE xx        		keyword	"^"
000028r 2  41 4E C4 xx  		keyword	"AND"
000029r 2  4F D2 xx     		keyword	"OR"
00002Ar 2  BE xx        		keyword	">", TOKEN_GREATER
00002Br 2  BD xx        		keyword	"=", TOKEN_EQUAL
00002Cr 2  BC xx        		keyword	"<"
00002Dr 2               
00002Dr 2                       .segment "MSBVECTORS"
000038r 2               UNFNC:
000038r 2               
000038r 2  rr rr 53 47  		keyword_addr "SGN", SGN, TOKEN_SGN
00003Cr 2  CE xx        
00002Er 2  rr rr 49 4E  		keyword_addr "INT", INT
000032r 2  D4 xx        
00002Fr 2  rr rr 41 42  		keyword_addr "ABS", ABS
000033r 2  D3 xx        
000030r 2               .ifndef CONFIG_NO_POKE
000030r 2                 .ifdef CONFIG_RAM
000030r 2               		keyword_addr "USR", IQERR
000030r 2                 .else
000030r 2  02 00 55 53  		keyword_addr "USR", USR, TOKEN_USR
000034r 2  D2 xx        
000031r 2                 .endif
000031r 2               .endif
000031r 2  rr rr 46 52  		keyword_addr "FRE", FRE
000035r 2  C5 xx        
000032r 2  rr rr 50 4F  		keyword_addr "POS", POS
000036r 2  D3 xx        
000033r 2  rr rr 53 51  		keyword_addr "SQR", SQR
000037r 2  D2 xx        
000034r 2  rr rr 52 4E  		keyword_addr "RND", RND
000038r 2  C4 xx        
000035r 2  rr rr 4C 4F  		keyword_addr "LOG", LOG
000039r 2  C7 xx        
000036r 2  rr rr 45 58  		keyword_addr "EXP", EXP
00003Ar 2  D0 xx        
000037r 2               .segment "MSBVECTORS"
00004Cr 2               UNFNC_COS:
00004Cr 2  rr rr 43 4F  		keyword_addr "COS", COS
000050r 2  D3 xx        
000038r 2               .segment "MSBVECTORS"
00004Er 2               UNFNC_SIN:
00004Er 2  rr rr 53 49  		keyword_addr "SIN", SIN
000052r 2  CE xx        
000039r 2               .segment "MSBVECTORS"
000050r 2               UNFNC_TAN:
000050r 2  rr rr 54 41  		keyword_addr "TAN", TAN
000054r 2  CE xx        
00003Ar 2               .segment "MSBVECTORS"
000052r 2               UNFNC_ATN:
000052r 2  rr rr 41 54  		keyword_addr "ATN", ATN
000056r 2  CE xx        
00003Br 2               .ifndef CONFIG_NO_POKE
00003Br 2  rr rr 50 45  		keyword_addr "PEEK", PEEK
00003Fr 2  45 CB xx     
00003Cr 2               .endif
00003Cr 2  rr rr 4C 45  		keyword_addr "LEN", LEN
000040r 2  CE xx        
00003Dr 2  rr rr 53 54  		keyword_addr "STR$", STR
000041r 2  52 A4 xx     
00003Er 2  rr rr 56 41  		keyword_addr "VAL", VAL
000042r 2  CC xx        
00003Fr 2  rr rr 41 53  		keyword_addr "ASC", ASC
000043r 2  C3 xx        
000040r 2  rr rr 43 48  		keyword_addr "CHR$", CHRSTR
000044r 2  52 A4 xx     
000041r 2  rr rr 4C 45  		keyword_addr "LEFT$", LEFTSTR, TOKEN_LEFTSTR
000045r 2  46 54 A4 xx  
000042r 2  rr rr 52 49  		keyword_addr "RIGHT$", RIGHTSTR
000046r 2  47 48 54 A4  
00004Ar 2  xx           
000043r 2  rr rr 4D 49  		keyword_addr "MID$", MIDSTR
000047r 2  44 A4 xx     
000044r 2  47 CF xx     		keyword	"GO", TOKEN_GO
000045r 2                       .segment "MSBKEYWORDS"
0000E0r 2  00           		.byte   0
0000E1r 2               
0000E1r 2                       .segment "MSBVECTORS"
000066r 2               MATHTBL:
000066r 2  79                   .byte   $79
000067r 2  rr rr                .word   FADDT-1
000069r 2  79                   .byte   $79
00006Ar 2  rr rr                .word   FSUBT-1
00006Cr 2  7B                   .byte   $7B
00006Dr 2  rr rr                .word   FMULTT-1
00006Fr 2  7B                   .byte   $7B
000070r 2  rr rr                .word   FDIVT-1
000072r 2  7F                   .byte   $7F
000073r 2  rr rr                .word   FPWRT-1
000075r 2  50                   .byte   $50
000076r 2  rr rr                .word   TAND-1
000078r 2  46                   .byte   $46
000079r 2  rr rr                .word   OR-1
00007Br 2  7D                   .byte   $7D
00007Cr 2  rr rr                .word   NEGOP-1
00007Er 2  5A                   .byte   $5A
00007Fr 2  rr rr                .word   EQUOP-1
000081r 2  64                   .byte   $64
000082r 2  rr rr                .word   RELOPS-1
000084r 2               
000084r 2               ; .include "error.s"
000084r 2               
000084r 2               init_error_table
000000r 2               
000000r 2  4E 45 58 54  define_error ERR_NOFOR, "NEXT WITHOUT FOR"
000004r 2  20 57 49 54  
000008r 2  48 4F 55 54  
000010r 2  53 59 4E 54  define_error ERR_SYNTAX, "SYNTAX"
000014r 2  41 D8        
000016r 2  52 45 54 55  define_error ERR_NOGOSUB, "RETURN WITHOUT GOSUB"
00001Ar 2  52 4E 20 57  
00001Er 2  49 54 48 4F  
00002Ar 2  4F 55 54 20  define_error ERR_NODATA, "OUT OF DATA"
00002Er 2  4F 46 20 44  
000032r 2  41 54 C1     
000035r 2  49 4C 4C 45  define_error ERR_ILLQTY, "ILLEGAL QUANTITY"
000039r 2  47 41 4C 20  
00003Dr 2  51 55 41 4E  
000045r 2               .ifdef CBM1
000045r 2               	.byte 0,0,0,0,0
000045r 2               .endif
000045r 2  4F 56 45 52  define_error ERR_OVERFLOW, "OVERFLOW"
000049r 2  46 4C 4F D7  
00004Dr 2  4F 55 54 20  define_error ERR_MEMFULL, "OUT OF MEMORY"
000051r 2  4F 46 20 4D  
000055r 2  45 4D 4F 52  
00005Ar 2  55 4E 44 45  define_error ERR_UNDEFSTAT, "UNDEF'D STATEMENT"
00005Er 2  46 27 44 20  
000062r 2  53 54 41 54  
00006Br 2  42 41 44 20  define_error ERR_BADSUBS, "BAD SUBSCRIPT"
00006Fr 2  53 55 42 53  
000073r 2  43 52 49 50  
000078r 2  52 45 44 49  define_error ERR_REDIMD, "REDIM'D ARRAY"
00007Cr 2  4D 27 44 20  
000080r 2  41 52 52 41  
000085r 2  44 49 56 49  define_error ERR_ZERODIV, "DIVISION BY ZERO"
000089r 2  53 49 4F 4E  
00008Dr 2  20 42 59 20  
000095r 2  49 4C 4C 45  define_error ERR_ILLDIR, "ILLEGAL DIRECT"
000099r 2  47 41 4C 20  
00009Dr 2  44 49 52 45  
0000A3r 2  54 59 50 45  define_error ERR_BADTYPE, "TYPE MISMATCH"
0000A7r 2  20 4D 49 53  
0000ABr 2  4D 41 54 43  
0000B0r 2  53 54 52 49  define_error ERR_STRLONG, "STRING TOO LONG"
0000B4r 2  4E 47 20 54  
0000B8r 2  4F 4F 20 4C  
0000BFr 2               .ifdef CONFIG_FILE
0000BFr 2                 .ifdef CBM1
0000BFr 2               define_error ERR_BADDATA, "BAD DATA"
0000BFr 2                 .else
0000BFr 2               define_error ERR_BADDATA, "FILE DATA"
0000BFr 2                 .endif
0000BFr 2               .endif
0000BFr 2  46 4F 52 4D  define_error ERR_FRMCPX, "FORMULA TOO COMPLEX"
0000C3r 2  55 4C 41 20  
0000C7r 2  54 4F 4F 20  
0000D2r 2  43 41 4E 27  define_error ERR_CANTCONT, "CAN'T CONTINUE"
0000D6r 2  54 20 43 4F  
0000DAr 2  4E 54 49 4E  
0000E0r 2  55 4E 44 45  define_error ERR_UNDEFFN, "UNDEF'D FUNCTION"
0000E4r 2  46 27 44 20  
0000E8r 2  46 55 4E 43  
0000F0r 2               
0000F0r 2               ; .include "message.s"
0000F0r 2               
0000F0r 2               ; global messages: "error", "in", "ready", "break"
0000F0r 2               
0000F0r 2               .segment "MSBCODE"
000000r 2               
000000r 2               QT_ERROR:
000000r 2  20 45 52 52      .byte   " ERROR"
000004r 2  4F 52        
000006r 2  00               .byte   0
000007r 2               
000007r 2               QT_IN:
000007r 2  20 49 4E 20      .byte   " IN "
00000Br 2  00               .byte   $00
00000Cr 2               
00000Cr 2               
00000Cr 2               QT_OK:
00000Cr 2               .ifdef CONFIG_CBM_ALL
00000Cr 2                   .byte   CR,LF,"READY.",CR,LF
00000Cr 2               .else
00000Cr 2  0D 0A 4F 4B      .byte   CR,LF,"OK",CR,LF
000010r 2  0D 0A        
000012r 2               .endif
000012r 2  00               .byte	0
000013r 2               
000013r 2               QT_BREAK:
000013r 2  0D 0A 42 52      .byte CR,LF,"BREAK"
000017r 2  45 41 4B     
00001Ar 2  00               .byte   0
00001Br 2               
00001Br 2               
00001Br 2               ; .include "memory.s"
00001Br 2               
00001Br 2               ; generic stack and memory management code
00001Br 2               ; this code is identical across all versions of
00001Br 2               ; BASIC
00001Br 2               
00001Br 2               .segment "MSBCODE"
00001Br 2               
00001Br 2               ; ----------------------------------------------------------------------------
00001Br 2               ; CALLED BY "NEXT" AND "FOR" TO SCAN THROUGH
00001Br 2               ; THE STACK FOR A FRAME WITH THE SAME VARIABLE.
00001Br 2               ;
00001Br 2               ; (FORPNT) = ADDRESS OF VARIABLE IF "FOR" OR "NEXT"
00001Br 2               ; 	= $XXFF IF CALLED FROM "RETURN"
00001Br 2               ; 	<<< BUG: SHOULD BE $FFXX >>>
00001Br 2               ;
00001Br 2               ;	RETURNS .NE. IF VARIABLE NOT FOUND,
00001Br 2               ;	(X) = STACK PNTR AFTER SKIPPING ALL FRAMES
00001Br 2               ;
00001Br 2               ;	.EQ. IF FOUND
00001Br 2               ;	(X) = STACK PNTR OF FRAME FOUND
00001Br 2               ; ----------------------------------------------------------------------------
00001Br 2               GTFORPNT:
00001Br 2  BA                   tsx
00001Cr 2  E8                   inx
00001Dr 2  E8                   inx
00001Er 2  E8                   inx
00001Fr 2  E8                   inx
000020r 2               L2279:
000020r 2  BD 01 01             lda     STACK+1,x
000023r 2  C9 81                cmp     #$81
000025r 2  D0 21                bne     L22A1
000027r 2  A5 A1                lda     FORPNT+1
000029r 2  D0 0A                bne     L228E
00002Br 2  BD 02 01             lda     STACK+2,x
00002Er 2  85 A0                sta     FORPNT
000030r 2  BD 03 01             lda     STACK+3,x
000033r 2  85 A1                sta     FORPNT+1
000035r 2               L228E:
000035r 2  DD 03 01             cmp     STACK+3,x
000038r 2  D0 07                bne     L229A
00003Ar 2  A5 A0                lda     FORPNT
00003Cr 2  DD 02 01             cmp     STACK+2,x
00003Fr 2  F0 07                beq     L22A1
000041r 2               L229A:
000041r 2  8A                   txa
000042r 2  18                   clc
000043r 2  69 12                adc     #BYTES_PER_FRAME
000045r 2  AA                   tax
000046r 2  D0 D8                bne     L2279
000048r 2               L22A1:
000048r 2  60                   rts
000049r 2               
000049r 2               ; ----------------------------------------------------------------------------
000049r 2               ; MOVE BLOCK OF MEMORY UP
000049r 2               ;
000049r 2               ; ON ENTRY:
000049r 2               ;	(Y,A) = (HIGHDS) = DESTINATION END+1
000049r 2               ;	(LOWTR) = LOWEST ADDRESS OF SOURCE
000049r 2               ;	(HIGHTR) = HIGHEST SOURCE ADDRESS+1
000049r 2               ; ----------------------------------------------------------------------------
000049r 2               BLTU:
000049r 2  20 rr rr             jsr     REASON
00004Cr 2  85 88                sta     STREND
00004Er 2  84 89                sty     STREND+1
000050r 2               BLTU2:
000050r 2  38                   sec
000051r 2  A5 B1                lda     HIGHTR
000053r 2  E5 B6                sbc     LOWTR
000055r 2  85 79                sta     INDEX
000057r 2  A8                   tay
000058r 2  A5 B2                lda     HIGHTR+1
00005Ar 2  E5 B7                sbc     LOWTR+1
00005Cr 2  AA                   tax
00005Dr 2  E8                   inx
00005Er 2  98                   tya
00005Fr 2  F0 23                beq     L22DD
000061r 2  A5 B1                lda     HIGHTR
000063r 2  38                   sec
000064r 2  E5 79                sbc     INDEX
000066r 2  85 B1                sta     HIGHTR
000068r 2  B0 03                bcs     L22C6
00006Ar 2  C6 B2                dec     HIGHTR+1
00006Cr 2  38                   sec
00006Dr 2               L22C6:
00006Dr 2  A5 AF                lda     HIGHDS
00006Fr 2  E5 79                sbc     INDEX
000071r 2  85 AF                sta     HIGHDS
000073r 2  B0 08                bcs     L22D6
000075r 2  C6 B0                dec     HIGHDS+1
000077r 2  90 04                bcc     L22D6
000079r 2               L22D2:
000079r 2  B1 B1                lda     (HIGHTR),y
00007Br 2  91 AF                sta     (HIGHDS),y
00007Dr 2               L22D6:
00007Dr 2  88                   dey
00007Er 2  D0 F9                bne     L22D2
000080r 2  B1 B1                lda     (HIGHTR),y
000082r 2  91 AF                sta     (HIGHDS),y
000084r 2               L22DD:
000084r 2  C6 B2                dec     HIGHTR+1
000086r 2  C6 B0                dec     HIGHDS+1
000088r 2  CA                   dex
000089r 2  D0 F2                bne     L22D6
00008Br 2  60                   rts
00008Cr 2               
00008Cr 2               ; ----------------------------------------------------------------------------
00008Cr 2               ; CHECK IF ENOUGH ROOM LEFT ON STACK
00008Cr 2               ; FOR "FOR", "GOSUB", OR EXPRESSION EVALUATION
00008Cr 2               ; ----------------------------------------------------------------------------
00008Cr 2               CHKMEM:
00008Cr 2  0A                   asl     a
00008Dr 2  69 3E                adc     #SPACE_FOR_GOSUB
00008Fr 2  B0 35                bcs     MEMERR
000091r 2  85 79                sta     INDEX
000093r 2  BA                   tsx
000094r 2  E4 79                cpx     INDEX
000096r 2  90 2E                bcc     MEMERR
000098r 2  60                   rts
000099r 2               
000099r 2               ; ----------------------------------------------------------------------------
000099r 2               ; CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
000099r 2               ; (Y,A) = ADDR ARRAYS NEED TO GROW TO
000099r 2               ; ----------------------------------------------------------------------------
000099r 2               REASON:
000099r 2  C4 8B                cpy     FRETOP+1
00009Br 2  90 28                bcc     L231E
00009Dr 2  D0 04                bne     L22FC
00009Fr 2  C5 8A                cmp     FRETOP
0000A1r 2  90 22                bcc     L231E
0000A3r 2               L22FC:
0000A3r 2  48                   pha
0000A4r 2  A2 09                ldx     #FAC-TEMP1-1
0000A6r 2  98                   tya
0000A7r 2               L2300:
0000A7r 2  48                   pha
0000A8r 2  B5 AE                lda     TEMP1,x
0000AAr 2  CA                   dex
0000ABr 2  10 FA                bpl     L2300
0000ADr 2  20 rr rr             jsr     GARBAG
0000B0r 2  A2 F7                ldx     #TEMP1-FAC+1
0000B2r 2               L230B:
0000B2r 2  68                   pla
0000B3r 2  95 B8                sta     FAC,x
0000B5r 2  E8                   inx
0000B6r 2  30 FA                bmi     L230B
0000B8r 2  68                   pla
0000B9r 2  A8                   tay
0000BAr 2  68                   pla
0000BBr 2  C4 8B                cpy     FRETOP+1
0000BDr 2  90 06                bcc     L231E
0000BFr 2  D0 05                bne     MEMERR
0000C1r 2  C5 8A                cmp     FRETOP
0000C3r 2  B0 01                bcs     MEMERR
0000C5r 2               L231E:
0000C5r 2  60                   rts
0000C6r 2               
0000C6r 2               ;.include "program.s"
0000C6r 2               
0000C6r 2               ; error
0000C6r 2               ; line input, line editing
0000C6r 2               ; tokenize
0000C6r 2               ; detokenize
0000C6r 2               ; BASIC program memory management
0000C6r 2               
0000C6r 2               ; MICROTAN has some nonstandard extension to LIST here
0000C6r 2               
0000C6r 2               .segment "MSBCODE"
0000C6r 2               
0000C6r 2               MEMERR:
0000C6r 2  A2 4D                ldx     #ERR_MEMFULL
0000C8r 2               
0000C8r 2               ; ----------------------------------------------------------------------------
0000C8r 2               ; HANDLE AN ERROR
0000C8r 2               ;
0000C8r 2               ; (X)=OFFSET IN ERROR MESSAGE TABLE
0000C8r 2               ; (ERRFLG) > 128 IF "ON ERR" TURNED ON
0000C8r 2               ; (CURLIN+1) = $FF IF IN DIRECT MODE
0000C8r 2               ; ----------------------------------------------------------------------------
0000C8r 2               ERROR:
0000C8r 2  46 6C                lsr     Z14
0000CAr 2               .ifdef CONFIG_FILE
0000CAr 2                       lda     CURDVC    ; output
0000CAr 2                       beq     LC366     ; is screen
0000CAr 2                       jsr     CLRCH     ; otherwise redirect output back to screen
0000CAr 2                       lda     #$00
0000CAr 2                       sta     CURDVC
0000CAr 2               LC366:
0000CAr 2               .endif
0000CAr 2  20 rr rr             jsr     CRDO
0000CDr 2  20 rr rr             jsr     OUTQUES
0000D0r 2               L2329:
0000D0r 2  BD rr rr             lda     ERROR_MESSAGES,x
0000D3r 2  48                   pha
0000D4r 2  29 7F                and     #$7F
0000D6r 2  20 rr rr             jsr     OUTDO
0000D9r 2  E8                   inx
0000DAr 2  68                   pla
0000DBr 2  10 F3                bpl     L2329
0000DDr 2  20 rr rr             jsr     STKINI
0000E0r 2  A9 rr                lda     #<QT_ERROR
0000E2r 2  A0 rr                ldy     #>QT_ERROR
0000E4r 2               
0000E4r 2               ; ----------------------------------------------------------------------------
0000E4r 2               ; PRINT STRING AT (Y,A)
0000E4r 2               ; PRINT CURRENT LINE # UNLESS IN DIRECT MODE
0000E4r 2               ; FALL INTO WARM RESTART
0000E4r 2               ; ----------------------------------------------------------------------------
0000E4r 2               PRINT_ERROR_LINNUM:
0000E4r 2  20 rr rr             jsr     STROUT
0000E7r 2  A4 91                ldy     CURLIN+1
0000E9r 2  C8                   iny
0000EAr 2  F0 03                beq     RESTART
0000ECr 2  20 rr rr             jsr     INPRT
0000EFr 2               
0000EFr 2               ; ----------------------------------------------------------------------------
0000EFr 2               ; WARM RESTART ENTRY
0000EFr 2               ; ----------------------------------------------------------------------------
0000EFr 2               RESTART:
0000EFr 2               
0000EFr 2  46 6C                lsr     Z14
0000F1r 2  A9 rr                lda     #<QT_OK
0000F3r 2  A0 rr                ldy     #>QT_OK
0000F5r 2                 .ifdef CONFIG_CBM_ALL
0000F5r 2                       jsr     STROUT
0000F5r 2                 .else
0000F5r 2  20 05 00             jsr     GOSTROUT
0000F8r 2                 .endif
0000F8r 2               L2351:
0000F8r 2  20 rr rr             jsr     INLIN
0000FBr 2  86 D1                stx     TXTPTR
0000FDr 2  84 D2                sty     TXTPTR+1
0000FFr 2  20 CA 00             jsr     CHRGET
000102r 2               ; bug in pre-1.1: CHRGET sets Z on '\0'
000102r 2               ; and ':' - a line starting with ':' in
000102r 2               ; direct mode gets ignored
000102r 2  AA                   tax
000103r 2  F0 F3                beq     L2351
000105r 2  A2 FF                ldx     #$FF
000107r 2  86 91                stx     CURLIN+1
000109r 2  90 06                bcc     NUMBERED_LINE
00010Br 2  20 rr rr             jsr     PARSE_INPUT_LINE
00010Er 2  4C rr rr             jmp     NEWSTT2
000111r 2               
000111r 2               ; ----------------------------------------------------------------------------
000111r 2               ; HANDLE NUMBERED LINE
000111r 2               ; ----------------------------------------------------------------------------
000111r 2               NUMBERED_LINE:
000111r 2  20 rr rr             jsr     LINGET
000114r 2  20 rr rr             jsr     PARSE_INPUT_LINE
000117r 2  84 64                sty     EOLPNTR
000119r 2  20 rr rr             jsr     FNDLIN
00011Cr 2  90 44                bcc     PUT_NEW_LINE
00011Er 2  A0 01                ldy     #$01
000120r 2  B1 B6                lda     (LOWTR),y
000122r 2  85 7A                sta     INDEX+1
000124r 2  A5 84                lda     VARTAB
000126r 2  85 79                sta     INDEX
000128r 2  A5 B7                lda     LOWTR+1
00012Ar 2  85 7C                sta     DEST+1
00012Cr 2  A5 B6                lda     LOWTR
00012Er 2  88                   dey
00012Fr 2  F1 B6                sbc     (LOWTR),y
000131r 2  18                   clc
000132r 2  65 84                adc     VARTAB
000134r 2  85 84                sta     VARTAB
000136r 2  85 7B                sta     DEST
000138r 2  A5 85                lda     VARTAB+1
00013Ar 2  69 FF                adc     #$FF
00013Cr 2  85 85                sta     VARTAB+1
00013Er 2  E5 B7                sbc     LOWTR+1
000140r 2  AA                   tax
000141r 2  38                   sec
000142r 2  A5 B6                lda     LOWTR
000144r 2  E5 84                sbc     VARTAB
000146r 2  A8                   tay
000147r 2  B0 03                bcs     L23A5
000149r 2  E8                   inx
00014Ar 2  C6 7C                dec     DEST+1
00014Cr 2               L23A5:
00014Cr 2  18                   clc
00014Dr 2  65 79                adc     INDEX
00014Fr 2  90 03                bcc     L23AD
000151r 2  C6 7A                dec     INDEX+1
000153r 2  18                   clc
000154r 2               L23AD:
000154r 2  B1 79                lda     (INDEX),y
000156r 2  91 7B                sta     (DEST),y
000158r 2  C8                   iny
000159r 2  D0 F9                bne     L23AD
00015Br 2  E6 7A                inc     INDEX+1
00015Dr 2  E6 7C                inc     DEST+1
00015Fr 2  CA                   dex
000160r 2  D0 F2                bne     L23AD
000162r 2               ; ----------------------------------------------------------------------------
000162r 2               PUT_NEW_LINE:
000162r 2  20 rr rr             jsr     SETPTRS
000165r 2  20 rr rr             jsr     LE33D
000168r 2  A5 12                lda     INPUTBUFFER
00016Ar 2  F0 8C                beq     L2351
00016Cr 2  18                   clc
00016Dr 2  A5 84                lda     VARTAB
00016Fr 2  85 B1                sta     HIGHTR
000171r 2  65 64                adc     EOLPNTR
000173r 2  85 AF                sta     HIGHDS
000175r 2  A4 85                ldy     VARTAB+1
000177r 2  84 B2                sty     HIGHTR+1
000179r 2  90 01                bcc     L23D6
00017Br 2  C8                   iny
00017Cr 2               L23D6:
00017Cr 2  84 B0                sty     HIGHDS+1
00017Er 2  20 rr rr             jsr     BLTU
000181r 2               .ifdef CONFIG_INPUTBUFFER_0200
000181r 2                       lda     LINNUM
000181r 2                       ldy     LINNUM+1
000181r 2                       sta     INPUTBUFFER-2
000181r 2                       sty     INPUTBUFFER-1
000181r 2               .endif
000181r 2  A5 88                lda     STREND
000183r 2  A4 89                ldy     STREND+1
000185r 2  85 84                sta     VARTAB
000187r 2  84 85                sty     VARTAB+1
000189r 2  A4 64                ldy     EOLPNTR
00018Br 2  88                   dey
00018Cr 2               ; ---COPY LINE INTO PROGRAM-------
00018Cr 2               L23E6:
00018Cr 2  B9 0E 00             lda     INPUTBUFFER-4,y
00018Fr 2  91 B6                sta     (LOWTR),y
000191r 2  88                   dey
000192r 2  10 F8                bpl     L23E6
000194r 2               
000194r 2               ; ----------------------------------------------------------------------------
000194r 2               ; CLEAR ALL VARIABLES
000194r 2               ; RE-ESTABLISH ALL FORWARD LINKS
000194r 2               ; ----------------------------------------------------------------------------
000194r 2               FIX_LINKS:
000194r 2  20 rr rr             jsr     SETPTRS
000197r 2  20 rr rr             jsr     LE33D
00019Ar 2  4C rr rr             jmp     L2351
00019Dr 2               LE33D:
00019Dr 2  A5 82                lda     TXTTAB
00019Fr 2  A4 83                ldy     TXTTAB+1
0001A1r 2  85 79                sta     INDEX
0001A3r 2  84 7A                sty     INDEX+1
0001A5r 2  18                   clc
0001A6r 2               L23FA:
0001A6r 2  A0 01                ldy     #$01
0001A8r 2  B1 79                lda     (INDEX),y
0001AAr 2  F0 22                beq     RET3
0001ACr 2  D0 03 4C rr          jeq     L2351
0001B0r 2  rr           
0001B1r 2  A0 04                ldy     #$04
0001B3r 2               L2405:
0001B3r 2  C8                   iny
0001B4r 2  B1 79                lda     (INDEX),y
0001B6r 2  D0 FB                bne     L2405
0001B8r 2  C8                   iny
0001B9r 2  98                   tya
0001BAr 2  65 79                adc     INDEX
0001BCr 2  AA                   tax
0001BDr 2  A0 00                ldy     #$00
0001BFr 2  91 79                sta     (INDEX),y
0001C1r 2  A5 7A                lda     INDEX+1
0001C3r 2  69 00                adc     #$00
0001C5r 2  C8                   iny
0001C6r 2  91 79                sta     (INDEX),y
0001C8r 2  86 79                stx     INDEX
0001CAr 2  85 7A                sta     INDEX+1
0001CCr 2  90 D8                bcc     L23FA	; always
0001CEr 2               
0001CEr 2               ; ----------------------------------------------------------------------------
0001CEr 2               
0001CEr 2               RET3:
0001CEr 2  60           		rts
0001CFr 2               
0001CFr 2               ;.include "inline.s"
0001CFr 2               
0001CFr 2               .segment "MSBCODE"
0001CFr 2               
0001CFr 2               .ifndef CONFIG_NO_INPUTBUFFER_ZP
0001CFr 2               L2420:
0001CFr 2  CA                   dex
0001D0r 2  10 05                bpl     INLIN2
0001D2r 2               L2423:
0001D2r 2  20 rr rr             jsr     CRDO
0001D5r 2               .endif
0001D5r 2               
0001D5r 2               ; ----------------------------------------------------------------------------
0001D5r 2               ; READ A LINE, AND STRIP OFF SIGN BITS
0001D5r 2               ; ----------------------------------------------------------------------------
0001D5r 2               
0001D5r 2               INLIN:
0001D5r 2               
0001D5r 2  A2 00                ldx     #$00
0001D7r 2               INLIN2:
0001D7r 2  20 rr rr             jsr     GETLN
0001DAr 2                   .ifndef CONFIG_NO_LINE_EDITING
0001DAr 2  C9 07                cmp     #$07
0001DCr 2  F0 14                beq     L2443
0001DEr 2                   .endif
0001DEr 2  C9 0D                cmp     #$0D
0001E0r 2  F0 20                beq     L2453
0001E2r 2                   .ifndef CONFIG_NO_LINE_EDITING
0001E2r 2  C9 20                cmp     #$20
0001E4r 2  90 F1                bcc     INLIN2
0001E6r 2  C9 7D                cmp     #$7D
0001E8r 2  B0 ED                bcs     INLIN2
0001EAr 2  C9 40                cmp     #$40 ; @
0001ECr 2  F0 E4                beq     L2423
0001EEr 2  C9 5F                cmp     #$5F ; _
0001F0r 2  F0 DD                beq     L2420
0001F2r 2               L2443:
0001F2r 2  E0 47                cpx     #$47
0001F4r 2  B0 05                bcs     L244C
0001F6r 2                   .endif
0001F6r 2  95 12                sta     INPUTBUFFER,x
0001F8r 2  E8                   inx
0001F9r 2  D0 DC                bne     INLIN2
0001FBr 2               L244C:
0001FBr 2                   .ifndef CONFIG_NO_LINE_EDITING
0001FBr 2  A9 07                lda     #$07 ; BEL
0001FDr 2               L244E:
0001FDr 2  20 rr rr             jsr     OUTDO
000200r 2  D0 D5                bne     INLIN2
000202r 2                   .endif
000202r 2               L2453:
000202r 2  4C rr rr             jmp     L29B9
000205r 2               
000205r 2               
000205r 2               GETLN:
000205r 2                   .ifdef CONFIG_FILE
000205r 2                       jsr     CHRIN
000205r 2                       ldy     CURDVC
000205r 2                       bne     L2465
000205r 2                   .else
000205r 2  20 rr rr             jsr     MONRDKEY
000208r 2                   .endif
000208r 2  C9 0F                cmp     #$0F
00020Ar 2  D0 08                bne     L2465
00020Cr 2  48                   pha
00020Dr 2  A5 6C                lda     Z14
00020Fr 2  49 FF                eor     #$FF
000211r 2  85 6C                sta     Z14
000213r 2  68                   pla
000214r 2               L2465:
000214r 2  60                   rts
000215r 2               
000215r 2               
000215r 2               ; ----------------------------------------------------------------------------
000215r 2               ; TOKENIZE THE INPUT LINE
000215r 2               ; ----------------------------------------------------------------------------
000215r 2               PARSE_INPUT_LINE:
000215r 2  A6 D1                ldx     TXTPTR
000217r 2  A0 04                ldy     #$04
000219r 2  84 68                sty     DATAFLG
00021Br 2               L246C:
00021Br 2  B5 00                lda     INPUTBUFFERX,x
00021Dr 2               .ifdef CONFIG_CBM_ALL
00021Dr 2                       bpl     LC49E
00021Dr 2                       cmp     #$FF
00021Dr 2                       beq     L24AC
00021Dr 2                       inx
00021Dr 2                       bne     L246C
00021Dr 2               LC49E:
00021Dr 2               .endif
00021Dr 2  C9 20                cmp     #$20
00021Fr 2  F0 36                beq     L24AC
000221r 2  85 63                sta     ENDCHR
000223r 2  C9 22                cmp     #$22
000225r 2  F0 54                beq     L24D0
000227r 2  24 68                bit     DATAFLG
000229r 2  70 2C                bvs     L24AC
00022Br 2  C9 3F                cmp     #$3F
00022Dr 2  D0 04                bne     L2484
00022Fr 2  A9 96                lda     #TOKEN_PRINT
000231r 2  D0 24                bne     L24AC
000233r 2               L2484:
000233r 2  C9 30                cmp     #$30
000235r 2  90 04                bcc     L248C
000237r 2  C9 3C                cmp     #$3C
000239r 2  90 1C                bcc     L24AC
00023Br 2               ; ----------------------------------------------------------------------------
00023Br 2               ; SEARCH TOKEN NAME TABLE FOR MATCH STARTING
00023Br 2               ; WITH CURRENT CHAR FROM INPUT LINE
00023Br 2               ; ----------------------------------------------------------------------------
00023Br 2               L248C:
00023Br 2  84 C8                sty     STRNG2
00023Dr 2  A0 00                ldy     #$00
00023Fr 2  84 64                sty     EOLPNTR
000241r 2  88                   dey
000242r 2  86 D1                stx     TXTPTR
000244r 2  CA                   dex
000245r 2               L2496:
000245r 2  C8                   iny
000246r 2               L2497:
000246r 2  E8                   inx
000247r 2               L2498:
000247r 2  B5 00                lda     INPUTBUFFERX,x
000249r 2  38                   sec
00024Ar 2  F9 rr rr             sbc     TOKEN_NAME_TABLE,y
00024Dr 2  F0 F6                beq     L2496
00024Fr 2  C9 80                cmp     #$80
000251r 2  D0 2F                bne     L24D7
000253r 2  05 64                ora     EOLPNTR
000255r 2               ; ----------------------------------------------------------------------------
000255r 2               ; STORE CHARACTER OR TOKEN IN OUTPUT LINE
000255r 2               ; ----------------------------------------------------------------------------
000255r 2               L24AA:
000255r 2  A4 C8                ldy     STRNG2
000257r 2               L24AC:
000257r 2  E8                   inx
000258r 2  C8                   iny
000259r 2  99 0D 00             sta     INPUTBUFFER-5,y
00025Cr 2  B9 0D 00             lda     INPUTBUFFER-5,y
00025Fr 2  F0 34                beq     L24EA
000261r 2  38                   sec
000262r 2  E9 3A                sbc     #$3A
000264r 2  F0 04                beq     L24BF
000266r 2  C9 49                cmp     #$49
000268r 2  D0 02                bne     L24C1
00026Ar 2               L24BF:
00026Ar 2  85 68                sta     DATAFLG
00026Cr 2               L24C1:
00026Cr 2  38                   sec
00026Dr 2  E9 54                sbc     #TOKEN_REM-':'
00026Fr 2  D0 AA                bne     L246C
000271r 2  85 63                sta     ENDCHR
000273r 2               ; ----------------------------------------------------------------------------
000273r 2               ; HANDLE LITERAL (BETWEEN QUOTES) OR REMARK,
000273r 2               ; BY COPYING CHARS UP TO ENDCHR.
000273r 2               ; ----------------------------------------------------------------------------
000273r 2               L24C8:
000273r 2  B5 00                lda     INPUTBUFFERX,x
000275r 2  F0 E0                beq     L24AC
000277r 2  C5 63                cmp     ENDCHR
000279r 2  F0 DC                beq     L24AC
00027Br 2               L24D0:
00027Br 2  C8                   iny
00027Cr 2  99 0D 00             sta     INPUTBUFFER-5,y
00027Fr 2  E8                   inx
000280r 2  D0 F1                bne     L24C8
000282r 2               ; ----------------------------------------------------------------------------
000282r 2               ; ADVANCE POINTER TO NEXT TOKEN NAME
000282r 2               ; ----------------------------------------------------------------------------
000282r 2               L24D7:
000282r 2  A6 D1                ldx     TXTPTR
000284r 2  E6 64                inc     EOLPNTR
000286r 2               L24DB:
000286r 2  C8                   iny
000287r 2  B9 rr rr             lda     MATHTBL+28+1,y
00028Ar 2  10 FA                bpl     L24DB
00028Cr 2  B9 rr rr             lda     TOKEN_NAME_TABLE,y
00028Fr 2  D0 B6                bne     L2498
000291r 2  B5 00                lda     INPUTBUFFERX,x
000293r 2  10 C0                bpl     L24AA
000295r 2               ; ---END OF LINE------------------
000295r 2               L24EA:
000295r 2  99 0F 00             sta     INPUTBUFFER-3,y
000298r 2               .ifdef CONFIG_NO_INPUTBUFFER_ZP
000298r 2                       dec     TXTPTR+1
000298r 2               .endif
000298r 2  A9 11                lda     #<INPUTBUFFER-1
00029Ar 2  85 D1                sta     TXTPTR
00029Cr 2  60                   rts
00029Dr 2               
00029Dr 2               ; ----------------------------------------------------------------------------
00029Dr 2               ; SEARCH FOR LINE
00029Dr 2               ;
00029Dr 2               ; (LINNUM) = LINE # TO FIND
00029Dr 2               ; IF NOT FOUND:  CARRY = 0
00029Dr 2               ;	LOWTR POINTS AT NEXT LINE
00029Dr 2               ; IF FOUND:      CARRY = 1
00029Dr 2               ;	LOWTR POINTS AT LINE
00029Dr 2               ; ----------------------------------------------------------------------------
00029Dr 2               FNDLIN:
00029Dr 2  A5 82                lda     TXTTAB
00029Fr 2  A6 83                ldx     TXTTAB+1
0002A1r 2               FL1:
0002A1r 2  A0 01                ldy     #$01
0002A3r 2  85 B6                sta     LOWTR
0002A5r 2  86 B7                stx     LOWTR+1
0002A7r 2  B1 B6                lda     (LOWTR),y
0002A9r 2  F0 1F                beq     L251F
0002ABr 2  C8                   iny
0002ACr 2  C8                   iny
0002ADr 2  A5 11                lda     LINNUM+1
0002AFr 2  D1 B6                cmp     (LOWTR),y
0002B1r 2  90 18                bcc     L2520
0002B3r 2  F0 03                beq     L250D
0002B5r 2  88                   dey
0002B6r 2  D0 09                bne     L2516
0002B8r 2               L250D:
0002B8r 2  A5 10                lda     LINNUM
0002BAr 2  88                   dey
0002BBr 2  D1 B6                cmp     (LOWTR),y
0002BDr 2  90 0C                bcc     L2520
0002BFr 2  F0 0A                beq     L2520
0002C1r 2               L2516:
0002C1r 2  88                   dey
0002C2r 2  B1 B6                lda     (LOWTR),y
0002C4r 2  AA                   tax
0002C5r 2  88                   dey
0002C6r 2  B1 B6                lda     (LOWTR),y
0002C8r 2  B0 D7                bcs     FL1
0002CAr 2               L251F:
0002CAr 2  18                   clc
0002CBr 2               L2520:
0002CBr 2  60                   rts
0002CCr 2               
0002CCr 2               ; ----------------------------------------------------------------------------
0002CCr 2               ; "NEW" STATEMENT
0002CCr 2               ; ----------------------------------------------------------------------------
0002CCr 2               NEW:
0002CCr 2  D0 FD                bne     L2520
0002CEr 2               SCRTCH:
0002CEr 2  A9 00                lda     #$00
0002D0r 2  A8                   tay
0002D1r 2  91 82                sta     (TXTTAB),y
0002D3r 2  C8                   iny
0002D4r 2  91 82                sta     (TXTTAB),y
0002D6r 2  A5 82                lda     TXTTAB
0002D8r 2  18           		clc
0002D9r 2  69 02                adc     #$02
0002DBr 2  85 84                sta     VARTAB
0002DDr 2  A5 83                lda     TXTTAB+1
0002DFr 2  69 00                adc     #$00
0002E1r 2  85 85                sta     VARTAB+1
0002E3r 2               ; ----------------------------------------------------------------------------
0002E3r 2               SETPTRS:
0002E3r 2  20 rr rr             jsr     STXTPT
0002E6r 2  A9 00                lda     #$00
0002E8r 2               
0002E8r 2               ; ----------------------------------------------------------------------------
0002E8r 2               ; "CLEAR" STATEMENT
0002E8r 2               ; ----------------------------------------------------------------------------
0002E8r 2               CLEAR:
0002E8r 2  D0 2A                bne     L256A
0002EAr 2               CLEARC:
0002EAr 2               
0002EAr 2  A5 8E                lda     MEMSIZ
0002ECr 2  A4 8F                ldy     MEMSIZ+1
0002EEr 2  85 8A                sta     FRETOP
0002F0r 2  84 8B                sty     FRETOP+1
0002F2r 2               .ifdef CONFIG_CBM_ALL
0002F2r 2                       jsr     CLALL
0002F2r 2               .endif
0002F2r 2  A5 84                lda     VARTAB
0002F4r 2  A4 85                ldy     VARTAB+1
0002F6r 2  85 86                sta     ARYTAB
0002F8r 2  84 87                sty     ARYTAB+1
0002FAr 2  85 88                sta     STREND
0002FCr 2  84 89                sty     STREND+1
0002FEr 2  20 rr rr             jsr     RESTORE
000301r 2               ; ----------------------------------------------------------------------------
000301r 2               STKINI:
000301r 2  A2 70                ldx     #TEMPST
000303r 2  86 6D                stx     TEMPPT
000305r 2  68                   pla
000306r 2  A8           		tay
000307r 2  68                   pla
000308r 2  A2 FA                ldx     #STACK_TOP
00030Ar 2  9A                   txs
00030Br 2  48                   pha
00030Cr 2  98                   tya
00030Dr 2  48                   pha
00030Er 2  A9 00                lda     #$00
000310r 2  85 95                sta     OLDTEXT+1
000312r 2  85 69                sta     SUBFLG
000314r 2               L256A:
000314r 2  60                   rts
000315r 2               
000315r 2               ; ----------------------------------------------------------------------------
000315r 2               ; SET TXTPTR TO BEGINNING OF PROGRAM
000315r 2               ; ----------------------------------------------------------------------------
000315r 2               STXTPT:
000315r 2  18                   clc
000316r 2  A5 82                lda     TXTTAB
000318r 2  69 FF                adc     #$FF
00031Ar 2  85 D1                sta     TXTPTR
00031Cr 2  A5 83                lda     TXTTAB+1
00031Er 2  69 FF                adc     #$FF
000320r 2  85 D2                sta     TXTPTR+1
000322r 2  60                   rts
000323r 2               
000323r 2               ; ----------------------------------------------------------------------------
000323r 2               ; "LIST" STATEMENT
000323r 2               ; ----------------------------------------------------------------------------
000323r 2               LIST:
000323r 2  90 06                bcc     L2581
000325r 2  F0 04                beq     L2581
000327r 2  C9 A4                cmp     #TOKEN_MINUS
000329r 2  D0 E9                bne     L256A
00032Br 2               L2581:
00032Br 2  20 rr rr             jsr     LINGET
00032Er 2  20 rr rr             jsr     FNDLIN
000331r 2  20 D0 00             jsr     CHRGOT
000334r 2  F0 0C                beq     L2598
000336r 2  C9 A4                cmp     #TOKEN_MINUS
000338r 2  D0 91                bne     L2520
00033Ar 2  20 CA 00             jsr     CHRGET
00033Dr 2  20 rr rr             jsr     LINGET
000340r 2  D0 89                bne     L2520
000342r 2               L2598:
000342r 2  A9 FF                lda     #$FF
000344r 2  85 10                sta     LINNUM
000346r 2  85 11                sta     LINNUM+1
000348r 2               L25A6:
000348r 2               L25A6X:
000348r 2  A0 01                ldy     #$01
00034Ar 2               .ifdef CONFIG_DATAFLG
00034Ar 2                       sty     DATAFLG
00034Ar 2               .endif
00034Ar 2  B1 B6                lda     (LOWTRX),y
00034Cr 2  F0 39                beq     L25E5
00034Er 2  20 rr rr             jsr     ISCNTC
000351r 2  20 rr rr             jsr     CRDO
000354r 2  C8                   iny
000355r 2  B1 B6                lda     (LOWTRX),y
000357r 2  AA                   tax
000358r 2  C8                   iny
000359r 2  B1 B6                lda     (LOWTRX),y
00035Br 2  C5 11                cmp     LINNUM+1
00035Dr 2  D0 04                bne     L25C1
00035Fr 2  E4 10                cpx     LINNUM
000361r 2  F0 02                beq     L25C3
000363r 2               L25C1:
000363r 2  B0 22                bcs     L25E5
000365r 2               ; ---LIST ONE LINE----------------
000365r 2               L25C3:
000365r 2  84 A0                sty     FORPNT
000367r 2  20 rr rr             jsr     LINPRT
00036Ar 2  A9 20                lda     #$20
00036Cr 2               L25CA:
00036Cr 2  A4 A0                ldy     FORPNT
00036Er 2  29 7F                and     #$7F
000370r 2               L25CE:
000370r 2  20 rr rr             jsr     OUTDO
000373r 2               .ifdef CONFIG_DATAFLG
000373r 2                       cmp     #$22
000373r 2                       bne     LA519
000373r 2                       lda     DATAFLG
000373r 2                       eor     #$FF
000373r 2                       sta     DATAFLG
000373r 2               LA519:
000373r 2               .endif
000373r 2  C8                   iny
000374r 2  F0 11                beq     L25E5
000376r 2  B1 B6                lda     (LOWTRX),y
000378r 2  D0 10                bne     L25E8
00037Ar 2  A8                   tay
00037Br 2  B1 B6                lda     (LOWTRX),y
00037Dr 2  AA                   tax
00037Er 2  C8                   iny
00037Fr 2  B1 B6                lda     (LOWTRX),y
000381r 2  86 B6                stx     LOWTRX
000383r 2  85 B7                sta     LOWTRX+1
000385r 2  D0 C1                bne     L25A6
000387r 2               L25E5:
000387r 2  4C rr rr             jmp     RESTART
00038Ar 2               L25E8:
00038Ar 2  10 E4                bpl     L25CE
00038Cr 2               .ifdef CONFIG_DATAFLG
00038Cr 2                       cmp     #$FF
00038Cr 2                       beq     L25CE
00038Cr 2                       bit     DATAFLG
00038Cr 2                       bmi     L25CE
00038Cr 2               .endif
00038Cr 2  38                   sec
00038Dr 2  E9 7F                sbc     #$7F
00038Fr 2  AA                   tax
000390r 2  84 A0                sty     FORPNT
000392r 2  A0 FF                ldy     #$FF
000394r 2               L25F2:
000394r 2  CA                   dex
000395r 2  F0 08                beq     L25FD
000397r 2               L25F5:
000397r 2  C8                   iny
000398r 2  B9 rr rr             lda     TOKEN_NAME_TABLE,y
00039Br 2  10 FA                bpl     L25F5
00039Dr 2  30 F5                bmi     L25F2
00039Fr 2               L25FD:
00039Fr 2  C8                   iny
0003A0r 2  B9 rr rr             lda     TOKEN_NAME_TABLE,y
0003A3r 2  30 C7                bmi     L25CA
0003A5r 2  20 rr rr             jsr     OUTDO
0003A8r 2  D0 F5                bne     L25FD	; always
0003AAr 2               
0003AAr 2               
0003AAr 2               ;.include "flow1.s"
0003AAr 2               
0003AAr 2               .segment "MSBCODE"
0003AAr 2               
0003AAr 2               ; ----------------------------------------------------------------------------
0003AAr 2               ; "FOR" STATEMENT
0003AAr 2               ;
0003AAr 2               ; FOR PUSHES 18 BYTES ON THE STACK:
0003AAr 2               ; 2 -- TXTPTR
0003AAr 2               ; 2 -- LINE NUMBER
0003AAr 2               ; 5 -- INITIAL (CURRENT)  FOR VARIABLE VALUE
0003AAr 2               ; 1 -- STEP SIGN
0003AAr 2               ; 5 -- STEP VALUE
0003AAr 2               ; 2 -- ADDRESS OF FOR VARIABLE IN VARTAB
0003AAr 2               ; 1 -- FOR TOKEN ($81)
0003AAr 2               ; ----------------------------------------------------------------------------
0003AAr 2               FOR:
0003AAr 2  A9 80                lda     #$80
0003ACr 2  85 69                sta     SUBFLG
0003AEr 2  20 rr rr             jsr     LET
0003B1r 2  20 rr rr             jsr     GTFORPNT
0003B4r 2  D0 05                bne     L2619
0003B6r 2  8A                   txa
0003B7r 2  69 0F                adc     #FOR_STACK1
0003B9r 2  AA                   tax
0003BAr 2  9A                   txs
0003BBr 2               L2619:
0003BBr 2  68                   pla
0003BCr 2  68                   pla
0003BDr 2  A9 09                lda     #FOR_STACK2
0003BFr 2  20 rr rr             jsr     CHKMEM
0003C2r 2  20 rr rr             jsr     DATAN
0003C5r 2  18                   clc
0003C6r 2  98                   tya
0003C7r 2  65 D1                adc     TXTPTR
0003C9r 2  48                   pha
0003CAr 2  A5 D2                lda     TXTPTR+1
0003CCr 2  69 00                adc     #$00
0003CEr 2  48                   pha
0003CFr 2  A5 91                lda     CURLIN+1
0003D1r 2  48                   pha
0003D2r 2  A5 90                lda     CURLIN
0003D4r 2  48                   pha
0003D5r 2  A9 9D                lda     #TOKEN_TO
0003D7r 2  20 rr rr             jsr     SYNCHR
0003DAr 2  20 rr rr             jsr     CHKNUM
0003DDr 2  20 rr rr             jsr     FRMNUM
0003E0r 2  A5 BD                lda     FACSIGN
0003E2r 2  09 7F                ora     #$7F
0003E4r 2  25 B9                and     FAC+1
0003E6r 2  85 B9                sta     FAC+1
0003E8r 2  A9 rr                lda     #<STEP
0003EAr 2  A0 rr                ldy     #>STEP
0003ECr 2  85 79                sta     INDEX
0003EEr 2  84 7A                sty     INDEX+1
0003F0r 2  4C rr rr             jmp     FRM_STACK3
0003F3r 2               
0003F3r 2               ; ----------------------------------------------------------------------------
0003F3r 2               ; "STEP" PHRASE OF "FOR" STATEMENT
0003F3r 2               ; ----------------------------------------------------------------------------
0003F3r 2               STEP:
0003F3r 2  A9 rr                lda     #<CON_ONE
0003F5r 2  A0 rr                ldy     #>CON_ONE
0003F7r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
0003FAr 2  20 D0 00             jsr     CHRGOT
0003FDr 2  C9 A2                cmp     #TOKEN_STEP
0003FFr 2  D0 06                bne     L2665
000401r 2  20 CA 00             jsr     CHRGET
000404r 2  20 rr rr             jsr     FRMNUM
000407r 2               L2665:
000407r 2  20 rr rr             jsr     SIGN
00040Ar 2  20 rr rr             jsr     FRM_STACK2
00040Dr 2  A5 A1                lda     FORPNT+1
00040Fr 2  48                   pha
000410r 2  A5 A0                lda     FORPNT
000412r 2  48                   pha
000413r 2  A9 81                lda     #$81
000415r 2  48                   pha
000416r 2               
000416r 2               ; ----------------------------------------------------------------------------
000416r 2               ; PERFORM NEXT STATEMENT
000416r 2               ; ----------------------------------------------------------------------------
000416r 2               NEWSTT:
000416r 2  20 rr rr             jsr     ISCNTC
000419r 2  A5 D1                lda     TXTPTR
00041Br 2  A4 D2                ldy     TXTPTR+1
00041Dr 2               ;.if .def(CONFIG_NO_INPUTBUFFER_ZP) && .def(CONFIG_2)
00041Dr 2  C0 00                cpy     #>INPUTBUFFER
00041Fr 2                 .ifdef CBM2
00041Fr 2                       nop
00041Fr 2                 .endif
00041Fr 2  F0 04                beq     LC6D4
000421r 2               ;.else
000421r 2               ; BUG on AppleSoft I,
000421r 2               ; fixed differently on AppleSoft II (ldx/inx)
000421r 2               ;        beq     L2683
000421r 2               ;.endif
000421r 2  85 94                sta     OLDTEXT
000423r 2  84 95                sty     OLDTEXT+1
000425r 2               LC6D4:
000425r 2  A0 00                ldy     #$00
000427r 2               L2683:
000427r 2  B1 D1                lda     (TXTPTR),y
000429r 2  D0 40                bne     COLON; new: 1 cycle more on ":" case
00042Br 2  A0 02                ldy     #$02
00042Dr 2  B1 D1                lda     (TXTPTR),y
00042Fr 2  18                   clc
000430r 2  D0 03 4C rr          jeq     L2701
000434r 2  rr           
000435r 2  C8                   iny
000436r 2  B1 D1                lda     (TXTPTR),y
000438r 2  85 90                sta     CURLIN
00043Ar 2  C8                   iny
00043Br 2  B1 D1                lda     (TXTPTR),y
00043Dr 2  85 91                sta     CURLIN+1
00043Fr 2  98                   tya
000440r 2  65 D1                adc     TXTPTR
000442r 2  85 D1                sta     TXTPTR
000444r 2  90 02                bcc     NEWSTT2
000446r 2  E6 D2                inc     TXTPTR+1
000448r 2               NEWSTT2:
000448r 2  20 CA 00             jsr     CHRGET
00044Br 2  20 rr rr             jsr     EXECUTE_STATEMENT
00044Er 2  4C rr rr             jmp     NEWSTT
000451r 2               
000451r 2               ; ----------------------------------------------------------------------------
000451r 2               ; EXECUTE A STATEMENT
000451r 2               ;
000451r 2               ; (A) IS FIRST CHAR OF STATEMENT
000451r 2               ; CARRY IS SET
000451r 2               ; ----------------------------------------------------------------------------
000451r 2               EXECUTE_STATEMENT:
000451r 2  F0 3C                beq     RET2
000453r 2               EXECUTE_STATEMENT1:
000453r 2  E9 80                sbc     #$80
000455r 2  90 11                bcc     LET1; new: 1 cycle more on assignment
000457r 2  C9 1C                cmp     #NUM_TOKENS
000459r 2  B0 17                bcs     LC721
00045Br 2  0A                   asl     a
00045Cr 2  A8                   tay
00045Dr 2  B9 rr rr             lda     TOKEN_ADDRESS_TABLE+1,y
000460r 2  48                   pha
000461r 2  B9 rr rr             lda     TOKEN_ADDRESS_TABLE,y
000464r 2  48                   pha
000465r 2  4C CA 00             jmp     CHRGET
000468r 2               
000468r 2               LET1:
000468r 2  4C rr rr             jmp     LET
00046Br 2               
00046Br 2               COLON:
00046Br 2  C9 3A                cmp     #$3A
00046Dr 2  F0 D9                beq     NEWSTT2
00046Fr 2               SYNERR1:
00046Fr 2  4C rr rr             jmp     SYNERR
000472r 2               
000472r 2               LC721:
000472r 2  C9 44                cmp     #TOKEN_GO-$80
000474r 2  D0 F9                bne     SYNERR1
000476r 2  20 CA 00             jsr     CHRGET
000479r 2  A9 9D                lda     #TOKEN_TO
00047Br 2  20 rr rr             jsr     SYNCHR
00047Er 2  4C rr rr             jmp     GOTO
000481r 2               
000481r 2               ; ----------------------------------------------------------------------------
000481r 2               ; "RESTORE" STATEMENT
000481r 2               ; ----------------------------------------------------------------------------
000481r 2               RESTORE:
000481r 2  38                   sec
000482r 2  A5 82                lda     TXTTAB
000484r 2  E9 01                sbc     #$01
000486r 2  A4 83                ldy     TXTTAB+1
000488r 2  B0 01                bcs     SETDA
00048Ar 2  88                   dey
00048Br 2               SETDA:
00048Br 2  85 98                sta     DATPTR
00048Dr 2  84 99                sty     DATPTR+1
00048Fr 2               RET2:
00048Fr 2  60                   rts
000490r 2               
000490r 2               ; .include "iscntc.s"
000490r 2               
000490r 2               ISCNTC:
000490r 2  20 rr rr             jsr CHRIN
000493r 2  90 07                bcc not_cntc
000495r 2  C9 03                cmp #3
000497r 2  D0 03                bne not_cntc
000499r 2  4C rr rr             jmp is_cntc
00049Cr 2               
00049Cr 2               not_cntc:
00049Cr 2  60                   rts
00049Dr 2               
00049Dr 2               is_cntc:
00049Dr 2                       ; Fall through
00049Dr 2               
00049Dr 2               ;!!! runs into "STOP"
00049Dr 2               ; ----------------------------------------------------------------------------
00049Dr 2               ; "STOP" STATEMENT
00049Dr 2               ; ----------------------------------------------------------------------------
00049Dr 2               STOP:
00049Dr 2  B0 01                bcs     END2
00049Fr 2               
00049Fr 2               ; ----------------------------------------------------------------------------
00049Fr 2               ; "END" STATEMENT
00049Fr 2               ; ----------------------------------------------------------------------------
00049Fr 2               END:
00049Fr 2  18                   clc
0004A0r 2               END2:
0004A0r 2  D0 3C                bne     RET1
0004A2r 2  A5 D1                lda     TXTPTR
0004A4r 2  A4 D2                ldy     TXTPTR+1
0004A6r 2               ;.if .def(CONFIG_NO_INPUTBUFFER_ZP) && .def(CONFIG_2)
0004A6r 2               ; BUG on AppleSoft I
0004A6r 2               ; fix exists on AppleSoft II
0004A6r 2               ; TXTPTR+1 will always be > 0
0004A6r 2  A6 91                ldx     CURLIN+1
0004A8r 2  E8                   inx
0004A9r 2               ;.endif
0004A9r 2  F0 0C                beq     END4
0004ABr 2  85 94                sta     OLDTEXT
0004ADr 2  84 95                sty     OLDTEXT+1
0004AFr 2               CONTROL_C_TYPED:
0004AFr 2  A5 90                lda     CURLIN
0004B1r 2  A4 91                ldy     CURLIN+1
0004B3r 2  85 92                sta     OLDLIN
0004B5r 2  84 93                sty     OLDLIN+1
0004B7r 2               END4:
0004B7r 2  68                   pla
0004B8r 2  68                   pla
0004B9r 2               L2701:
0004B9r 2  A9 rr                lda     #<QT_BREAK
0004BBr 2  A0 rr                ldy     #>QT_BREAK
0004BDr 2  90 03                bcc     L270E
0004BFr 2  4C rr rr             jmp     PRINT_ERROR_LINNUM
0004C2r 2               L270E:
0004C2r 2  4C rr rr             jmp     RESTART
0004C5r 2               
0004C5r 2               
0004C5r 2               ; ----------------------------------------------------------------------------
0004C5r 2               ; "CONT" COMMAND
0004C5r 2               ; ----------------------------------------------------------------------------
0004C5r 2               CONT:
0004C5r 2  D0 17                bne     RET1
0004C7r 2  A2 D2                ldx     #ERR_CANTCONT
0004C9r 2  A4 95                ldy     OLDTEXT+1
0004CBr 2  D0 03                bne     L271C
0004CDr 2  4C rr rr             jmp     ERROR
0004D0r 2               L271C:
0004D0r 2  A5 94                lda     OLDTEXT
0004D2r 2  85 D1                sta     TXTPTR
0004D4r 2  84 D2                sty     TXTPTR+1
0004D6r 2  A5 92                lda     OLDLIN
0004D8r 2  A4 93                ldy     OLDLIN+1
0004DAr 2  85 90                sta     CURLIN
0004DCr 2  84 91                sty     CURLIN+1
0004DEr 2               RET1:
0004DEr 2  60                   rts
0004DFr 2               
0004DFr 2               .if .def(CONFIG_NULL) || .def(CONFIG_PRINTNULLS)
0004DFr 2               ; CBM1 has the keyword removed,
0004DFr 2               ; but the code is still here
0004DFr 2               NULL:
0004DFr 2                       jsr     GETBYT
0004DFr 2                       bne     RET1
0004DFr 2                       inx
0004DFr 2                       cpx     #NULL_MAX
0004DFr 2                       bcs     L2739
0004DFr 2                       dex
0004DFr 2                       stx     Z15
0004DFr 2               L2738:
0004DFr 2                       rts
0004DFr 2               L2739:
0004DFr 2                       jmp     IQERR
0004DFr 2               
0004DFr 2               .endif
0004DFr 2               
0004DFr 2               ;.include "loadsave.s"
0004DFr 2               
0004DFr 2               ;.include "flow2.s"
0004DFr 2               
0004DFr 2               .segment "MSBCODE"
0004DFr 2               ; ----------------------------------------------------------------------------
0004DFr 2               ; "RUN" COMMAND
0004DFr 2               ; ----------------------------------------------------------------------------
0004DFr 2               RUN:
0004DFr 2  D0 03                bne     L27CF
0004E1r 2  4C rr rr             jmp     SETPTRS
0004E4r 2               L27CF:
0004E4r 2  20 rr rr             jsr     CLEARC
0004E7r 2  4C rr rr             jmp     L27E9
0004EAr 2               
0004EAr 2               ; ----------------------------------------------------------------------------
0004EAr 2               ; "GOSUB" STATEMENT
0004EAr 2               ;
0004EAr 2               ; LEAVES 7 BYTES ON STACK:
0004EAr 2               ; 2 -- RETURN ADDRESS (NEWSTT)
0004EAr 2               ; 2 -- TXTPTR
0004EAr 2               ; 2 -- LINE #
0004EAr 2               ; 1 -- GOSUB TOKEN
0004EAr 2               ; ----------------------------------------------------------------------------
0004EAr 2               GOSUB:
0004EAr 2  A9 03                lda     #$03
0004ECr 2  20 rr rr             jsr     CHKMEM
0004EFr 2  A5 D2                lda     TXTPTR+1
0004F1r 2  48                   pha
0004F2r 2  A5 D1                lda     TXTPTR
0004F4r 2  48                   pha
0004F5r 2  A5 91                lda     CURLIN+1
0004F7r 2  48                   pha
0004F8r 2  A5 90                lda     CURLIN
0004FAr 2  48                   pha
0004FBr 2  A9 8C                lda     #TOKEN_GOSUB
0004FDr 2  48                   pha
0004FEr 2               L27E9:
0004FEr 2  20 D0 00             jsr     CHRGOT
000501r 2  20 rr rr             jsr     GOTO
000504r 2  4C rr rr             jmp     NEWSTT
000507r 2               
000507r 2               ; ----------------------------------------------------------------------------
000507r 2               ; "GOTO" STATEMENT
000507r 2               ; ALSO USED BY "RUN" AND "GOSUB"
000507r 2               ; ----------------------------------------------------------------------------
000507r 2               GOTO:
000507r 2  20 rr rr             jsr     LINGET
00050Ar 2  20 rr rr             jsr     REMN
00050Dr 2  A5 91                lda     CURLIN+1
00050Fr 2  C5 11                cmp     LINNUM+1
000511r 2  B0 0B                bcs     L2809
000513r 2  98                   tya
000514r 2  38                   sec
000515r 2  65 D1                adc     TXTPTR
000517r 2  A6 D2                ldx     TXTPTR+1
000519r 2  90 07                bcc     L280D
00051Br 2  E8                   inx
00051Cr 2  B0 04                bcs     L280D
00051Er 2               L2809:
00051Er 2  A5 82                lda     TXTTAB
000520r 2  A6 83                ldx     TXTTAB+1
000522r 2               L280D:
000522r 2  20 rr rr             jsr     FL1
000525r 2  90 1E                bcc     UNDERR
000527r 2  A5 B6                lda     LOWTRX
000529r 2  E9 01                sbc     #$01
00052Br 2  85 D1                sta     TXTPTR
00052Dr 2  A5 B7                lda     LOWTRX+1
00052Fr 2  E9 00                sbc     #$00
000531r 2  85 D2                sta     TXTPTR+1
000533r 2               L281E:
000533r 2  60                   rts
000534r 2               
000534r 2               ; ----------------------------------------------------------------------------
000534r 2               ; "POP" AND "RETURN" STATEMENTS
000534r 2               ; ----------------------------------------------------------------------------
000534r 2               POP:
000534r 2  D0 FD                bne     L281E
000536r 2  A9 FF                lda     #$FF
000538r 2  85 A1                sta     FORPNT+1 ; bugfix, wrong in AppleSoft II
00053Ar 2  20 rr rr             jsr     GTFORPNT
00053Dr 2  9A                   txs
00053Er 2  C9 8C                cmp     #TOKEN_GOSUB
000540r 2  F0 0B                beq     RETURN
000542r 2  A2 16                ldx     #ERR_NOGOSUB
000544r 2  2C                   .byte   $2C
000545r 2               UNDERR:
000545r 2  A2 5A                ldx     #ERR_UNDEFSTAT
000547r 2  4C rr rr             jmp     ERROR
00054Ar 2               ; ----------------------------------------------------------------------------
00054Ar 2               SYNERR2:
00054Ar 2  4C rr rr             jmp     SYNERR
00054Dr 2               ; ----------------------------------------------------------------------------
00054Dr 2               RETURN:
00054Dr 2  68                   pla
00054Er 2  68                   pla
00054Fr 2  85 90                sta     CURLIN
000551r 2  68                   pla
000552r 2  85 91                sta     CURLIN+1
000554r 2  68                   pla
000555r 2  85 D1                sta     TXTPTR
000557r 2  68                   pla
000558r 2  85 D2                sta     TXTPTR+1
00055Ar 2               
00055Ar 2               ; ----------------------------------------------------------------------------
00055Ar 2               ; "DATA" STATEMENT
00055Ar 2               ; EXECUTED BY SKIPPING TO NEXT COLON OR EOL
00055Ar 2               ; ----------------------------------------------------------------------------
00055Ar 2               DATA:
00055Ar 2  20 rr rr             jsr     DATAN
00055Dr 2               
00055Dr 2               ; ----------------------------------------------------------------------------
00055Dr 2               ; ADD (Y) TO TXTPTR
00055Dr 2               ; ----------------------------------------------------------------------------
00055Dr 2               ADDON:
00055Dr 2  98                   tya
00055Er 2  18                   clc
00055Fr 2  65 D1                adc     TXTPTR
000561r 2  85 D1                sta     TXTPTR
000563r 2  90 02                bcc     L2852
000565r 2  E6 D2                inc     TXTPTR+1
000567r 2               L2852:
000567r 2  60                   rts
000568r 2               
000568r 2               ; ----------------------------------------------------------------------------
000568r 2               ; SCAN AHEAD TO NEXT ":" OR EOL
000568r 2               ; ----------------------------------------------------------------------------
000568r 2               DATAN:
000568r 2  A2 3A                ldx     #$3A
00056Ar 2  2C                   .byte   $2C
00056Br 2               REMN:
00056Br 2  A2 00                ldx     #$00
00056Dr 2  86 62                stx     CHARAC
00056Fr 2  A0 00                ldy     #$00
000571r 2  84 63                sty     ENDCHR
000573r 2               L285E:
000573r 2  A5 63                lda     ENDCHR
000575r 2  A6 62                ldx     CHARAC
000577r 2  85 62                sta     CHARAC
000579r 2  86 63                stx     ENDCHR
00057Br 2               L2866:
00057Br 2  B1 D1                lda     (TXTPTR),y
00057Dr 2  F0 E8                beq     L2852
00057Fr 2  C5 63                cmp     ENDCHR
000581r 2  F0 E4                beq     L2852
000583r 2  C8                   iny
000584r 2  C9 22                cmp     #$22
000586r 2  D0 F3                bne     L2866; new: cont is faster
000588r 2  F0 E9                beq     L285E
00058Ar 2               
00058Ar 2               ; ----------------------------------------------------------------------------
00058Ar 2               ; "IF" STATEMENT
00058Ar 2               ; ----------------------------------------------------------------------------
00058Ar 2               IF:
00058Ar 2  20 rr rr             jsr     FRMEVL
00058Dr 2  20 D0 00             jsr     CHRGOT
000590r 2  C9 88                cmp     #TOKEN_GOTO
000592r 2  F0 05                beq     L2884
000594r 2  A9 A0                lda     #TOKEN_THEN
000596r 2  20 rr rr             jsr     SYNCHR
000599r 2               L2884:
000599r 2  A5 B8                lda     FAC
00059Br 2  D0 05                bne     L288D
00059Dr 2               
00059Dr 2               ; ----------------------------------------------------------------------------
00059Dr 2               ; "REM" STATEMENT, OR FALSE "IF" STATEMENT
00059Dr 2               ; ----------------------------------------------------------------------------
00059Dr 2               REM:
00059Dr 2  20 rr rr             jsr     REMN
0005A0r 2  F0 BB                beq     ADDON
0005A2r 2               L288D:
0005A2r 2  20 D0 00             jsr     CHRGOT
0005A5r 2  B0 03                bcs     L2895
0005A7r 2  4C rr rr             jmp     GOTO
0005AAr 2               L2895:
0005AAr 2  4C rr rr             jmp     EXECUTE_STATEMENT
0005ADr 2               
0005ADr 2               ; ----------------------------------------------------------------------------
0005ADr 2               ; "ON" STATEMENT
0005ADr 2               ;
0005ADr 2               ; ON <EXP> GOTO <LIST>
0005ADr 2               ; ON <EXP> GOSUB <LIST>
0005ADr 2               ; ----------------------------------------------------------------------------
0005ADr 2               ON:
0005ADr 2  20 rr rr             jsr     GETBYT
0005B0r 2  48                   pha
0005B1r 2  C9 8C                cmp     #TOKEN_GOSUB
0005B3r 2  F0 04                beq     L28A4
0005B5r 2               L28A0:
0005B5r 2  C9 88                cmp     #TOKEN_GOTO
0005B7r 2  D0 91                bne     SYNERR2
0005B9r 2               L28A4:
0005B9r 2  C6 BC                dec     FAC_LAST
0005BBr 2  D0 04                bne     L28AC
0005BDr 2  68                   pla
0005BEr 2  4C rr rr             jmp     EXECUTE_STATEMENT1
0005C1r 2               L28AC:
0005C1r 2  20 CA 00             jsr     CHRGET
0005C4r 2  20 rr rr             jsr     LINGET
0005C7r 2  C9 2C                cmp     #$2C
0005C9r 2  F0 EE                beq     L28A4
0005CBr 2  68                   pla
0005CCr 2               L28B7:
0005CCr 2  60                   rts
0005CDr 2               
0005CDr 2               ;.include "misc1.s"
0005CDr 2               
0005CDr 2               .segment "MSBCODE"
0005CDr 2               
0005CDr 2               ; ----------------------------------------------------------------------------
0005CDr 2               ; CONVERT LINE NUMBER
0005CDr 2               ; ----------------------------------------------------------------------------
0005CDr 2               LINGET:
0005CDr 2  A2 00                ldx     #$00
0005CFr 2  86 10                stx     LINNUM
0005D1r 2  86 11                stx     LINNUM+1
0005D3r 2               L28BE:
0005D3r 2  B0 F7                bcs     L28B7
0005D5r 2  E9 2F                sbc     #$2F
0005D7r 2  85 62                sta     CHARAC
0005D9r 2  A5 11                lda     LINNUM+1
0005DBr 2  85 79                sta     INDEX
0005DDr 2  C9 19                cmp     #$19
0005DFr 2  B0 D4                bcs     L28A0
0005E1r 2               ; <<<<<DANGEROUS CODE>>>>>
0005E1r 2               ; NOTE THAT IF (A) = $AB ON THE LINE ABOVE,
0005E1r 2               ; ON.1 WILL COMPARE = AND CAUSE A CATASTROPHIC
0005E1r 2               ; JUMP TO $22D9 (FOR GOTO), OR OTHER LOCATIONS
0005E1r 2               ; FOR OTHER CALLS TO LINGET.
0005E1r 2               ;
0005E1r 2               ; YOU CAN SEE THIS IS YOU FIRST PUT "BRK" IN $22D9,
0005E1r 2               ; THEN TYPE "GO TO 437761".
0005E1r 2               ;
0005E1r 2               ; ANY VALUE FROM 437760 THROUGH 440319 WILL CAUSE
0005E1r 2               ; THE PROBLEM.  ($AB00 - $ABFF)
0005E1r 2               ; <<<<<DANGEROUS CODE>>>>>
0005E1r 2  A5 10                lda     LINNUM
0005E3r 2  0A                   asl     a
0005E4r 2  26 79                rol     INDEX
0005E6r 2  0A                   asl     a
0005E7r 2  26 79                rol     INDEX
0005E9r 2  65 10                adc     LINNUM
0005EBr 2  85 10                sta     LINNUM
0005EDr 2  A5 79                lda     INDEX
0005EFr 2  65 11                adc     LINNUM+1
0005F1r 2  85 11                sta     LINNUM+1
0005F3r 2  06 10                asl     LINNUM
0005F5r 2  26 11                rol     LINNUM+1
0005F7r 2  A5 10                lda     LINNUM
0005F9r 2  65 62                adc     CHARAC
0005FBr 2  85 10                sta     LINNUM
0005FDr 2  90 02                bcc     L28EC
0005FFr 2  E6 11                inc     LINNUM+1
000601r 2               L28EC:
000601r 2  20 CA 00             jsr     CHRGET
000604r 2  4C rr rr             jmp     L28BE
000607r 2               
000607r 2               ; ----------------------------------------------------------------------------
000607r 2               ; "LET" STATEMENT
000607r 2               ;
000607r 2               ; LET <VAR> = <EXP>
000607r 2               ; <VAR> = <EXP>
000607r 2               ; ----------------------------------------------------------------------------
000607r 2               LET:
000607r 2  20 rr rr             jsr     PTRGET
00060Ar 2  85 A0                sta     FORPNT
00060Cr 2  84 A1                sty     FORPNT+1
00060Er 2  A9 AB                lda     #TOKEN_EQUAL
000610r 2  20 rr rr             jsr     SYNCHR
000613r 2  A5 67                lda     VALTYP+1
000615r 2  48                   pha
000616r 2  A5 66                lda     VALTYP
000618r 2  48                   pha
000619r 2  20 rr rr             jsr     FRMEVL
00061Cr 2  68                   pla
00061Dr 2  2A                   rol     a
00061Er 2  20 rr rr             jsr     CHKVAL
000621r 2  D0 18                bne     LETSTRING
000623r 2  68                   pla
000624r 2               LET2:
000624r 2  10 12                bpl     L2923
000626r 2  20 rr rr             jsr     ROUND_FAC
000629r 2  20 rr rr             jsr     AYINT
00062Cr 2  A0 00                ldy     #$00
00062Er 2  A5 BB                lda     FAC+3
000630r 2  91 A0                sta     (FORPNT),y
000632r 2  C8                   iny
000633r 2  A5 BC                lda     FAC+4
000635r 2  91 A0                sta     (FORPNT),y
000637r 2  60                   rts
000638r 2               L2923:
000638r 2               
000638r 2               ; ----------------------------------------------------------------------------
000638r 2               ; REAL VARIABLE = EXPRESSION
000638r 2               ; ----------------------------------------------------------------------------
000638r 2  4C rr rr             jmp     SETFOR
00063Br 2               LETSTRING:
00063Br 2  68                   pla
00063Cr 2               
00063Cr 2               ; ----------------------------------------------------------------------------
00063Cr 2               ; INSTALL STRING, DESCRIPTOR ADDRESS IS AT FAC+3,4
00063Cr 2               ; ----------------------------------------------------------------------------
00063Cr 2               PUTSTR:
00063Cr 2               .ifdef CONFIG_CBM_ALL
00063Cr 2                       ldy     FORPNT+1
00063Cr 2                 .ifdef CBM1
00063Cr 2                       cpy     #$D0	; TI$
00063Cr 2                 .else
00063Cr 2                       cpy     #$DE
00063Cr 2                 .endif
00063Cr 2                       bne     LC92B
00063Cr 2                       jsr     FREFAC
00063Cr 2                       cmp     #$06
00063Cr 2                 .ifdef CBM2
00063Cr 2                       bne     IQERR1
00063Cr 2                 .else
00063Cr 2                       jne     IQERR
00063Cr 2                 .endif
00063Cr 2                       ldy     #$00
00063Cr 2                       sty     FAC
00063Cr 2                       sty     FACSIGN
00063Cr 2               LC8E8:
00063Cr 2                       sty     STRNG2
00063Cr 2                       jsr     LC91C
00063Cr 2                       jsr     MUL10
00063Cr 2                       inc     STRNG2
00063Cr 2                       ldy     STRNG2
00063Cr 2                       jsr     LC91C
00063Cr 2                       jsr     COPY_FAC_TO_ARG_ROUNDED
00063Cr 2                       tax
00063Cr 2                       beq     LC902
00063Cr 2                       inx
00063Cr 2                       txa
00063Cr 2                       jsr     LD9BF
00063Cr 2               LC902:
00063Cr 2                       ldy     STRNG2
00063Cr 2                       iny
00063Cr 2                       cpy     #$06
00063Cr 2                       bne     LC8E8
00063Cr 2                       jsr     MUL10
00063Cr 2                       jsr     QINT
00063Cr 2                       ldx     #$02
00063Cr 2                       sei
00063Cr 2               LC912:
00063Cr 2                       lda     FAC+2,x
00063Cr 2                       sta     TISTR,x
00063Cr 2                       dex
00063Cr 2                       bpl     LC912
00063Cr 2                       cli
00063Cr 2                       rts
00063Cr 2               LC91C:
00063Cr 2                       lda     (INDEX),y
00063Cr 2                       jsr     CHRGOT2
00063Cr 2                       bcc     LC926
00063Cr 2               IQERR1:
00063Cr 2                       jmp     IQERR
00063Cr 2               LC926:
00063Cr 2                       sbc     #$2F
00063Cr 2                       jmp     ADDACC
00063Cr 2               LC92B:
00063Cr 2               .endif
00063Cr 2  A0 02                ldy     #$02
00063Er 2  B1 BB                lda     (FAC_LAST-1),y
000640r 2  C5 8B                cmp     FRETOP+1
000642r 2  90 17                bcc     L2946
000644r 2  D0 07                bne     L2938
000646r 2  88                   dey
000647r 2  B1 BB                lda     (FAC_LAST-1),y
000649r 2  C5 8A                cmp     FRETOP
00064Br 2  90 0E                bcc     L2946
00064Dr 2               L2938:
00064Dr 2  A4 BC                ldy     FAC_LAST
00064Fr 2  C4 85                cpy     VARTAB+1
000651r 2  90 08                bcc     L2946
000653r 2  D0 0D                bne     L294D
000655r 2  A5 BB                lda     FAC_LAST-1
000657r 2  C5 84                cmp     VARTAB
000659r 2  B0 07                bcs     L294D
00065Br 2               L2946:
00065Br 2  A5 BB                lda     FAC_LAST-1
00065Dr 2  A4 BC                ldy     FAC_LAST
00065Fr 2  4C rr rr             jmp     L2963
000662r 2               L294D:
000662r 2  A0 00                ldy     #$00
000664r 2  B1 BB                lda     (FAC_LAST-1),y
000666r 2  20 rr rr             jsr     STRINI
000669r 2  A5 A7                lda     DSCPTR
00066Br 2  A4 A8                ldy     DSCPTR+1
00066Dr 2  85 C6                sta     STRNG1
00066Fr 2  84 C7                sty     STRNG1+1
000671r 2  20 rr rr             jsr     MOVINS
000674r 2  A9 B8                lda     #FAC
000676r 2  A0 00                ldy     #$00
000678r 2               L2963:
000678r 2  85 A7                sta     DSCPTR
00067Ar 2  84 A8                sty     DSCPTR+1
00067Cr 2  20 rr rr             jsr     FRETMS
00067Fr 2  A0 00                ldy     #$00
000681r 2  B1 A7                lda     (DSCPTR),y
000683r 2  91 A0                sta     (FORPNT),y
000685r 2  C8                   iny
000686r 2  B1 A7                lda     (DSCPTR),y
000688r 2  91 A0                sta     (FORPNT),y
00068Ar 2  C8                   iny
00068Br 2  B1 A7                lda     (DSCPTR),y
00068Dr 2  91 A0                sta     (FORPNT),y
00068Fr 2               RET5:
00068Fr 2  60                   rts
000690r 2               
000690r 2               .ifdef CONFIG_FILE
000690r 2               PRINTH:
000690r 2                       jsr     CMD
000690r 2                       jmp     LCAD6
000690r 2               CMD:
000690r 2                       jsr     GETBYT
000690r 2                       beq     LC98F
000690r 2                       lda     #$2C
000690r 2                       jsr     SYNCHR
000690r 2               LC98F:
000690r 2                       php
000690r 2                       jsr     CHKOUT
000690r 2                       stx     CURDVC
000690r 2                       plp
000690r 2                       jmp     PRINT
000690r 2               .endif
000690r 2               
000690r 2               ;.include "print.s"
000690r 2               
000690r 2               .segment "MSBCODE"
000690r 2               
000690r 2               PRSTRING:
000690r 2  20 rr rr             jsr     STRPRT
000693r 2               L297E:
000693r 2  20 D0 00             jsr     CHRGOT
000696r 2               
000696r 2               ; ----------------------------------------------------------------------------
000696r 2               ; "PRINT" STATEMENT
000696r 2               ; ----------------------------------------------------------------------------
000696r 2               
000696r 2               PRINT:
000696r 2  F0 2E                beq     CRDO
000698r 2               PRINT2:
000698r 2  F0 3A                beq     L29DD
00069Ar 2  C9 9C                cmp     #TOKEN_TAB
00069Cr 2  F0 44                beq     L29F5
00069Er 2  C9 9F                cmp     #TOKEN_SPC
0006A0r 2  18                   clc	; also AppleSoft II
0006A1r 2  F0 3F                beq     L29F5
0006A3r 2  C9 2C                cmp     #','
0006A5r 2               ; Pre-KIM had no CLC. KIM added the CLC
0006A5r 2               ; here. Post-KIM moved the CLC up...
0006A5r 2               ; (makes no sense on KIM, liveness = 0)
0006A5r 2  F0 2E                beq     L29DE
0006A7r 2  C9 3B                cmp     #$3B
0006A9r 2  F0 4C                beq     L2A0D
0006ABr 2  20 rr rr             jsr     FRMEVL
0006AEr 2  24 66                bit     VALTYP
0006B0r 2  30 DE                bmi     PRSTRING
0006B2r 2  20 rr rr             jsr     FOUT
0006B5r 2  20 rr rr             jsr     STRLIT
0006B8r 2               .ifndef CONFIG_NO_CR
0006B8r 2                       ldy     #$00
0006B8r 2                       lda     (FAC_LAST-1),y
0006B8r 2                       clc
0006B8r 2                       adc     POSX
0006B8r 2                       cmp     Z17
0006B8r 2                       bcc     L29B1
0006B8r 2                       jsr     CRDO
0006B8r 2               L29B1:
0006B8r 2               .endif
0006B8r 2  20 rr rr             jsr     STRPRT
0006BBr 2  20 rr rr             jsr     OUTSP
0006BEr 2  D0 D3                bne     L297E ; branch always
0006C0r 2               
0006C0r 2               
0006C0r 2               L29B9:
0006C0r 2               .ifdef CBM2
0006C0r 2                       lda     #$00
0006C0r 2                       sta     INPUTBUFFER,x
0006C0r 2                       ldx     #<(INPUTBUFFER-1)
0006C0r 2                       ldy     #>(INPUTBUFFER-1)
0006C0r 2               .else
0006C0r 2  A0 00                ldy     #$00
0006C2r 2  94 12                sty     INPUTBUFFER,x
0006C4r 2  A2 11                ldx     #LINNUM+1
0006C6r 2               .endif
0006C6r 2               .ifdef CONFIG_FILE
0006C6r 2                       lda     CURDVC
0006C6r 2                       bne     L29DD
0006C6r 2               .endif
0006C6r 2               
0006C6r 2               
0006C6r 2               CRDO:
0006C6r 2               .if .def(CONFIG_PRINTNULLS) && .def(CONFIG_FILE)
0006C6r 2                       lda     CURDVC
0006C6r 2                       bne     LC9D8
0006C6r 2                       sta     POSX
0006C6r 2               LC9D8:
0006C6r 2               .endif
0006C6r 2  A9 0D                lda     #CRLF_1
0006C8r 2               .ifndef CONFIG_CBM_ALL
0006C8r 2  85 0D                sta     POSX
0006CAr 2               .endif
0006CAr 2  20 rr rr             jsr     OUTDO
0006CDr 2               CRDO2:
0006CDr 2  A9 0A                lda     #CRLF_2
0006CFr 2  20 rr rr             jsr     OUTDO
0006D2r 2               
0006D2r 2               PRINTNULLS:
0006D2r 2                 .if .def(CONFIG_NULL) || .def(CONFIG_PRINTNULLS)
0006D2r 2                   .ifdef CONFIG_FILE
0006D2r 2                   ; Although there is no statement for it,
0006D2r 2                   ; CBM1 had NULL support and ignores
0006D2r 2                   ; it when not targeting the screen,
0006D2r 2                   ; CBM2 dropped it completely.
0006D2r 2                       lda     CURDVC
0006D2r 2                       bne     L29DD
0006D2r 2                   .endif
0006D2r 2                       txa
0006D2r 2                       pha
0006D2r 2                       ldx     Z15
0006D2r 2                       beq     L29D9
0006D2r 2                       lda     #$00
0006D2r 2               L29D3:
0006D2r 2                       jsr     OUTDO
0006D2r 2                       dex
0006D2r 2                       bne     L29D3
0006D2r 2               L29D9:
0006D2r 2                       stx     POSX
0006D2r 2                       pla
0006D2r 2                       tax
0006D2r 2                 .else
0006D2r 2  49 FF                eor     #$FF
0006D4r 2                 .endif
0006D4r 2               
0006D4r 2               L29DD:
0006D4r 2  60                   rts
0006D5r 2               L29DE:
0006D5r 2  A5 0D                lda     POSX
0006D7r 2               .ifndef CONFIG_NO_CR
0006D7r 2                       cmp     Z18
0006D7r 2                       bcc     L29EA
0006D7r 2                       jsr     CRDO
0006D7r 2                       jmp     L2A0D
0006D7r 2               L29EA:
0006D7r 2               .endif
0006D7r 2  38                   sec
0006D8r 2               L29EB:
0006D8r 2               .if .def(CONFIG_CBM_ALL) || .def(AIM65)
0006D8r 2                       sbc     #$0A
0006D8r 2               .else
0006D8r 2  E9 0E                sbc     #$0E
0006DAr 2               .endif
0006DAr 2  B0 FC                bcs     L29EB
0006DCr 2  49 FF                eor     #$FF
0006DEr 2  69 01                adc     #$01
0006E0r 2  D0 10                bne     L2A08
0006E2r 2               L29F5:
0006E2r 2  08                   php
0006E3r 2  20 rr rr             jsr     GTBYTC
0006E6r 2  C9 29                cmp     #')'
0006E8r 2  D0 5C                bne     SYNERR4
0006EAr 2  28                   plp
0006EBr 2  90 06                bcc     L2A09
0006EDr 2  8A                   txa
0006EEr 2  E5 0D                sbc     POSX
0006F0r 2  90 05                bcc     L2A0D
0006F2r 2               L2A08:
0006F2r 2  AA                   tax
0006F3r 2               L2A09:
0006F3r 2  E8                   inx
0006F4r 2               L2A0A:
0006F4r 2  CA                   dex
0006F5r 2  D0 06                bne     L2A13
0006F7r 2               L2A0D:
0006F7r 2  20 CA 00             jsr     CHRGET
0006FAr 2  4C rr rr             jmp     PRINT2
0006FDr 2               L2A13:
0006FDr 2  20 rr rr             jsr     OUTSP
000700r 2  D0 F2                bne     L2A0A
000702r 2               
000702r 2               ; ----------------------------------------------------------------------------
000702r 2               ; PRINT STRING AT (Y,A)
000702r 2               ; ----------------------------------------------------------------------------
000702r 2               STROUT:
000702r 2  20 rr rr             jsr     STRLIT
000705r 2               
000705r 2               ; ----------------------------------------------------------------------------
000705r 2               ; PRINT STRING AT (FACMO,FACLO)
000705r 2               ; ----------------------------------------------------------------------------
000705r 2               STRPRT:
000705r 2  20 rr rr             jsr     FREFAC
000708r 2  AA                   tax
000709r 2  A0 00                ldy     #$00
00070Br 2  E8                   inx
00070Cr 2               L2A22:
00070Cr 2  CA                   dex
00070Dr 2  F0 C5                beq     L29DD
00070Fr 2  B1 79                lda     (INDEX),y
000711r 2  20 rr rr             jsr     OUTDO
000714r 2  C8                   iny
000715r 2  C9 0D                cmp     #$0D
000717r 2  D0 F3                bne     L2A22
000719r 2  20 rr rr             jsr     PRINTNULLS
00071Cr 2  4C rr rr             jmp     L2A22
00071Fr 2               ; ----------------------------------------------------------------------------
00071Fr 2               OUTSP:
00071Fr 2               .ifdef CONFIG_FILE
00071Fr 2                 .ifndef CBM1
00071Fr 2               ; on non-screen devices, print SPACE
00071Fr 2               ; instead of CRSR RIGHT
00071Fr 2                       lda     CURDVC
00071Fr 2                       beq     LCA40
00071Fr 2                       lda     #$20
00071Fr 2                       .byte   $2C
00071Fr 2               LCA40:
00071Fr 2                 .endif
00071Fr 2                       lda     #$1D ; CRSR RIGHT
00071Fr 2               .else
00071Fr 2  A9 20                lda     #$20
000721r 2               .endif
000721r 2  2C                   .byte   $2C
000722r 2               OUTQUES:
000722r 2  A9 3F                lda     #$3F
000724r 2               
000724r 2               ; ----------------------------------------------------------------------------
000724r 2               ; PRINT CHAR FROM (A)
000724r 2               ; ----------------------------------------------------------------------------
000724r 2               OUTDO:
000724r 2  24 6C                bit     Z14
000726r 2  30 09                bmi     L2A56
000728r 2               .if .def(CONFIG_PRINT_CR) || .def(CBM1)
000728r 2               ; Commodore forgot to remove this in CBM1
000728r 2                       pha
000728r 2               .endif
000728r 2               .ifdef CBM1
000728r 2                       cmp     #$1D ; CRSR RIGHT
000728r 2                       beq     LCA6A
000728r 2                       cmp     #$9D ; CRSR LEFT
000728r 2                       beq     LCA5A
000728r 2                       cmp     #$14 ; DEL
000728r 2                       bne     LCA64
000728r 2               LCA5A:
000728r 2                       lda     POSX
000728r 2                       beq     L2A4E
000728r 2                       lda     CURDVC
000728r 2                       bne     L2A4E
000728r 2                       dec     POSX
000728r 2               LCA64:
000728r 2                       and     #$7F
000728r 2               .endif
000728r 2               .ifndef CBM2
000728r 2  C9 20                cmp     #$20
00072Ar 2  90 02                bcc     L2A4E
00072Cr 2               .endif
00072Cr 2               LCA6A:
00072Cr 2               .ifdef CONFIG_CBM1_PATCHES
00072Cr 2                       lda     CURDVC
00072Cr 2                       jsr     PATCH6
00072Cr 2                       nop
00072Cr 2               .endif
00072Cr 2               .ifdef CONFIG_PRINT_CR
00072Cr 2                       lda     POSX
00072Cr 2                       cmp     Z17
00072Cr 2                       bne     L2A4C
00072Cr 2                       jsr     CRDO
00072Cr 2               L2A4C:
00072Cr 2               .endif
00072Cr 2               .ifndef CONFIG_CBM_ALL
00072Cr 2  E6 0D                inc     POSX
00072Er 2               .endif
00072Er 2               L2A4E:
00072Er 2               .if .def(CONFIG_PRINT_CR) || .def(CBM1)
00072Er 2               ; Commodore forgot to remove this in CBM1
00072Er 2                       pla
00072Er 2               .endif
00072Er 2               .ifdef CONFIG_MONCOUT_DESTROYS_Y
00072Er 2                       sty     DIMFLG
00072Er 2               .endif
00072Er 2               .ifdef CONFIG_IO_MSB
00072Er 2                       ora     #$80
00072Er 2               .endif
00072Er 2  20 rr rr             jsr     MONCOUT
000731r 2               .ifdef CONFIG_IO_MSB
000731r 2                       and     #$7F
000731r 2               .endif
000731r 2               .ifdef CONFIG_MONCOUT_DESTROYS_Y
000731r 2                       ldy     DIMFLG
000731r 2               .endif
000731r 2               .ifdef OSI
000731r 2                       nop
000731r 2                       nop
000731r 2                       nop
000731r 2                       nop
000731r 2               .endif
000731r 2               L2A56:
000731r 2  29 FF                and     #$FF
000733r 2               LE8F2:
000733r 2  60                   rts
000734r 2               
000734r 2               ;.include "input.s"
000734r 2               
000734r 2               .segment "MSBCODE"
000734r 2               
000734r 2               ; ----------------------------------------------------------------------------
000734r 2               ; INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
000734r 2               ; IN NUMERIC FIELD.  MUST DISTINGUISH
000734r 2               ; BETWEEN INPUT, READ, AND GET
000734r 2               ; ----------------------------------------------------------------------------
000734r 2               INPUTERR:
000734r 2  A5 6A                lda     INPUTFLG
000736r 2  F0 11                beq     RESPERR	; INPUT
000738r 2               ; without this, it treats GET errors
000738r 2               ; like READ errors
000738r 2  30 04                bmi     L2A63	; READ
00073Ar 2  A0 FF                ldy     #$FF	; GET
00073Cr 2  D0 04                bne     L2A67
00073Er 2               L2A63:
00073Er 2               .ifdef CONFIG_CBM1_PATCHES
00073Er 2                       jsr     PATCH5
00073Er 2               		nop
00073Er 2               .else
00073Er 2  A5 96                lda     Z8C
000740r 2  A4 97                ldy     Z8C+1
000742r 2               .endif
000742r 2               L2A67:
000742r 2  85 90                sta     CURLIN
000744r 2  84 91                sty     CURLIN+1
000746r 2               SYNERR4:
000746r 2  4C rr rr             jmp     SYNERR
000749r 2               RESPERR:
000749r 2               .ifdef CONFIG_FILE
000749r 2                       lda     CURDVC
000749r 2                       beq     LCA8F
000749r 2                       ldx     #ERR_BADDATA
000749r 2                       jmp     ERROR
000749r 2               LCA8F:
000749r 2               .endif
000749r 2  A9 rr                lda     #<ERRREENTRY
00074Br 2  A0 rr                ldy     #>ERRREENTRY
00074Dr 2  20 rr rr             jsr     STROUT
000750r 2  A5 94                lda     OLDTEXT
000752r 2  A4 95                ldy     OLDTEXT+1
000754r 2  85 D1                sta     TXTPTR
000756r 2  84 D2                sty     TXTPTR+1
000758r 2               RTS20:
000758r 2  60                   rts
000759r 2               
000759r 2               ; ----------------------------------------------------------------------------
000759r 2               ; "GET" STATEMENT
000759r 2               ; ----------------------------------------------------------------------------
000759r 2               GET:
000759r 2  20 rr rr             jsr     ERRDIR
00075Cr 2               ; CBM: if GET#, then switch input
00075Cr 2               .ifdef CONFIG_FILE
00075Cr 2                       cmp     #'#'
00075Cr 2                       bne     LCAB6
00075Cr 2                       jsr     CHRGET
00075Cr 2                       jsr     GETBYT
00075Cr 2                       lda     #','
00075Cr 2                       jsr     SYNCHR
00075Cr 2                       jsr     CHKIN
00075Cr 2                       stx     CURDVC
00075Cr 2               LCAB6:
00075Cr 2                       ldx     #<(INPUTBUFFER+1)
00075Cr 2                       ldy     #>(INPUTBUFFER+1)
00075Cr 2               .ifdef CONFIG_NO_INPUTBUFFER_ZP
00075Cr 2                       lda     #$00
00075Cr 2                       sta     INPUTBUFFER+1
00075Cr 2               .else
00075Cr 2                       sty     INPUTBUFFER+1
00075Cr 2               .endif
00075Cr 2                       lda     #$40
00075Cr 2                       jsr     PROCESS_INPUT_LIST
00075Cr 2               ; CBM: if GET#, then switch input back
00075Cr 2               .ifdef CONFIG_FILE
00075Cr 2                       ldx     CURDVC
00075Cr 2                       bne     LCAD8
00075Cr 2               .endif
00075Cr 2                       rts
00075Cr 2               .endif
00075Cr 2               
00075Cr 2               ; ----------------------------------------------------------------------------
00075Cr 2               ; "INPUT#" STATEMENT
00075Cr 2               ; ----------------------------------------------------------------------------
00075Cr 2               .ifdef CONFIG_FILE
00075Cr 2               INPUTH:
00075Cr 2                       jsr     GETBYT
00075Cr 2                       lda     #$2C
00075Cr 2                       jsr     SYNCHR
00075Cr 2                       jsr     CHKIN
00075Cr 2                       stx     CURDVC
00075Cr 2                       jsr     L2A9E
00075Cr 2               LCAD6:
00075Cr 2                       lda     CURDVC
00075Cr 2               LCAD8:
00075Cr 2                       jsr     CLRCH
00075Cr 2                       ldx     #$00
00075Cr 2                       stx     CURDVC
00075Cr 2                       rts
00075Cr 2               LCAE0:
00075Cr 2               .endif
00075Cr 2               
00075Cr 2               
00075Cr 2               ; ----------------------------------------------------------------------------
00075Cr 2               ; "INPUT" STATEMENT
00075Cr 2               ; ----------------------------------------------------------------------------
00075Cr 2               INPUT:
00075Cr 2  46 6C                lsr     Z14
00075Er 2  C9 22                cmp     #$22
000760r 2  D0 0B                bne     L2A9E
000762r 2  20 rr rr             jsr     STRTXT
000765r 2  A9 3B                lda     #$3B
000767r 2  20 rr rr             jsr     SYNCHR
00076Ar 2  20 rr rr             jsr     STRPRT
00076Dr 2               L2A9E:
00076Dr 2  20 rr rr             jsr     ERRDIR
000770r 2  A9 2C                lda     #$2C
000772r 2  85 11                sta     INPUTBUFFER-1
000774r 2               LCAF8:
000774r 2  20 rr rr             jsr     NXIN
000777r 2                 .ifdef CONFIG_FILE
000777r 2                       lda     CURDVC
000777r 2                       beq     LCB0C
000777r 2                       lda     Z96
000777r 2                       and     #$02
000777r 2                       beq     LCB0C
000777r 2                       jsr     LCAD6
000777r 2                       jmp     DATA
000777r 2               LCB0C:
000777r 2                 .endif
000777r 2  A5 12                lda     INPUTBUFFER
000779r 2  D0 12                bne     L2ABE
00077Br 2                 .ifdef CONFIG_FILE
00077Br 2                       lda     CURDVC
00077Br 2                       bne     LCAF8
00077Br 2                 .endif
00077Br 2                 .ifdef CONFIG_CBM1_PATCHES
00077Br 2                       jmp     PATCH1
00077Br 2                 .else
00077Br 2  18                   clc
00077Cr 2  4C rr rr             jmp     CONTROL_C_TYPED
00077Fr 2                 .endif
00077Fr 2               
00077Fr 2               NXIN:
00077Fr 2                 .ifdef CONFIG_FILE
00077Fr 2                       lda     CURDVC
00077Fr 2                       bne     LCB21
00077Fr 2                 .endif
00077Fr 2  20 rr rr             jsr     OUTQUES	; '?'
000782r 2  20 rr rr             jsr     OUTSP
000785r 2               LCB21:
000785r 2  4C rr rr             jmp     INLIN
000788r 2               
000788r 2               
000788r 2               ; ----------------------------------------------------------------------------
000788r 2               ; "READ" STATEMENT
000788r 2               ; ----------------------------------------------------------------------------
000788r 2               READ:
000788r 2  A6 98                ldx     DATPTR
00078Ar 2  A4 99                ldy     DATPTR+1
00078Cr 2               .ifdef CONFIG_NO_READ_Y_IS_ZERO_HACK
00078Cr 2               ; AppleSoft II, too
00078Cr 2                       lda     #$98	; READ
00078Cr 2                       .byte   $2C
00078Cr 2               L2ABE:
00078Cr 2                       lda     #$00	; INPUT
00078Cr 2               .else
00078Cr 2  A9                   .byte   $A9	; LDA #$98
00078Dr 2               L2ABE:
00078Dr 2  98                   tya
00078Er 2               .endif
00078Er 2               
00078Er 2               ; ----------------------------------------------------------------------------
00078Er 2               ; PROCESS INPUT LIST
00078Er 2               ;
00078Er 2               ; (Y,X) IS ADDRESS OF INPUT DATA STRING
00078Er 2               ; (A) = VALUE FOR INPUTFLG:  $00 FOR INPUT
00078Er 2               ; 				$40 FOR GET
00078Er 2               ;				$98 FOR READ
00078Er 2               ; ----------------------------------------------------------------------------
00078Er 2               PROCESS_INPUT_LIST:
00078Er 2  85 6A                sta     INPUTFLG
000790r 2  86 9A                stx     INPTR
000792r 2  84 9B                sty     INPTR+1
000794r 2               PROCESS_INPUT_ITEM:
000794r 2  20 rr rr             jsr     PTRGET
000797r 2  85 A0                sta     FORPNT
000799r 2  84 A1                sty     FORPNT+1
00079Br 2  A5 D1                lda     TXTPTR
00079Dr 2  A4 D2                ldy     TXTPTR+1
00079Fr 2  85 10                sta     TXPSV
0007A1r 2  84 11                sty     TXPSV+1
0007A3r 2  A6 9A                ldx     INPTR
0007A5r 2  A4 9B                ldy     INPTR+1
0007A7r 2  86 D1                stx     TXTPTR
0007A9r 2  84 D2                sty     TXTPTR+1
0007ABr 2  20 D0 00             jsr     CHRGOT
0007AEr 2  D0 1B                bne     INSTART
0007B0r 2  24 6A                bit     INPUTFLG
0007B2r 2  50 0B                bvc     L2AF0
0007B4r 2  20 rr rr             jsr     MONRDKEY
0007B7r 2                 .ifdef CONFIG_IO_MSB
0007B7r 2                       and     #$7F
0007B7r 2                 .endif
0007B7r 2  85 12                sta     INPUTBUFFER
0007B9r 2               ; BUG: The beq/bne L2AF8 below is supposed
0007B9r 2               ; to be always taken. For this to happen,
0007B9r 2               ; the last load must be a 0 for beq
0007B9r 2               ; and != 0 for bne. The original Microsoft
0007B9r 2               ; code had ldx/ldy/bne here, which was only
0007B9r 2               ; correct for a non-ZP INPUTBUFFER. Commodore
0007B9r 2               ; fixed it in CBMBASIC V1 by swapping the
0007B9r 2               ; ldx and the ldy. It was broken on KIM,
0007B9r 2               ; but okay on APPLE and CBM2, because
0007B9r 2               ; these used a non-ZP INPUTBUFFER.
0007B9r 2               ; Microsoft fixed this somewhere after KIM
0007B9r 2               ; and before MICROTAN, by using beq instead
0007B9r 2               ; of bne in the ZP case.
0007B9r 2                 .ifdef CBM1
0007B9r 2                       ldy     #>(INPUTBUFFER-1)
0007B9r 2                       ldx     #<(INPUTBUFFER-1)
0007B9r 2                 .else
0007B9r 2  A2 11                ldx     #<(INPUTBUFFER-1)
0007BBr 2  A0 00                ldy     #>(INPUTBUFFER-1)
0007BDr 2                 .endif
0007BDr 2               ;  .if .def(CONFIG_2) && (!.def(CONFIG_NO_INPUTBUFFER_ZP))
0007BDr 2  F0 08                beq     L2AF8	; always
0007BFr 2               ;  .else
0007BFr 2               ;        bne     L2AF8	; always
0007BFr 2               ;  .endif
0007BFr 2               L2AF0:
0007BFr 2  30 71                bmi     FINDATA
0007C1r 2               .ifdef CONFIG_FILE
0007C1r 2                       lda     CURDVC
0007C1r 2                       bne     LCB64
0007C1r 2               .endif
0007C1r 2  20 rr rr             jsr     OUTQUES
0007C4r 2               LCB64:
0007C4r 2  20 rr rr             jsr     NXIN
0007C7r 2               L2AF8:
0007C7r 2  86 D1                stx     TXTPTR
0007C9r 2  84 D2                sty     TXTPTR+1
0007CBr 2               
0007CBr 2               ; ----------------------------------------------------------------------------
0007CBr 2               INSTART:
0007CBr 2  20 CA 00             jsr     CHRGET
0007CEr 2  24 66                bit     VALTYP
0007D0r 2  10 31                bpl     L2B34
0007D2r 2  24 6A                bit     INPUTFLG
0007D4r 2  50 09                bvc     L2B10
0007D6r 2                 .ifdef CONFIG_CBM1_PATCHES
0007D6r 2                       lda     #$00
0007D6r 2                       jsr     PATCH4
0007D6r 2                       nop
0007D6r 2                 .else
0007D6r 2  E8                   inx
0007D7r 2  86 D1                stx     TXTPTR
0007D9r 2  A9 00                lda     #$00
0007DBr 2  85 62                sta     CHARAC
0007DDr 2  F0 0C                beq     L2B1C
0007DFr 2                 .endif
0007DFr 2               L2B10:
0007DFr 2  85 62                sta     CHARAC
0007E1r 2  C9 22                cmp     #$22
0007E3r 2  F0 07                beq     L2B1D
0007E5r 2  A9 3A                lda     #$3A
0007E7r 2  85 62                sta     CHARAC
0007E9r 2  A9 2C                lda     #$2C
0007EBr 2               L2B1C:
0007EBr 2  18                   clc
0007ECr 2               L2B1D:
0007ECr 2  85 63                sta     ENDCHR
0007EEr 2  A5 D1                lda     TXTPTR
0007F0r 2  A4 D2                ldy     TXTPTR+1
0007F2r 2  69 00                adc     #$00
0007F4r 2  90 01                bcc     L2B28
0007F6r 2  C8                   iny
0007F7r 2               L2B28:
0007F7r 2  20 rr rr             jsr     STRLT2
0007FAr 2  20 rr rr             jsr     POINT
0007FDr 2  20 rr rr             jsr     PUTSTR
000800r 2  4C rr rr             jmp     INPUT_MORE
000803r 2               ; ----------------------------------------------------------------------------
000803r 2               L2B34:
000803r 2  20 rr rr             jsr     FIN
000806r 2  A5 67                lda     VALTYP+1
000808r 2  20 rr rr             jsr     LET2
00080Br 2               ; ----------------------------------------------------------------------------
00080Br 2               INPUT_MORE:
00080Br 2  20 D0 00             jsr     CHRGOT
00080Er 2  F0 07                beq     L2B48
000810r 2  C9 2C                cmp     #$2C
000812r 2  F0 03                beq     L2B48
000814r 2  4C rr rr             jmp     INPUTERR
000817r 2               L2B48:
000817r 2  A5 D1                lda     TXTPTR
000819r 2  A4 D2                ldy     TXTPTR+1
00081Br 2  85 9A                sta     INPTR
00081Dr 2  84 9B                sty     INPTR+1
00081Fr 2  A5 10                lda     TXPSV
000821r 2  A4 11                ldy     TXPSV+1
000823r 2  85 D1                sta     TXTPTR
000825r 2  84 D2                sty     TXTPTR+1
000827r 2  20 D0 00             jsr     CHRGOT
00082Ar 2  F0 2C                beq     INPDONE
00082Cr 2  20 rr rr             jsr     CHKCOM
00082Fr 2  4C rr rr             jmp     PROCESS_INPUT_ITEM
000832r 2               ; ----------------------------------------------------------------------------
000832r 2               FINDATA:
000832r 2  20 rr rr             jsr     DATAN
000835r 2  C8                   iny
000836r 2  AA                   tax
000837r 2  D0 12                bne     L2B7C
000839r 2  A2 2A                ldx     #ERR_NODATA
00083Br 2  C8                   iny
00083Cr 2  B1 D1                lda     (TXTPTR),y
00083Er 2  F0 69                beq     GERR
000840r 2  C8                   iny
000841r 2  B1 D1                lda     (TXTPTR),y
000843r 2  85 96                sta     Z8C
000845r 2  C8                   iny
000846r 2  B1 D1                lda     (TXTPTR),y
000848r 2  C8                   iny
000849r 2  85 97                sta     Z8C+1
00084Br 2               L2B7C:
00084Br 2  B1 D1                lda     (TXTPTR),y
00084Dr 2  AA                   tax
00084Er 2  20 rr rr             jsr     ADDON
000851r 2  E0 83                cpx     #$83
000853r 2  D0 DD                bne     FINDATA
000855r 2  4C rr rr             jmp     INSTART
000858r 2               ; ---NO MORE INPUT REQUESTED------
000858r 2               INPDONE:
000858r 2  A5 9A                lda     INPTR
00085Ar 2  A4 9B                ldy     INPTR+1
00085Cr 2  A6 6A                ldx     INPUTFLG
00085Er 2  10 03                bpl     L2B94; INPUT or GET
000860r 2  4C rr rr             jmp     SETDA
000863r 2               L2B94:
000863r 2  A0 00                ldy     #$00
000865r 2  B1 9A                lda     (INPTR),y
000867r 2  F0 07                beq     L2BA1
000869r 2               .ifdef CONFIG_FILE
000869r 2                       lda     CURDVC
000869r 2                       bne     L2BA1
000869r 2               .endif
000869r 2  A9 rr                lda     #<ERREXTRA
00086Br 2  A0 rr                ldy     #>ERREXTRA
00086Dr 2  4C rr rr             jmp     STROUT
000870r 2               L2BA1:
000870r 2  60                   rts
000871r 2               
000871r 2               ; ----------------------------------------------------------------------------
000871r 2               ERREXTRA:
000871r 2  3F 45 58 54          .byte   "?EXTRA IGNORED"
000875r 2  52 41 20 49  
000879r 2  47 4E 4F 52  
00087Fr 2  0D 0A 00             .byte   $0D,$0A,$00
000882r 2               ERRREENTRY:
000882r 2  3F 52 45 44          .byte   "?REDO FROM START"
000886r 2  4F 20 46 52  
00088Ar 2  4F 4D 20 53  
000892r 2  0D 0A 00             .byte   $0D,$0A,$00
000895r 2               
000895r 2               ;.include "eval.s"
000895r 2               
000895r 2               .segment "MSBCODE"
000895r 2               
000895r 2               ; ----------------------------------------------------------------------------
000895r 2               ; "NEXT" STATEMENT
000895r 2               ; ----------------------------------------------------------------------------
000895r 2               NEXT:
000895r 2  D0 04                bne     NEXT1
000897r 2  A0 00                ldy     #$00
000899r 2  F0 03                beq     NEXT2
00089Br 2               NEXT1:
00089Br 2  20 rr rr             jsr     PTRGET
00089Er 2               NEXT2:
00089Er 2  85 A0                sta     FORPNT
0008A0r 2  84 A1                sty     FORPNT+1
0008A2r 2  20 rr rr             jsr     GTFORPNT
0008A5r 2  F0 04                beq     NEXT3
0008A7r 2  A2 00                ldx     #$00
0008A9r 2               GERR:
0008A9r 2  F0 66                beq     JERROR
0008ABr 2               NEXT3:
0008ABr 2  9A                   txs
0008ACr 2  8A                   txa
0008ADr 2  18                   clc
0008AEr 2  69 04                adc     #$04
0008B0r 2  48                   pha
0008B1r 2  69 06                adc     #BYTES_FP+1
0008B3r 2  85 7B                sta     DEST
0008B5r 2  68                   pla
0008B6r 2  A0 01                ldy     #>STACK
0008B8r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
0008BBr 2  BA                   tsx
0008BCr 2  BD 09 01             lda     STACK+BYTES_FP+4,x
0008BFr 2  85 BD                sta     FACSIGN
0008C1r 2  A5 A0                lda     FORPNT
0008C3r 2  A4 A1                ldy     FORPNT+1
0008C5r 2  20 rr rr             jsr     FADD
0008C8r 2  20 rr rr             jsr     SETFOR
0008CBr 2  A0 01                ldy     #>STACK
0008CDr 2  20 rr rr             jsr     FCOMP2
0008D0r 2  BA                   tsx
0008D1r 2  38                   sec
0008D2r 2  FD 09 01             sbc     STACK+BYTES_FP+4,x
0008D5r 2  F0 17                beq     L2C22
0008D7r 2  BD 0F 01             lda     STACK+2*BYTES_FP+5,x
0008DAr 2  85 90                sta     CURLIN
0008DCr 2  BD 10 01             lda     STACK+2*BYTES_FP+6,x
0008DFr 2  85 91                sta     CURLIN+1
0008E1r 2  BD 12 01             lda     STACK+2*BYTES_FP+8,x
0008E4r 2  85 D1                sta     TXTPTR
0008E6r 2  BD 11 01             lda     STACK+2*BYTES_FP+7,x
0008E9r 2  85 D2                sta     TXTPTR+1
0008EBr 2               L2C1F:
0008EBr 2  4C rr rr             jmp     NEWSTT
0008EEr 2               L2C22:
0008EEr 2  8A                   txa
0008EFr 2  69 11                adc     #2*BYTES_FP+7
0008F1r 2  AA                   tax
0008F2r 2  9A                   txs
0008F3r 2  20 D0 00             jsr     CHRGOT
0008F6r 2  C9 2C                cmp     #$2C
0008F8r 2  D0 F1                bne     L2C1F
0008FAr 2  20 CA 00             jsr     CHRGET
0008FDr 2  20 rr rr             jsr     NEXT1
000900r 2               
000900r 2               ; ----------------------------------------------------------------------------
000900r 2               ; EVALUATE EXPRESSION, MAKE SURE IT IS NUMERIC
000900r 2               ; ----------------------------------------------------------------------------
000900r 2               FRMNUM:
000900r 2  20 rr rr             jsr     FRMEVL
000903r 2               
000903r 2               ; ----------------------------------------------------------------------------
000903r 2               ; MAKE SURE (FAC) IS NUMERIC
000903r 2               ; ----------------------------------------------------------------------------
000903r 2               CHKNUM:
000903r 2  18                   clc
000904r 2  24                   .byte   $24
000905r 2               
000905r 2               ; ----------------------------------------------------------------------------
000905r 2               ; MAKE SURE (FAC) IS STRING
000905r 2               ; ----------------------------------------------------------------------------
000905r 2               CHKSTR:
000905r 2  38                   sec
000906r 2               
000906r 2               ; ----------------------------------------------------------------------------
000906r 2               ; MAKE SURE (FAC) IS CORRECT TYPE
000906r 2               ; IF C=0, TYPE MUST BE NUMERIC
000906r 2               ; IF C=1, TYPE MUST BE STRING
000906r 2               ; ----------------------------------------------------------------------------
000906r 2               CHKVAL:
000906r 2  24 66                bit     VALTYP
000908r 2  30 03                bmi     L2C41
00090Ar 2  B0 03                bcs     L2C43
00090Cr 2               L2C40:
00090Cr 2  60                   rts
00090Dr 2               L2C41:
00090Dr 2  B0 FD                bcs     L2C40
00090Fr 2               L2C43:
00090Fr 2  A2 A3                ldx     #ERR_BADTYPE
000911r 2               JERROR:
000911r 2  4C rr rr             jmp     ERROR
000914r 2               
000914r 2               ; ----------------------------------------------------------------------------
000914r 2               ; EVALUATE THE EXPRESSION AT TXTPTR, LEAVING THE
000914r 2               ; RESULT IN FAC.  WORKS FOR BOTH STRING AND NUMERIC
000914r 2               ; EXPRESSIONS.
000914r 2               ; ----------------------------------------------------------------------------
000914r 2               FRMEVL:
000914r 2  A6 D1                ldx     TXTPTR
000916r 2  D0 02                bne     L2C4E
000918r 2  C6 D2                dec     TXTPTR+1
00091Ar 2               L2C4E:
00091Ar 2  C6 D1                dec     TXTPTR
00091Cr 2  A2 00                ldx     #$00
00091Er 2  24                   .byte   $24
00091Fr 2               FRMEVL1:
00091Fr 2  48                   pha
000920r 2  8A                   txa
000921r 2  48                   pha
000922r 2  A9 01                lda     #$01
000924r 2  20 rr rr             jsr     CHKMEM
000927r 2  20 rr rr             jsr     FRM_ELEMENT
00092Ar 2  A9 00                lda     #$00
00092Cr 2  85 A4                sta     CPRTYP
00092Er 2               FRMEVL2:
00092Er 2  20 D0 00             jsr     CHRGOT
000931r 2               L2C65:
000931r 2  38                   sec
000932r 2  E9 AA                sbc     #TOKEN_GREATER
000934r 2  90 17                bcc     L2C81
000936r 2  C9 03                cmp     #$03
000938r 2  B0 13                bcs     L2C81
00093Ar 2  C9 01                cmp     #$01
00093Cr 2  2A                   rol     a
00093Dr 2  49 01                eor     #$01
00093Fr 2  45 A4                eor     CPRTYP
000941r 2  C5 A4                cmp     CPRTYP
000943r 2  90 61                bcc     SNTXERR
000945r 2  85 A4                sta     CPRTYP
000947r 2  20 CA 00             jsr     CHRGET
00094Ar 2  4C rr rr             jmp     L2C65
00094Dr 2               L2C81:
00094Dr 2  A6 A4                ldx     CPRTYP
00094Fr 2  D0 2C                bne     FRM_RELATIONAL
000951r 2  B0 7F                bcs     L2D02
000953r 2  69 07                adc     #$07
000955r 2  90 7B                bcc     L2D02
000957r 2  65 66                adc     VALTYP
000959r 2  D0 03                bne     L2C92
00095Br 2  4C rr rr             jmp     CAT
00095Er 2               L2C92:
00095Er 2  69 FF                adc     #$FF
000960r 2  85 79                sta     INDEX
000962r 2  0A                   asl     a
000963r 2  65 79                adc     INDEX
000965r 2  A8                   tay
000966r 2               FRM_PRECEDENCE_TEST:
000966r 2  68                   pla
000967r 2  D9 rr rr             cmp     MATHTBL,y
00096Ar 2  B0 6B                bcs     FRM_PERFORM1
00096Cr 2  20 rr rr             jsr     CHKNUM
00096Fr 2               L2CA3:
00096Fr 2  48                   pha
000970r 2               L2CA4:
000970r 2  20 rr rr             jsr     FRM_RECURSE
000973r 2  68                   pla
000974r 2  A4 A2                ldy     LASTOP
000976r 2  10 17                bpl     PREFNC
000978r 2  AA                   tax
000979r 2  F0 5A                beq     GOEX
00097Br 2  D0 63                bne     FRM_PERFORM2
00097Dr 2               
00097Dr 2               ; ----------------------------------------------------------------------------
00097Dr 2               ; FOUND ONE OR MORE RELATIONAL OPERATORS <,=,>
00097Dr 2               ; ----------------------------------------------------------------------------
00097Dr 2               FRM_RELATIONAL:
00097Dr 2  46 66                lsr     VALTYP
00097Fr 2  8A                   txa
000980r 2  2A                   rol     a
000981r 2  A6 D1                ldx     TXTPTR
000983r 2  D0 02                bne     L2CBB
000985r 2  C6 D2                dec     TXTPTR+1
000987r 2               L2CBB:
000987r 2  C6 D1                dec     TXTPTR
000989r 2  A0 1B                ldy     #$1B
00098Br 2  85 A4                sta     CPRTYP
00098Dr 2  D0 D7                bne     FRM_PRECEDENCE_TEST
00098Fr 2               PREFNC:
00098Fr 2  D9 rr rr             cmp     MATHTBL,y
000992r 2  B0 4C                bcs     FRM_PERFORM2
000994r 2  90 D9                bcc     L2CA3
000996r 2               
000996r 2               ; ----------------------------------------------------------------------------
000996r 2               ; STACK THIS OPERATION AND CALL FRMEVL FOR
000996r 2               ; ANOTHER ONE
000996r 2               ; ----------------------------------------------------------------------------
000996r 2               FRM_RECURSE:
000996r 2  B9 rr rr             lda     MATHTBL+2,y
000999r 2  48                   pha
00099Ar 2  B9 rr rr             lda     MATHTBL+1,y
00099Dr 2  48                   pha
00099Er 2  20 rr rr             jsr     FRM_STACK1
0009A1r 2  A5 A4                lda     CPRTYP
0009A3r 2  4C rr rr             jmp     FRMEVL1
0009A6r 2               SNTXERR:
0009A6r 2  4C rr rr             jmp     SYNERR
0009A9r 2               
0009A9r 2               ; ----------------------------------------------------------------------------
0009A9r 2               ; STACK (FAC)
0009A9r 2               ; THREE ENTRY POINTS:
0009A9r 2               ; 	1, FROM FRMEVL
0009A9r 2               ;	2, FROM "STEP"
0009A9r 2               ;	3, FROM "FOR"
0009A9r 2               ; ----------------------------------------------------------------------------
0009A9r 2               FRM_STACK1:
0009A9r 2  A5 BD                lda     FACSIGN
0009ABr 2  BE rr rr             ldx     MATHTBL,y
0009AEr 2               
0009AEr 2               ; ----------------------------------------------------------------------------
0009AEr 2               ; ENTER HERE FROM "STEP", TO PUSH STEP SIGN AND VALUE
0009AEr 2               ; ----------------------------------------------------------------------------
0009AEr 2               FRM_STACK2:
0009AEr 2  A8                   tay
0009AFr 2  68                   pla
0009B0r 2  85 79                sta     INDEX
0009B2r 2  68                   pla
0009B3r 2  85 7A                sta     INDEX+1
0009B5r 2  E6 79                inc     INDEX
0009B7r 2  D0 02                bne     LEB69
0009B9r 2  E6 7A                inc     INDEX+1
0009BBr 2               LEB69:
0009BBr 2  98                   tya
0009BCr 2  48                   pha
0009BDr 2               
0009BDr 2               ; ----------------------------------------------------------------------------
0009BDr 2               ; ENTER HERE FROM "FOR", WITH (INDEX) = STEP,
0009BDr 2               ; TO PUSH INITIAL VALUE OF "FOR" VARIABLE
0009BDr 2               ; ----------------------------------------------------------------------------
0009BDr 2               FRM_STACK3:
0009BDr 2  20 rr rr             jsr     ROUND_FAC
0009C0r 2  A5 BC                lda     FAC+4
0009C2r 2  48                   pha
0009C3r 2  A5 BB                lda     FAC+3
0009C5r 2  48                   pha
0009C6r 2  A5 BA                lda     FAC+2
0009C8r 2  48                   pha
0009C9r 2  A5 B9                lda     FAC+1
0009CBr 2  48                   pha
0009CCr 2  A5 B8                lda     FAC
0009CEr 2  48                   pha
0009CFr 2  6C 79 00             jmp     (INDEX)
0009D2r 2               L2D02:
0009D2r 2  A0 FF                ldy     #$FF
0009D4r 2  68                   pla
0009D5r 2               GOEX:
0009D5r 2  F0 23                beq     EXIT
0009D7r 2               
0009D7r 2               ; ----------------------------------------------------------------------------
0009D7r 2               ; PERFORM STACKED OPERATION
0009D7r 2               ;
0009D7r 2               ; (A) = PRECEDENCE BYTE
0009D7r 2               ; STACK:  1 -- CPRMASK
0009D7r 2               ;	5 -- (ARG)
0009D7r 2               ;	2 -- ADDR OF PERFORMER
0009D7r 2               ; ----------------------------------------------------------------------------
0009D7r 2               FRM_PERFORM1:
0009D7r 2  C9 64                cmp     #$64
0009D9r 2  F0 03                beq     L2D0E
0009DBr 2  20 rr rr             jsr     CHKNUM
0009DEr 2               L2D0E:
0009DEr 2  84 A2                sty     LASTOP
0009E0r 2               FRM_PERFORM2:
0009E0r 2  68                   pla
0009E1r 2  4A                   lsr     a
0009E2r 2  85 6B                sta     CPRMASK
0009E4r 2  68                   pla
0009E5r 2  85 C0                sta     ARG
0009E7r 2  68                   pla
0009E8r 2  85 C1                sta     ARG+1
0009EAr 2  68                   pla
0009EBr 2  85 C2                sta     ARG+2
0009EDr 2  68                   pla
0009EEr 2  85 C3                sta     ARG+3
0009F0r 2  68                   pla
0009F1r 2  85 C4                sta     ARG+4
0009F3r 2  68                   pla
0009F4r 2  85 C5                sta     ARGSIGN
0009F6r 2  45 BD                eor     FACSIGN
0009F8r 2  85 C6                sta     SGNCPR
0009FAr 2               EXIT:
0009FAr 2  A5 B8                lda     FAC
0009FCr 2  60                   rts
0009FDr 2               
0009FDr 2               ; ----------------------------------------------------------------------------
0009FDr 2               ; GET ELEMENT IN EXPRESSION
0009FDr 2               ;
0009FDr 2               ; GET VALUE OF VARIABLE OR NUMBER AT TXTPNT, OR POINT
0009FDr 2               ; TO STRING DESCRIPTOR IF A STRING, AND PUT IN FAC.
0009FDr 2               ; ----------------------------------------------------------------------------
0009FDr 2               FRM_ELEMENT:
0009FDr 2  A9 00                lda     #$00
0009FFr 2  85 66                sta     VALTYP
000A01r 2               L2D31:
000A01r 2  20 CA 00             jsr     CHRGET
000A04r 2  B0 03                bcs     L2D39
000A06r 2               L2D36:
000A06r 2  4C rr rr             jmp     FIN
000A09r 2               L2D39:
000A09r 2  20 rr rr             jsr     ISLETC
000A0Cr 2  B0 67                bcs     FRM_VARIABLE
000A0Er 2               .ifdef CONFIG_CBM_ALL
000A0Er 2                       cmp     #$FF
000A0Er 2                       bne     LCDC1
000A0Er 2                       lda     #<CON_PI
000A0Er 2                       ldy     #>CON_PI
000A0Er 2                       jsr     LOAD_FAC_FROM_YA
000A0Er 2                       jmp     CHRGET
000A0Er 2               CON_PI:
000A0Er 2                       .byte   $82,$49,$0f,$DA,$A1
000A0Er 2               LCDC1:
000A0Er 2               .endif
000A0Er 2  C9 2E                cmp     #$2E
000A10r 2  F0 F4                beq     L2D36
000A12r 2  C9 A4                cmp     #TOKEN_MINUS
000A14r 2  F0 58                beq     MIN
000A16r 2  C9 A3                cmp     #TOKEN_PLUS
000A18r 2  F0 E7                beq     L2D31
000A1Ar 2  C9 22                cmp     #$22
000A1Cr 2  D0 0F                bne     NOT_
000A1Er 2               
000A1Er 2               ; ----------------------------------------------------------------------------
000A1Er 2               ; STRING CONSTANT ELEMENT
000A1Er 2               ;
000A1Er 2               ; SET Y,A = (TXTPTR)+CARRY
000A1Er 2               ; ----------------------------------------------------------------------------
000A1Er 2               STRTXT:
000A1Er 2  A5 D1                lda     TXTPTR
000A20r 2  A4 D2                ldy     TXTPTR+1
000A22r 2  69 00                adc     #$00
000A24r 2  90 01                bcc     L2D57
000A26r 2  C8                   iny
000A27r 2               L2D57:
000A27r 2  20 rr rr             jsr     STRLIT
000A2Ar 2  4C rr rr             jmp     POINT
000A2Dr 2               
000A2Dr 2               ; ----------------------------------------------------------------------------
000A2Dr 2               ; "NOT" FUNCTION
000A2Dr 2               ; IF FAC=0, RETURN FAC=1
000A2Dr 2               ; IF FAC<>0, RETURN FAC=0
000A2Dr 2               ; ----------------------------------------------------------------------------
000A2Dr 2               NOT_:
000A2Dr 2  C9 A1                cmp     #TOKEN_NOT
000A2Fr 2  D0 13                bne     L2D74
000A31r 2  A0 18                ldy     #$18
000A33r 2  D0 3B                bne     EQUL
000A35r 2               
000A35r 2               ; ----------------------------------------------------------------------------
000A35r 2               ; COMPARISON FOR EQUALITY (= OPERATOR)
000A35r 2               ; ALSO USED TO EVALUATE "NOT" FUNCTION
000A35r 2               ; ----------------------------------------------------------------------------
000A35r 2               EQUOP:
000A35r 2  20 rr rr             jsr     AYINT
000A38r 2  A5 BC                lda     FAC_LAST
000A3Ar 2  49 FF                eor     #$FF
000A3Cr 2  A8                   tay
000A3Dr 2  A5 BB                lda     FAC_LAST-1
000A3Fr 2  49 FF                eor     #$FF
000A41r 2  4C rr rr             jmp     GIVAYF
000A44r 2               L2D74:
000A44r 2  C9 9E                cmp     #TOKEN_FN
000A46r 2  D0 03                bne     L2D7B
000A48r 2  4C rr rr             jmp     L31F3
000A4Br 2               L2D7B:
000A4Br 2  C9 AD                cmp     #TOKEN_SGN
000A4Dr 2  90 03                bcc     PARCHK
000A4Fr 2  4C rr rr             jmp     UNARY
000A52r 2               
000A52r 2               ; ----------------------------------------------------------------------------
000A52r 2               ; EVALUATE "(EXPRESSION)"
000A52r 2               ; ----------------------------------------------------------------------------
000A52r 2               PARCHK:
000A52r 2  20 rr rr             jsr     CHKOPN
000A55r 2  20 rr rr             jsr     FRMEVL
000A58r 2               CHKCLS:
000A58r 2  A9 29                lda     #$29
000A5Ar 2  2C                   .byte   $2C
000A5Br 2               CHKOPN:
000A5Br 2  A9 28                lda     #$28
000A5Dr 2  2C                   .byte   $2C
000A5Er 2               CHKCOM:
000A5Er 2  A9 2C                lda     #$2C
000A60r 2               
000A60r 2               ; ----------------------------------------------------------------------------
000A60r 2               ; UNLESS CHAR AT TXTPTR = (A), SYNTAX ERROR
000A60r 2               ; ----------------------------------------------------------------------------
000A60r 2               SYNCHR:	; XXX all CBM code calls SYNCHR instead of CHKCOM
000A60r 2  A0 00                ldy     #$00
000A62r 2  D1 D1                cmp     (TXTPTR),y
000A64r 2  D0 03                bne     SYNERR
000A66r 2  4C CA 00             jmp     CHRGET
000A69r 2               ; ----------------------------------------------------------------------------
000A69r 2               SYNERR:
000A69r 2  A2 10                ldx     #ERR_SYNTAX
000A6Br 2  4C rr rr             jmp     ERROR
000A6Er 2               ; ----------------------------------------------------------------------------
000A6Er 2               MIN:
000A6Er 2  A0 15                ldy     #$15
000A70r 2               EQUL:
000A70r 2  68                   pla
000A71r 2  68                   pla
000A72r 2  4C rr rr             jmp     L2CA4
000A75r 2               ; ----------------------------------------------------------------------------
000A75r 2               FRM_VARIABLE:
000A75r 2  20 rr rr             jsr     PTRGET
000A78r 2               FRM_VARIABLE_CALL	= *-1
000A78r 2  85 BB                sta     FAC_LAST-1
000A7Ar 2  84 BC                sty     FAC_LAST
000A7Cr 2               .ifdef CONFIG_CBM_ALL
000A7Cr 2                       lda     VARNAM
000A7Cr 2                       ldy     VARNAM+1
000A7Cr 2               .endif
000A7Cr 2  A6 66                ldx     VALTYP
000A7Er 2  F0 05                beq     L2DB1
000A80r 2               .ifdef CONFIG_CBM_ALL
000A80r 2                 .ifdef CONFIG_CBM1_PATCHES
000A80r 2                       jmp     PATCH2
000A80r 2                       clc
000A80r 2               LCE3B:
000A80r 2                 .else
000A80r 2                       ldx     #$00
000A80r 2                       stx     STRNG1+1
000A80r 2                       bit     FAC+4
000A80r 2                       bpl     LCE53
000A80r 2                       cmp     #$54	; T
000A80r 2                       bne     LCE53
000A80r 2                 .endif
000A80r 2                       cpy     #$C9	; I$
000A80r 2                       bne     LCE53
000A80r 2                       jsr     LCE76
000A80r 2                       sty     EXPON
000A80r 2                       dey
000A80r 2                       sty     STRNG2
000A80r 2                       ldy     #$06
000A80r 2                       sty     INDX
000A80r 2                       ldy     #$24
000A80r 2                       jsr     LDD3A
000A80r 2                       jmp     LD353
000A80r 2               LCE53:
000A80r 2               .endif
000A80r 2                 .ifndef CBM2
000A80r 2               ; bugfix?
000A80r 2               ; fixed on AppleSoft II, not on any CBM
000A80r 2  A2 00                ldx     #$00
000A82r 2  86 C7                stx     STRNG1+1
000A84r 2                 .endif
000A84r 2  60                   rts
000A85r 2               L2DB1:
000A85r 2  A6 67                ldx     VALTYP+1
000A87r 2  10 0D                bpl     L2DC2
000A89r 2  A0 00                ldy     #$00
000A8Br 2  B1 BB                lda     (FAC+3),y
000A8Dr 2  AA                   tax
000A8Er 2  C8                   iny
000A8Fr 2  B1 BB                lda     (FAC+3),y
000A91r 2  A8                   tay
000A92r 2  8A                   txa
000A93r 2  4C rr rr             jmp     GIVAYF
000A96r 2               L2DC2:
000A96r 2               .ifdef CONFIG_CBM1_PATCHES
000A96r 2                       jmp     PATCH3
000A96r 2                       .byte   $19
000A96r 2               .endif
000A96r 2               .ifdef CBM2
000A96r 2                       bit     FAC+4
000A96r 2                       bpl     LCE90
000A96r 2                       cmp     #$54
000A96r 2                       bne     LCE82
000A96r 2               .endif
000A96r 2               .ifndef CONFIG_CBM_ALL
000A96r 2  4C rr rr             jmp     LOAD_FAC_FROM_YA
000A99r 2               .endif
000A99r 2               .ifdef CONFIG_CBM_ALL
000A99r 2               LCE69:
000A99r 2                       cpy     #$49
000A99r 2               .ifdef CBM1
000A99r 2                       bne     LCE82
000A99r 2               .else
000A99r 2                       bne     LCE90
000A99r 2               .endif
000A99r 2                       jsr     LCE76
000A99r 2                       tya
000A99r 2                       ldx     #$A0
000A99r 2                       jmp     LDB21
000A99r 2               LCE76:
000A99r 2               .ifdef CBM1
000A99r 2                       lda     #$FE
000A99r 2                       ldy     #$01
000A99r 2               .else
000A99r 2                       lda     #$8B
000A99r 2                       ldy     #$00
000A99r 2               .endif
000A99r 2                       sei
000A99r 2                       jsr     LOAD_FAC_FROM_YA
000A99r 2                       cli
000A99r 2                       sty     FAC+1
000A99r 2                       rts
000A99r 2               LCE82:
000A99r 2                       cmp     #$53
000A99r 2                       bne     LCE90
000A99r 2                       cpy     #$54
000A99r 2                       bne     LCE90
000A99r 2                       lda     Z96
000A99r 2                       jmp     FLOAT
000A99r 2               LCE90:
000A99r 2                       lda     FAC+3
000A99r 2                       ldy     FAC+4
000A99r 2                       jmp     LOAD_FAC_FROM_YA
000A99r 2               .endif
000A99r 2               
000A99r 2               ; ----------------------------------------------------------------------------
000A99r 2               UNARY:
000A99r 2  0A                   asl     a
000A9Ar 2  48                   pha
000A9Br 2  AA                   tax
000A9Cr 2  20 CA 00             jsr     CHRGET
000A9Fr 2  E0 81                cpx     #<(TOKEN_LEFTSTR*2-1)
000AA1r 2  90 20                bcc     L2DEF
000AA3r 2  20 rr rr             jsr     CHKOPN
000AA6r 2  20 rr rr             jsr     FRMEVL
000AA9r 2  20 rr rr             jsr     CHKCOM
000AACr 2  20 rr rr             jsr     CHKSTR
000AAFr 2  68                   pla
000AB0r 2  AA                   tax
000AB1r 2  A5 BC                lda     FAC_LAST
000AB3r 2  48                   pha
000AB4r 2  A5 BB                lda     FAC_LAST-1
000AB6r 2  48                   pha
000AB7r 2  8A                   txa
000AB8r 2  48                   pha
000AB9r 2  20 rr rr             jsr     GETBYT
000ABCr 2  68                   pla
000ABDr 2  A8                   tay
000ABEr 2  8A                   txa
000ABFr 2  48                   pha
000AC0r 2  4C rr rr             jmp     L2DF4
000AC3r 2               L2DEF:
000AC3r 2  20 rr rr             jsr     PARCHK
000AC6r 2  68                   pla
000AC7r 2  A8                   tay
000AC8r 2               L2DF4:
000AC8r 2  B9 rr rr             lda     UNFNC-TOKEN_SGN-TOKEN_SGN+$100,y
000ACBr 2  85 AC                sta     JMPADRS+1
000ACDr 2  B9 rr rr             lda     UNFNC-TOKEN_SGN-TOKEN_SGN+$101,y
000AD0r 2  85 AD                sta     JMPADRS+2
000AD2r 2  20 AB 00             jsr     JMPADRS
000AD5r 2  4C rr rr             jmp     CHKNUM
000AD8r 2               
000AD8r 2               ; ----------------------------------------------------------------------------
000AD8r 2               OR:
000AD8r 2  A0 FF                ldy     #$FF
000ADAr 2  2C                   .byte   $2C
000ADBr 2               ; ----------------------------------------------------------------------------
000ADBr 2               TAND:
000ADBr 2  A0 00                ldy     #$00
000ADDr 2  84 64                sty     EOLPNTR
000ADFr 2  20 rr rr             jsr     AYINT
000AE2r 2  A5 BB                lda     FAC_LAST-1
000AE4r 2  45 64                eor     EOLPNTR
000AE6r 2  85 62                sta     CHARAC
000AE8r 2  A5 BC                lda     FAC_LAST
000AEAr 2  45 64                eor     EOLPNTR
000AECr 2  85 63                sta     ENDCHR
000AEEr 2  20 rr rr             jsr     COPY_ARG_TO_FAC
000AF1r 2  20 rr rr             jsr     AYINT
000AF4r 2  A5 BC                lda     FAC_LAST
000AF6r 2  45 64                eor     EOLPNTR
000AF8r 2  25 63                and     ENDCHR
000AFAr 2  45 64                eor     EOLPNTR
000AFCr 2  A8                   tay
000AFDr 2  A5 BB                lda     FAC_LAST-1
000AFFr 2  45 64                eor     EOLPNTR
000B01r 2  25 62                and     CHARAC
000B03r 2  45 64                eor     EOLPNTR
000B05r 2  4C rr rr             jmp     GIVAYF
000B08r 2               
000B08r 2               ; ----------------------------------------------------------------------------
000B08r 2               ; PERFORM RELATIONAL OPERATIONS
000B08r 2               ; ----------------------------------------------------------------------------
000B08r 2               RELOPS:
000B08r 2  20 rr rr             jsr     CHKVAL
000B0Br 2  B0 13                bcs     STRCMP
000B0Dr 2  A5 C5                lda     ARGSIGN
000B0Fr 2  09 7F                ora     #$7F
000B11r 2  25 C1                and     ARG+1
000B13r 2  85 C1                sta     ARG+1
000B15r 2  A9 C0                lda     #<ARG
000B17r 2  A0 00                ldy     #$00
000B19r 2  20 rr rr             jsr     FCOMP
000B1Cr 2  AA                   tax
000B1Dr 2  4C rr rr             jmp     NUMCMP
000B20r 2               
000B20r 2               ; ----------------------------------------------------------------------------
000B20r 2               ; STRING COMPARISON
000B20r 2               ; ----------------------------------------------------------------------------
000B20r 2               STRCMP:
000B20r 2  A9 00                lda     #$00
000B22r 2  85 66                sta     VALTYP
000B24r 2  C6 A4                dec     CPRTYP
000B26r 2  20 rr rr             jsr     FREFAC
000B29r 2  85 B8                sta     FAC
000B2Br 2  86 B9                stx     FAC+1
000B2Dr 2  84 BA                sty     FAC+2
000B2Fr 2  A5 C3                lda     ARG_LAST-1
000B31r 2  A4 C4                ldy     ARG_LAST
000B33r 2  20 rr rr             jsr     FRETMP
000B36r 2  86 C3                stx     ARG_LAST-1
000B38r 2  84 C4                sty     ARG_LAST
000B3Ar 2  AA                   tax
000B3Br 2  38                   sec
000B3Cr 2  E5 B8                sbc     FAC
000B3Er 2  F0 08                beq     L2E74
000B40r 2  A9 01                lda     #$01
000B42r 2  90 04                bcc     L2E74
000B44r 2  A6 B8                ldx     FAC
000B46r 2  A9 FF                lda     #$FF
000B48r 2               L2E74:
000B48r 2  85 BD                sta     FACSIGN
000B4Ar 2  A0 FF                ldy     #$FF
000B4Cr 2  E8                   inx
000B4Dr 2               STRCMP1:
000B4Dr 2  C8                   iny
000B4Er 2  CA                   dex
000B4Fr 2  D0 07                bne     L2E84
000B51r 2  A6 BD                ldx     FACSIGN
000B53r 2               NUMCMP:
000B53r 2  30 0F                bmi     CMPDONE
000B55r 2  18                   clc
000B56r 2  90 0C                bcc     CMPDONE
000B58r 2               L2E84:
000B58r 2  B1 C3                lda     (ARG_LAST-1),y
000B5Ar 2  D1 B9                cmp     (FAC+1),y
000B5Cr 2  F0 EF                beq     STRCMP1
000B5Er 2  A2 FF                ldx     #$FF
000B60r 2  B0 02                bcs     CMPDONE
000B62r 2  A2 01                ldx     #$01
000B64r 2               CMPDONE:
000B64r 2  E8                   inx
000B65r 2  8A                   txa
000B66r 2  2A                   rol     a
000B67r 2  25 6B                and     CPRMASK
000B69r 2  F0 02                beq     L2E99
000B6Br 2  A9 FF                lda     #$FF
000B6Dr 2               L2E99:
000B6Dr 2  4C rr rr             jmp     FLOAT
000B70r 2               
000B70r 2               ;.include "var.s"
000B70r 2               
000B70r 2               .segment "MSBCODE"
000B70r 2               
000B70r 2               ; ----------------------------------------------------------------------------
000B70r 2               ; "DIM" STATEMENT
000B70r 2               ; ----------------------------------------------------------------------------
000B70r 2               NXDIM:
000B70r 2  20 rr rr             jsr     CHKCOM
000B73r 2               DIM:
000B73r 2  AA                   tax
000B74r 2  20 rr rr             jsr     PTRGET2
000B77r 2  20 D0 00             jsr     CHRGOT
000B7Ar 2  D0 F4                bne     NXDIM
000B7Cr 2  60                   rts
000B7Dr 2               
000B7Dr 2               ; ----------------------------------------------------------------------------
000B7Dr 2               ; PTRGET -- GENERAL VARIABLE SCAN
000B7Dr 2               ;
000B7Dr 2               ; SCANS VARIABLE NAME AT TXTPTR, AND SEARCHES THE
000B7Dr 2               ; VARTAB AND ARYTAB FOR THE NAME.
000B7Dr 2               ; IF NOT FOUND, CREATE VARIABLE OF APPROPRIATE TYPE.
000B7Dr 2               ; RETURN WITH ADDRESS IN VARPNT AND Y,A
000B7Dr 2               ;
000B7Dr 2               ; ACTUAL ACTIVITY CONTROLLED SOMEWHAT BY TWO FLAGS:
000B7Dr 2               ;	DIMFLG -- NONZERO IF CALLED FROM "DIM"
000B7Dr 2               ;		ELSE = 0
000B7Dr 2               ;
000B7Dr 2               ;	SUBFLG -- = $00
000B7Dr 2               ;		= $40 IF CALLED FROM "GETARYPT"
000B7Dr 2               ; ----------------------------------------------------------------------------
000B7Dr 2               PTRGET:
000B7Dr 2  A2 00                ldx     #$00
000B7Fr 2  20 D0 00             jsr     CHRGOT
000B82r 2               PTRGET2:
000B82r 2  86 65                stx     DIMFLG
000B84r 2               PTRGET3:
000B84r 2  85 9C                sta     VARNAM
000B86r 2  20 D0 00             jsr     CHRGOT
000B89r 2  20 rr rr             jsr     ISLETC
000B8Cr 2  B0 03                bcs     NAMOK
000B8Er 2               SYNERR3:
000B8Er 2  4C rr rr             jmp     SYNERR
000B91r 2               NAMOK:
000B91r 2  A2 00                ldx     #$00
000B93r 2  86 66                stx     VALTYP
000B95r 2  86 67                stx     VALTYP+1
000B97r 2  20 CA 00             jsr     CHRGET
000B9Ar 2  90 05                bcc     L2ECD
000B9Cr 2  20 rr rr             jsr     ISLETC
000B9Fr 2  90 0B                bcc     L2ED8
000BA1r 2               L2ECD:
000BA1r 2  AA                   tax
000BA2r 2               L2ECE:
000BA2r 2  20 CA 00             jsr     CHRGET
000BA5r 2  90 FB                bcc     L2ECE
000BA7r 2  20 rr rr             jsr     ISLETC
000BAAr 2  B0 F6                bcs     L2ECE
000BACr 2               L2ED8:
000BACr 2  C9 24                cmp     #$24
000BAEr 2  D0 06                bne     L2EE2
000BB0r 2  A9 FF                lda     #$FF
000BB2r 2  85 66                sta     VALTYP
000BB4r 2  D0 10                bne     L2EF2
000BB6r 2               L2EE2:
000BB6r 2  C9 25                cmp     #$25
000BB8r 2  D0 13                bne     L2EF9
000BBAr 2  A5 69                lda     SUBFLG
000BBCr 2  D0 D0                bne     SYNERR3
000BBEr 2  A9 80                lda     #$80
000BC0r 2  85 67                sta     VALTYP+1
000BC2r 2  05 9C                ora     VARNAM
000BC4r 2  85 9C                sta     VARNAM
000BC6r 2               L2EF2:
000BC6r 2  8A                   txa
000BC7r 2  09 80                ora     #$80
000BC9r 2  AA                   tax
000BCAr 2  20 CA 00             jsr     CHRGET
000BCDr 2               L2EF9:
000BCDr 2  86 9D                stx     VARNAM+1
000BCFr 2  38                   sec
000BD0r 2  05 69                ora     SUBFLG
000BD2r 2  E9 28                sbc     #$28
000BD4r 2  D0 03                bne     L2F05
000BD6r 2  4C rr rr             jmp     ARRAY
000BD9r 2               L2F05:
000BD9r 2  A9 00                lda     #$00
000BDBr 2  85 69                sta     SUBFLG
000BDDr 2  A5 84                lda     VARTAB
000BDFr 2  A6 85                ldx     VARTAB+1
000BE1r 2  A0 00                ldy     #$00
000BE3r 2               L2F0F:
000BE3r 2  86 B7                stx     LOWTR+1
000BE5r 2               L2F11:
000BE5r 2  85 B6                sta     LOWTR
000BE7r 2  E4 87                cpx     ARYTAB+1
000BE9r 2  D0 04                bne     L2F1B
000BEBr 2  C5 86                cmp     ARYTAB
000BEDr 2  F0 22                beq     NAMENOTFOUND
000BEFr 2               L2F1B:
000BEFr 2  A5 9C                lda     VARNAM
000BF1r 2  D1 B6                cmp     (LOWTR),y
000BF3r 2  D0 08                bne     L2F29
000BF5r 2  A5 9D                lda     VARNAM+1
000BF7r 2  C8                   iny
000BF8r 2  D1 B6                cmp     (LOWTR),y
000BFAr 2  F0 62                beq     SET_VARPNT_AND_YA
000BFCr 2  88                   dey
000BFDr 2               L2F29:
000BFDr 2  18                   clc
000BFEr 2  A5 B6                lda     LOWTR
000C00r 2  69 07                adc     #BYTES_PER_VARIABLE
000C02r 2  90 E1                bcc     L2F11
000C04r 2  E8                   inx
000C05r 2  D0 DC                bne     L2F0F
000C07r 2               
000C07r 2               ; ----------------------------------------------------------------------------
000C07r 2               ; CHECK IF (A) IS ASCII LETTER A-Z
000C07r 2               ;
000C07r 2               ; RETURN CARRY = 1 IF A-Z
000C07r 2               ;	= 0 IF NOT
000C07r 2               ; ----------------------------------------------------------------------------
000C07r 2               ISLETC:
000C07r 2  C9 41                cmp     #$41
000C09r 2  90 05                bcc     L2F3C
000C0Br 2  E9 5B                sbc     #$5B
000C0Dr 2  38                   sec
000C0Er 2  E9 A5                sbc     #$A5
000C10r 2               L2F3C:
000C10r 2  60                   rts
000C11r 2               
000C11r 2               ; ----------------------------------------------------------------------------
000C11r 2               ; VARIABLE NOT FOUND, SO MAKE ONE
000C11r 2               ; ----------------------------------------------------------------------------
000C11r 2               NAMENOTFOUND:
000C11r 2  68                   pla
000C12r 2  48                   pha
000C13r 2  C9 rr                cmp     #<FRM_VARIABLE_CALL
000C15r 2  D0 05                bne     MAKENEWVARIABLE
000C17r 2               .ifdef CONFIG_SAFE_NAMENOTFOUND
000C17r 2                       tsx
000C17r 2                       lda     STACK+2,x
000C17r 2                       cmp     #>FRM_VARIABLE_CALL
000C17r 2                       bne     MAKENEWVARIABLE
000C17r 2               .endif
000C17r 2               LD015:
000C17r 2  A9 rr                lda     #<C_ZERO
000C19r 2  A0 rr                ldy     #>C_ZERO
000C1Br 2  60                   rts
000C1Cr 2               
000C1Cr 2               ; ----------------------------------------------------------------------------
000C1Cr 2               
000C1Cr 2               
000C1Cr 2               ; ----------------------------------------------------------------------------
000C1Cr 2               ; MAKE A NEW SIMPLE VARIABLE
000C1Cr 2               ;
000C1Cr 2               ; MOVE ARRAYS UP 7 BYTES TO MAKE ROOM FOR NEW VARIABLE
000C1Cr 2               ; ENTER 7-BYTE VARIABLE DATA IN THE HOLE
000C1Cr 2               ; ----------------------------------------------------------------------------
000C1Cr 2               MAKENEWVARIABLE:
000C1Cr 2               .ifdef CONFIG_CBM_ALL
000C1Cr 2                       lda     VARNAM
000C1Cr 2                       ldy     VARNAM+1
000C1Cr 2                       cmp     #$54
000C1Cr 2                       bne     LD02F
000C1Cr 2                       cpy     #$C9
000C1Cr 2                       beq     LD015
000C1Cr 2                       cpy     #$49
000C1Cr 2                       bne     LD02F
000C1Cr 2               LD02C:
000C1Cr 2                       jmp     SYNERR
000C1Cr 2               LD02F:
000C1Cr 2                       cmp     #$53
000C1Cr 2                       bne     LD037
000C1Cr 2                       cpy     #$54
000C1Cr 2                       beq     LD02C
000C1Cr 2               LD037:
000C1Cr 2               .endif
000C1Cr 2  A5 86                lda     ARYTAB
000C1Er 2  A4 87                ldy     ARYTAB+1
000C20r 2  85 B6                sta     LOWTR
000C22r 2  84 B7                sty     LOWTR+1
000C24r 2  A5 88                lda     STREND
000C26r 2  A4 89                ldy     STREND+1
000C28r 2  85 B1                sta     HIGHTR
000C2Ar 2  84 B2                sty     HIGHTR+1
000C2Cr 2  18                   clc
000C2Dr 2  69 07                adc     #BYTES_PER_VARIABLE
000C2Fr 2  90 01                bcc     L2F68
000C31r 2  C8                   iny
000C32r 2               L2F68:
000C32r 2  85 AF                sta     HIGHDS
000C34r 2  84 B0                sty     HIGHDS+1
000C36r 2  20 rr rr             jsr     BLTU
000C39r 2  A5 AF                lda     HIGHDS
000C3Br 2  A4 B0                ldy     HIGHDS+1
000C3Dr 2  C8                   iny
000C3Er 2  85 86                sta     ARYTAB
000C40r 2  84 87                sty     ARYTAB+1
000C42r 2  A0 00                ldy     #$00
000C44r 2  A5 9C                lda     VARNAM
000C46r 2  91 B6                sta     (LOWTR),y
000C48r 2  C8                   iny
000C49r 2  A5 9D                lda     VARNAM+1
000C4Br 2  91 B6                sta     (LOWTR),y
000C4Dr 2  A9 00                lda     #$00
000C4Fr 2  C8                   iny
000C50r 2  91 B6                sta     (LOWTR),y
000C52r 2  C8                   iny
000C53r 2  91 B6                sta     (LOWTR),y
000C55r 2  C8                   iny
000C56r 2  91 B6                sta     (LOWTR),y
000C58r 2  C8                   iny
000C59r 2  91 B6                sta     (LOWTR),y
000C5Br 2  C8                   iny
000C5Cr 2  91 B6                sta     (LOWTR),y
000C5Er 2               
000C5Er 2               ; ----------------------------------------------------------------------------
000C5Er 2               ; PUT ADDRESS OF VALUE OF VARIABLE IN VARPNT AND Y,A
000C5Er 2               ; ----------------------------------------------------------------------------
000C5Er 2               SET_VARPNT_AND_YA:
000C5Er 2  A5 B6                lda     LOWTR
000C60r 2  18                   clc
000C61r 2  69 02                adc     #$02
000C63r 2  A4 B7                ldy     LOWTR+1
000C65r 2  90 01                bcc     L2F9E
000C67r 2  C8                   iny
000C68r 2               L2F9E:
000C68r 2  85 9E                sta     VARPNT
000C6Ar 2  84 9F                sty     VARPNT+1
000C6Cr 2  60                   rts
000C6Dr 2               
000C6Dr 2               
000C6Dr 2               ;.include "array.s"
000C6Dr 2               
000C6Dr 2               .segment "MSBCODE"
000C6Dr 2               
000C6Dr 2               ; ----------------------------------------------------------------------------
000C6Dr 2               ; COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
000C6Dr 2               ; ARYPNT = (LOWTR) + #DIMS*2 + 5
000C6Dr 2               ; ----------------------------------------------------------------------------
000C6Dr 2               GETARY:
000C6Dr 2  A5 64                lda     EOLPNTR
000C6Fr 2  0A                   asl     a
000C70r 2  69 05                adc     #$05
000C72r 2  65 B6                adc     LOWTR
000C74r 2  A4 B7                ldy     LOWTR+1
000C76r 2  90 01                bcc     L2FAF
000C78r 2  C8                   iny
000C79r 2               L2FAF:
000C79r 2  85 AF                sta     HIGHDS
000C7Br 2  84 B0                sty     HIGHDS+1
000C7Dr 2  60                   rts
000C7Er 2               
000C7Er 2               ; ----------------------------------------------------------------------------
000C7Er 2               NEG32768:
000C7Er 2  90 80 00 00          .byte   $90,$80,$00,$00
000C82r 2               
000C82r 2  00           		.byte	$00; bugfix: short number
000C83r 2               
000C83r 2               ; ----------------------------------------------------------------------------
000C83r 2               ; EVALUATE NUMERIC FORMULA AT TXTPTR
000C83r 2               ; CONVERTING RESULT TO INTEGER 0 <= X <= 32767
000C83r 2               ; IN FAC+3,4
000C83r 2               ; ----------------------------------------------------------------------------
000C83r 2               MAKINT:
000C83r 2  20 CA 00             jsr     CHRGET
000C86r 2  20 rr rr             jsr     FRMEVL
000C89r 2               
000C89r 2               ; ----------------------------------------------------------------------------
000C89r 2               ; CONVERT FAC TO INTEGER
000C89r 2               ; MUST BE POSITIVE AND LESS THAN 32768
000C89r 2               ; ----------------------------------------------------------------------------
000C89r 2               MKINT:
000C89r 2  20 rr rr             jsr     CHKNUM
000C8Cr 2  A5 BD                lda     FACSIGN
000C8Er 2  30 0D                bmi     MI1
000C90r 2               
000C90r 2               ; ----------------------------------------------------------------------------
000C90r 2               ; CONVERT FAC TO INTEGER
000C90r 2               ; MUST BE -32767 <= FAC <= 32767
000C90r 2               ; ----------------------------------------------------------------------------
000C90r 2               AYINT:
000C90r 2  A5 B8                lda     FAC
000C92r 2  C9 90                cmp     #$90
000C94r 2  90 09                bcc     MI2
000C96r 2  A9 rr                lda     #<NEG32768
000C98r 2  A0 rr                ldy     #>NEG32768
000C9Ar 2  20 rr rr             jsr     FCOMP
000C9Dr 2               MI1:
000C9Dr 2  D0 7A                bne     IQERR
000C9Fr 2               MI2:
000C9Fr 2  4C rr rr             jmp     QINT
000CA2r 2               
000CA2r 2               ; ----------------------------------------------------------------------------
000CA2r 2               ; LOCATE ARRAY ELEMENT OR CREATE AN ARRAY
000CA2r 2               ; ----------------------------------------------------------------------------
000CA2r 2               ARRAY:
000CA2r 2  A5 65                lda     DIMFLG
000CA4r 2  05 67                ora     VALTYP+1
000CA6r 2  48                   pha
000CA7r 2  A5 66                lda     VALTYP
000CA9r 2  48                   pha
000CAAr 2  A0 00                ldy     #$00
000CACr 2               L2FDE:
000CACr 2  98                   tya
000CADr 2  48                   pha
000CAEr 2  A5 9D                lda     VARNAM+1
000CB0r 2  48                   pha
000CB1r 2  A5 9C                lda     VARNAM
000CB3r 2  48                   pha
000CB4r 2  20 rr rr             jsr     MAKINT
000CB7r 2  68                   pla
000CB8r 2  85 9C                sta     VARNAM
000CBAr 2  68                   pla
000CBBr 2  85 9D                sta     VARNAM+1
000CBDr 2  68                   pla
000CBEr 2  A8                   tay
000CBFr 2  BA                   tsx
000CC0r 2  BD 02 01             lda     STACK+2,x
000CC3r 2  48                   pha
000CC4r 2  BD 01 01             lda     STACK+1,x
000CC7r 2  48                   pha
000CC8r 2  A5 BB                lda     FAC_LAST-1
000CCAr 2  9D 02 01             sta     STACK+2,x
000CCDr 2  A5 BC                lda     FAC_LAST
000CCFr 2  9D 01 01             sta     STACK+1,x
000CD2r 2  C8                   iny
000CD3r 2  20 D0 00             jsr     CHRGOT
000CD6r 2  C9 2C                cmp     #$2C
000CD8r 2  F0 D2                beq     L2FDE
000CDAr 2  84 64                sty     EOLPNTR
000CDCr 2  20 rr rr             jsr     CHKCLS
000CDFr 2  68                   pla
000CE0r 2  85 66                sta     VALTYP
000CE2r 2  68                   pla
000CE3r 2  85 67                sta     VALTYP+1
000CE5r 2  29 7F                and     #$7F
000CE7r 2  85 65                sta     DIMFLG
000CE9r 2               ; ----------------------------------------------------------------------------
000CE9r 2               ; SEARCH ARRAY TABLE FOR THIS ARRAY NAME
000CE9r 2               ; ----------------------------------------------------------------------------
000CE9r 2  A6 86                ldx     ARYTAB
000CEBr 2  A5 87                lda     ARYTAB+1
000CEDr 2               L301F:
000CEDr 2  86 B6                stx     LOWTR
000CEFr 2  85 B7                sta     LOWTR+1
000CF1r 2  C5 89                cmp     STREND+1
000CF3r 2  D0 04                bne     L302B
000CF5r 2  E4 88                cpx     STREND
000CF7r 2  F0 39                beq     MAKE_NEW_ARRAY
000CF9r 2               L302B:
000CF9r 2  A0 00                ldy     #$00
000CFBr 2  B1 B6                lda     (LOWTR),y
000CFDr 2  C8                   iny
000CFEr 2  C5 9C                cmp     VARNAM
000D00r 2  D0 06                bne     L303A
000D02r 2  A5 9D                lda     VARNAM+1
000D04r 2  D1 B6                cmp     (LOWTR),y
000D06r 2  F0 16                beq     USE_OLD_ARRAY
000D08r 2               L303A:
000D08r 2  C8                   iny
000D09r 2  B1 B6                lda     (LOWTR),y
000D0Br 2  18                   clc
000D0Cr 2  65 B6                adc     LOWTR
000D0Er 2  AA                   tax
000D0Fr 2  C8                   iny
000D10r 2  B1 B6                lda     (LOWTR),y
000D12r 2  65 B7                adc     LOWTR+1
000D14r 2  90 D7                bcc     L301F
000D16r 2               
000D16r 2               ; ----------------------------------------------------------------------------
000D16r 2               ; ERROR:  BAD SUBSCRIPTS
000D16r 2               ; ----------------------------------------------------------------------------
000D16r 2               SUBERR:
000D16r 2  A2 6B                ldx     #ERR_BADSUBS
000D18r 2  2C                   .byte   $2C
000D19r 2               
000D19r 2               ; ----------------------------------------------------------------------------
000D19r 2               ; ERROR:  ILLEGAL QUANTITY
000D19r 2               ; ----------------------------------------------------------------------------
000D19r 2               IQERR:
000D19r 2  A2 35                ldx     #ERR_ILLQTY
000D1Br 2               JER:
000D1Br 2  4C rr rr             jmp     ERROR
000D1Er 2               
000D1Er 2               ; ----------------------------------------------------------------------------
000D1Er 2               ; FOUND THE ARRAY
000D1Er 2               ; ----------------------------------------------------------------------------
000D1Er 2               USE_OLD_ARRAY:
000D1Er 2  A2 78                ldx     #ERR_REDIMD
000D20r 2  A5 65                lda     DIMFLG
000D22r 2  D0 F7                bne     JER
000D24r 2  20 rr rr             jsr     GETARY
000D27r 2  A5 64                lda     EOLPNTR
000D29r 2  A0 04                ldy     #$04
000D2Br 2  D1 B6                cmp     (LOWTR),y
000D2Dr 2  D0 E7                bne     SUBERR
000D2Fr 2  4C rr rr             jmp     FIND_ARRAY_ELEMENT
000D32r 2               
000D32r 2               ; ----------------------------------------------------------------------------
000D32r 2               ; CREATE A NEW ARRAY, UNLESS CALLED FROM GETARYPT
000D32r 2               ; ----------------------------------------------------------------------------
000D32r 2               MAKE_NEW_ARRAY:
000D32r 2  20 rr rr             jsr     GETARY
000D35r 2  20 rr rr             jsr     REASON
000D38r 2  A9 00                lda     #$00
000D3Ar 2  A8                   tay
000D3Br 2  85 C9                sta     STRNG2+1
000D3Dr 2  A2 05                ldx     #BYTES_PER_ELEMENT
000D3Fr 2  A5 9C                lda     VARNAM
000D41r 2  91 B6                sta     (LOWTR),y
000D43r 2  10 01                bpl     L3078
000D45r 2  CA                   dex
000D46r 2               L3078:
000D46r 2  C8                   iny
000D47r 2  A5 9D                lda     VARNAM+1
000D49r 2  91 B6                sta     (LOWTR),y
000D4Br 2  10 02                bpl     L3081
000D4Dr 2  CA                   dex
000D4Er 2  CA                   dex
000D4Fr 2               L3081:
000D4Fr 2  86 C8                stx     STRNG2
000D51r 2  A5 64                lda     EOLPNTR
000D53r 2  C8                   iny
000D54r 2  C8                   iny
000D55r 2  C8                   iny
000D56r 2  91 B6                sta     (LOWTR),y
000D58r 2               L308A:
000D58r 2  A2 0B                ldx     #$0B
000D5Ar 2  A9 00                lda     #$00
000D5Cr 2  24 65                bit     DIMFLG
000D5Er 2  50 08                bvc     L309A
000D60r 2  68                   pla
000D61r 2  18                   clc
000D62r 2  69 01                adc     #$01
000D64r 2  AA                   tax
000D65r 2  68                   pla
000D66r 2  69 00                adc     #$00
000D68r 2               L309A:
000D68r 2  C8                   iny
000D69r 2  91 B6                sta     (LOWTR),y
000D6Br 2  C8                   iny
000D6Cr 2  8A                   txa
000D6Dr 2  91 B6                sta     (LOWTR),y
000D6Fr 2  20 rr rr             jsr     MULTIPLY_SUBSCRIPT
000D72r 2  86 C8                stx     STRNG2
000D74r 2  85 C9                sta     STRNG2+1
000D76r 2  A4 79                ldy     INDEX
000D78r 2  C6 64                dec     EOLPNTR
000D7Ar 2  D0 DC                bne     L308A
000D7Cr 2  65 B0                adc     HIGHDS+1
000D7Er 2  B0 5D                bcs     GME
000D80r 2  85 B0                sta     HIGHDS+1
000D82r 2  A8                   tay
000D83r 2  8A                   txa
000D84r 2  65 AF                adc     HIGHDS
000D86r 2  90 03                bcc     L30BD
000D88r 2  C8                   iny
000D89r 2  F0 52                beq     GME
000D8Br 2               L30BD:
000D8Br 2  20 rr rr             jsr     REASON
000D8Er 2  85 88                sta     STREND
000D90r 2  84 89                sty     STREND+1
000D92r 2  A9 00                lda     #$00
000D94r 2  E6 C9                inc     STRNG2+1
000D96r 2  A4 C8                ldy     STRNG2
000D98r 2  F0 05                beq     L30D1
000D9Ar 2               L30CC:
000D9Ar 2  88                   dey
000D9Br 2  91 AF                sta     (HIGHDS),y
000D9Dr 2  D0 FB                bne     L30CC
000D9Fr 2               L30D1:
000D9Fr 2  C6 B0                dec     HIGHDS+1
000DA1r 2  C6 C9                dec     STRNG2+1
000DA3r 2  D0 F5                bne     L30CC
000DA5r 2  E6 B0                inc     HIGHDS+1
000DA7r 2  38                   sec
000DA8r 2  A5 88                lda     STREND
000DAAr 2  E5 B6                sbc     LOWTR
000DACr 2  A0 02                ldy     #$02
000DAEr 2  91 B6                sta     (LOWTR),y
000DB0r 2  A5 89                lda     STREND+1
000DB2r 2  C8                   iny
000DB3r 2  E5 B7                sbc     LOWTR+1
000DB5r 2  91 B6                sta     (LOWTR),y
000DB7r 2  A5 65                lda     DIMFLG
000DB9r 2  D0 62                bne     RTS9
000DBBr 2  C8                   iny
000DBCr 2               
000DBCr 2               ; ----------------------------------------------------------------------------
000DBCr 2               ; FIND SPECIFIED ARRAY ELEMENT
000DBCr 2               ;
000DBCr 2               ; (LOWTR),Y POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
000DBCr 2               ; THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
000DBCr 2               ; ----------------------------------------------------------------------------
000DBCr 2               FIND_ARRAY_ELEMENT:
000DBCr 2  B1 B6                lda     (LOWTR),y
000DBEr 2  85 64                sta     EOLPNTR
000DC0r 2  A9 00                lda     #$00
000DC2r 2  85 C8                sta     STRNG2
000DC4r 2               L30F6:
000DC4r 2  85 C9                sta     STRNG2+1
000DC6r 2  C8                   iny
000DC7r 2  68                   pla
000DC8r 2  AA                   tax
000DC9r 2  85 BB                sta     FAC_LAST-1
000DCBr 2  68                   pla
000DCCr 2  85 BC                sta     FAC_LAST
000DCEr 2  D1 B6                cmp     (LOWTR),y
000DD0r 2  90 0E                bcc     FAE2
000DD2r 2  D0 06                bne     GSE
000DD4r 2  C8                   iny
000DD5r 2  8A                   txa
000DD6r 2  D1 B6                cmp     (LOWTR),y
000DD8r 2  90 07                bcc     FAE3
000DDAr 2               ; ----------------------------------------------------------------------------
000DDAr 2               GSE:
000DDAr 2  4C rr rr             jmp     SUBERR
000DDDr 2               GME:
000DDDr 2  4C rr rr             jmp     MEMERR
000DE0r 2               ; ----------------------------------------------------------------------------
000DE0r 2               FAE2:
000DE0r 2  C8                   iny
000DE1r 2               FAE3:
000DE1r 2  A5 C9                lda     STRNG2+1
000DE3r 2  05 C8                ora     STRNG2
000DE5r 2  18                   clc
000DE6r 2  F0 0A                beq     L3124
000DE8r 2  20 rr rr             jsr     MULTIPLY_SUBSCRIPT
000DEBr 2  8A                   txa
000DECr 2  65 BB                adc     FAC_LAST-1
000DEEr 2  AA                   tax
000DEFr 2  98                   tya
000DF0r 2  A4 79                ldy     INDEX
000DF2r 2               L3124:
000DF2r 2  65 BC                adc     FAC_LAST
000DF4r 2  86 C8                stx     STRNG2
000DF6r 2  C6 64                dec     EOLPNTR
000DF8r 2  D0 CA                bne     L30F6
000DFAr 2               
000DFAr 2  85 C9                sta     STRNG2+1
000DFCr 2  A2 05                ldx     #BYTES_FP
000DFEr 2  A5 9C                lda     VARNAM
000E00r 2  10 01                bpl     L3135
000E02r 2  CA                   dex
000E03r 2               L3135:
000E03r 2  A5 9D                lda     VARNAM+1
000E05r 2  10 02                bpl     L313B
000E07r 2  CA                   dex
000E08r 2  CA                   dex
000E09r 2               L313B:
000E09r 2  86 7F                stx     RESULT+2
000E0Br 2  A9 00                lda     #$00
000E0Dr 2  20 rr rr             jsr     MULTIPLY_SUBS1
000E10r 2  8A                   txa
000E11r 2  65 AF                adc     HIGHDS
000E13r 2  85 9E                sta     VARPNT
000E15r 2  98                   tya
000E16r 2  65 B0                adc     HIGHDS+1
000E18r 2  85 9F                sta     VARPNT+1
000E1Ar 2  A8                   tay
000E1Br 2  A5 9E                lda     VARPNT
000E1Dr 2               RTS9:
000E1Dr 2  60                   rts
000E1Er 2               
000E1Er 2               ; ----------------------------------------------------------------------------
000E1Er 2               ; MULTIPLY (STRNG2) BY ((LOWTR),Y)
000E1Er 2               ; LEAVING PRODUCT IN A,X.  (HI-BYTE ALSO IN Y.)
000E1Er 2               ; USED ONLY BY ARRAY SUBSCRIPT ROUTINES
000E1Er 2               ; ----------------------------------------------------------------------------
000E1Er 2               MULTIPLY_SUBSCRIPT:
000E1Er 2  84 79                sty     INDEX
000E20r 2  B1 B6                lda     (LOWTR),y
000E22r 2  85 7F                sta     RESULT_LAST-2
000E24r 2  88                   dey
000E25r 2  B1 B6                lda     (LOWTR),y
000E27r 2               MULTIPLY_SUBS1:
000E27r 2  85 80                sta     RESULT_LAST-1
000E29r 2  A9 10                lda     #$10
000E2Br 2  85 B4                sta     INDX
000E2Dr 2  A2 00                ldx     #$00
000E2Fr 2  A0 00                ldy     #$00
000E31r 2               L3163:
000E31r 2  8A                   txa
000E32r 2  0A                   asl     a
000E33r 2  AA                   tax
000E34r 2  98                   tya
000E35r 2  2A                   rol     a
000E36r 2  A8                   tay
000E37r 2  B0 A4                bcs     GME
000E39r 2  06 C8                asl     STRNG2
000E3Br 2  26 C9                rol     STRNG2+1
000E3Dr 2  90 0B                bcc     L317C
000E3Fr 2  18                   clc
000E40r 2  8A                   txa
000E41r 2  65 7F                adc     RESULT_LAST-2
000E43r 2  AA                   tax
000E44r 2  98                   tya
000E45r 2  65 80                adc     RESULT_LAST-1
000E47r 2  A8                   tay
000E48r 2  B0 93                bcs     GME
000E4Ar 2               L317C:
000E4Ar 2  C6 B4                dec     INDX
000E4Cr 2  D0 E3                bne     L3163
000E4Er 2  60                   rts
000E4Fr 2               
000E4Fr 2               ;.include "misc2.s"
000E4Fr 2               
000E4Fr 2               .segment "MSBCODE"
000E4Fr 2               
000E4Fr 2               ; ----------------------------------------------------------------------------
000E4Fr 2               ; "FRE" FUNCTION
000E4Fr 2               ;
000E4Fr 2               ; COLLECTS GARBAGE AND RETURNS # BYTES OF MEMORY LEFT
000E4Fr 2               ; ----------------------------------------------------------------------------
000E4Fr 2               FRE:
000E4Fr 2  A5 66                lda     VALTYP
000E51r 2  F0 03                beq     L3188
000E53r 2  20 rr rr             jsr     FREFAC
000E56r 2               L3188:
000E56r 2  20 rr rr             jsr     GARBAG
000E59r 2  38                   sec
000E5Ar 2  A5 8A                lda     FRETOP
000E5Cr 2  E5 88                sbc     STREND
000E5Er 2  A8                   tay
000E5Fr 2  A5 8B                lda     FRETOP+1
000E61r 2  E5 89                sbc     STREND+1
000E63r 2               ; FALL INTO GIVAYF TO FLOAT THE VALUE
000E63r 2               ; NOTE THAT VALUES OVER 32767 WILL RETURN AS NEGATIVE
000E63r 2               
000E63r 2               ; ----------------------------------------------------------------------------
000E63r 2               ; FLOAT THE SIGNED INTEGER IN A,Y
000E63r 2               ; ----------------------------------------------------------------------------
000E63r 2               GIVAYF:
000E63r 2  A2 00                ldx     #$00
000E65r 2  86 66                stx     VALTYP
000E67r 2  85 B9                sta     FAC+1
000E69r 2  84 BA                sty     FAC+2
000E6Br 2  A2 90                ldx     #$90
000E6Dr 2  4C rr rr             jmp     FLOAT1
000E70r 2               POS:
000E70r 2  A4 0D                ldy     POSX
000E72r 2               
000E72r 2               ; ----------------------------------------------------------------------------
000E72r 2               ; FLOAT (Y) INTO FAC, GIVING VALUE 0-255
000E72r 2               ; ----------------------------------------------------------------------------
000E72r 2               SNGFLT:
000E72r 2  A9 00                lda     #$00
000E74r 2  F0 ED                beq     GIVAYF
000E76r 2               
000E76r 2               ; ----------------------------------------------------------------------------
000E76r 2               ; CHECK FOR DIRECT OR RUNNING MODE
000E76r 2               ; GIVING ERROR IF DIRECT MODE
000E76r 2               ; ----------------------------------------------------------------------------
000E76r 2               ERRDIR:
000E76r 2  A6 91                ldx     CURLIN+1
000E78r 2  E8                   inx
000E79r 2  D0 A2                bne     RTS9
000E7Br 2  A2 95                ldx     #ERR_ILLDIR
000E7Dr 2  2C                   .byte   $2C
000E7Er 2               LD288:
000E7Er 2  A2 E0                ldx     #ERR_UNDEFFN
000E80r 2               L31AF:
000E80r 2  4C rr rr             jmp     ERROR
000E83r 2               DEF:
000E83r 2  20 rr rr             jsr     FNC
000E86r 2  20 rr rr             jsr     ERRDIR
000E89r 2  20 rr rr             jsr     CHKOPN
000E8Cr 2  A9 80                lda     #$80
000E8Er 2  85 69                sta     SUBFLG
000E90r 2  20 rr rr             jsr     PTRGET
000E93r 2  20 rr rr             jsr     CHKNUM
000E96r 2  20 rr rr             jsr     CHKCLS
000E99r 2  A9 AB                lda     #TOKEN_EQUAL
000E9Br 2  20 rr rr             jsr     SYNCHR
000E9Er 2  48                   pha
000E9Fr 2  A5 9F                lda     VARPNT+1
000EA1r 2  48                   pha
000EA2r 2  A5 9E                lda     VARPNT
000EA4r 2  48                   pha
000EA5r 2  A5 D2                lda     TXTPTR+1
000EA7r 2  48                   pha
000EA8r 2  A5 D1                lda     TXTPTR
000EAAr 2  48                   pha
000EABr 2  20 rr rr             jsr     DATA
000EAEr 2  4C rr rr             jmp     L3250
000EB1r 2               FNC:
000EB1r 2  A9 9E                lda     #TOKEN_FN
000EB3r 2  20 rr rr             jsr     SYNCHR
000EB6r 2  09 80                ora     #$80
000EB8r 2  85 69                sta     SUBFLG
000EBAr 2  20 rr rr             jsr     PTRGET3
000EBDr 2  85 A5                sta     FNCNAM
000EBFr 2  84 A6                sty     FNCNAM+1
000EC1r 2  4C rr rr             jmp     CHKNUM
000EC4r 2               L31F3:
000EC4r 2  20 rr rr             jsr     FNC
000EC7r 2  A5 A6                lda     FNCNAM+1
000EC9r 2  48                   pha
000ECAr 2  A5 A5                lda     FNCNAM
000ECCr 2  48                   pha
000ECDr 2  20 rr rr             jsr     PARCHK
000ED0r 2  20 rr rr             jsr     CHKNUM
000ED3r 2  68                   pla
000ED4r 2  85 A5                sta     FNCNAM
000ED6r 2  68                   pla
000ED7r 2  85 A6                sta     FNCNAM+1
000ED9r 2  A0 02                ldy     #$02
000EDBr 2  B1 A5                lda     (FNCNAM),y
000EDDr 2  85 9E                sta     VARPNT
000EDFr 2  AA                   tax
000EE0r 2  C8                   iny
000EE1r 2  B1 A5                lda     (FNCNAM),y
000EE3r 2  F0 99                beq     LD288
000EE5r 2  85 9F                sta     VARPNT+1
000EE7r 2  C8                   iny
000EE8r 2               L3219:
000EE8r 2  B1 9E                lda     (VARPNT),y
000EEAr 2  48                   pha
000EEBr 2  88                   dey
000EECr 2  10 FA                bpl     L3219
000EEEr 2  A4 9F                ldy     VARPNT+1
000EF0r 2  20 rr rr             jsr     STORE_FAC_AT_YX_ROUNDED
000EF3r 2  A5 D2                lda     TXTPTR+1
000EF5r 2  48                   pha
000EF6r 2  A5 D1                lda     TXTPTR
000EF8r 2  48                   pha
000EF9r 2  B1 A5                lda     (FNCNAM),y
000EFBr 2  85 D1                sta     TXTPTR
000EFDr 2  C8                   iny
000EFEr 2  B1 A5                lda     (FNCNAM),y
000F00r 2  85 D2                sta     TXTPTR+1
000F02r 2  A5 9F                lda     VARPNT+1
000F04r 2  48                   pha
000F05r 2  A5 9E                lda     VARPNT
000F07r 2  48                   pha
000F08r 2  20 rr rr             jsr     FRMNUM
000F0Br 2  68                   pla
000F0Cr 2  85 A5                sta     FNCNAM
000F0Er 2  68                   pla
000F0Fr 2  85 A6                sta     FNCNAM+1
000F11r 2  20 D0 00             jsr     CHRGOT
000F14r 2  F0 03                beq     L324A
000F16r 2  4C rr rr             jmp     SYNERR
000F19r 2               L324A:
000F19r 2  68                   pla
000F1Ar 2  85 D1                sta     TXTPTR
000F1Cr 2  68                   pla
000F1Dr 2  85 D2                sta     TXTPTR+1
000F1Fr 2               L3250:
000F1Fr 2  A0 00                ldy     #$00
000F21r 2  68                   pla
000F22r 2  91 A5                sta     (FNCNAM),y
000F24r 2  68                   pla
000F25r 2  C8                   iny
000F26r 2  91 A5                sta     (FNCNAM),y
000F28r 2  68                   pla
000F29r 2  C8                   iny
000F2Ar 2  91 A5                sta     (FNCNAM),y
000F2Cr 2  68                   pla
000F2Dr 2  C8                   iny
000F2Er 2  91 A5                sta     (FNCNAM),y
000F30r 2  68                   pla
000F31r 2  C8                   iny
000F32r 2  91 A5                sta     (FNCNAM),y
000F34r 2  60                   rts
000F35r 2               
000F35r 2               ;.include "string.s"
000F35r 2               
000F35r 2               .segment "MSBCODE"
000F35r 2               ; ----------------------------------------------------------------------------
000F35r 2               ; "STR$" FUNCTION
000F35r 2               ; ----------------------------------------------------------------------------
000F35r 2               STR:
000F35r 2  20 rr rr             jsr     CHKNUM
000F38r 2  A0 00                ldy     #$00
000F3Ar 2  20 rr rr             jsr     FOUT1
000F3Dr 2  68                   pla
000F3Er 2  68                   pla
000F3Fr 2               LD353:
000F3Fr 2  A9 FF                lda     #<(STACK2-1)
000F41r 2  A0 00                ldy     #>(STACK2-1)
000F43r 2  F0 12                beq     STRLIT
000F45r 2               
000F45r 2               ; ----------------------------------------------------------------------------
000F45r 2               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
000F45r 2               ; ADDRESS IS IN FAC+3,4 AND WHOSE LENGTH IS IN A-REG
000F45r 2               ; ----------------------------------------------------------------------------
000F45r 2               STRINI:
000F45r 2  A6 BB                ldx     FAC_LAST-1
000F47r 2  A4 BC                ldy     FAC_LAST
000F49r 2  86 A7                stx     DSCPTR
000F4Br 2  84 A8                sty     DSCPTR+1
000F4Dr 2               
000F4Dr 2               ; ----------------------------------------------------------------------------
000F4Dr 2               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
000F4Dr 2               ; ADDRESS IS IN Y,X AND WHOSE LENGTH IS IN A-REG
000F4Dr 2               ; ----------------------------------------------------------------------------
000F4Dr 2               STRSPA:
000F4Dr 2  20 rr rr             jsr     GETSPA
000F50r 2  86 B9                stx     FAC+1
000F52r 2  84 BA                sty     FAC+2
000F54r 2  85 B8                sta     FAC
000F56r 2  60                   rts
000F57r 2               
000F57r 2               ; ----------------------------------------------------------------------------
000F57r 2               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
000F57r 2               ; AND TERMINATED BY $00 OR QUOTATION MARK
000F57r 2               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
000F57r 2               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
000F57r 2               ; ----------------------------------------------------------------------------
000F57r 2               STRLIT:
000F57r 2  A2 22                ldx     #$22
000F59r 2  86 62                stx     CHARAC
000F5Br 2  86 63                stx     ENDCHR
000F5Dr 2               
000F5Dr 2               ; ----------------------------------------------------------------------------
000F5Dr 2               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
000F5Dr 2               ; AND TERMINATED BY $00, (CHARAC), OR (ENDCHR)
000F5Dr 2               ;
000F5Dr 2               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
000F5Dr 2               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
000F5Dr 2               ; ----------------------------------------------------------------------------
000F5Dr 2               STRLT2:
000F5Dr 2  85 C6                sta     STRNG1
000F5Fr 2  84 C7                sty     STRNG1+1
000F61r 2  85 B9                sta     FAC+1
000F63r 2  84 BA                sty     FAC+2
000F65r 2  A0 FF                ldy     #$FF
000F67r 2               L3298:
000F67r 2  C8                   iny
000F68r 2  B1 C6                lda     (STRNG1),y
000F6Ar 2  F0 0C                beq     L32A9
000F6Cr 2  C5 62                cmp     CHARAC
000F6Er 2  F0 04                beq     L32A5
000F70r 2  C5 63                cmp     ENDCHR
000F72r 2  D0 F3                bne     L3298
000F74r 2               L32A5:
000F74r 2  C9 22                cmp     #$22
000F76r 2  F0 01                beq     L32AA
000F78r 2               L32A9:
000F78r 2  18                   clc
000F79r 2               L32AA:
000F79r 2  84 B8                sty     FAC
000F7Br 2  98                   tya
000F7Cr 2  65 C6                adc     STRNG1
000F7Er 2  85 C8                sta     STRNG2
000F80r 2  A6 C7                ldx     STRNG1+1
000F82r 2  90 01                bcc     L32B6
000F84r 2  E8                   inx
000F85r 2               L32B6:
000F85r 2  86 C9                stx     STRNG2+1
000F87r 2  A5 C7                lda     STRNG1+1
000F89r 2               .ifdef CONFIG_NO_INPUTBUFFER_ZP
000F89r 2                       beq     LD399
000F89r 2                       cmp     #>INPUTBUFFER
000F89r 2               .endif
000F89r 2  D0 0B                bne     PUTNEW
000F8Br 2               LD399:
000F8Br 2  98                   tya
000F8Cr 2  20 rr rr             jsr     STRINI
000F8Fr 2  A6 C6                ldx     STRNG1
000F91r 2  A4 C7                ldy     STRNG1+1
000F93r 2  20 rr rr             jsr     MOVSTR
000F96r 2               
000F96r 2               ; ----------------------------------------------------------------------------
000F96r 2               ; STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
000F96r 2               ;
000F96r 2               ; THE DESCRIPTOR IS NOW IN FAC, FAC+1, FAC+2
000F96r 2               ; PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+3,4
000F96r 2               ; ----------------------------------------------------------------------------
000F96r 2               PUTNEW:
000F96r 2  A6 6D                ldx     TEMPPT
000F98r 2  E0 79                cpx     #TEMPST+9
000F9Ar 2  D0 05                bne     PUTEMP
000F9Cr 2  A2 BF                ldx     #ERR_FRMCPX
000F9Er 2               JERR:
000F9Er 2  4C rr rr             jmp     ERROR
000FA1r 2               PUTEMP:
000FA1r 2  A5 B8                lda     FAC
000FA3r 2  95 00                sta     0,x
000FA5r 2  A5 B9                lda     FAC+1
000FA7r 2  95 01                sta     1,x
000FA9r 2  A5 BA                lda     FAC+2
000FABr 2  95 02                sta     2,x
000FADr 2  A0 00                ldy     #$00
000FAFr 2  86 BB                stx     FAC_LAST-1
000FB1r 2  84 BC                sty     FAC_LAST
000FB3r 2  84 C7                sty     FACEXTENSION
000FB5r 2  88                   dey
000FB6r 2  84 66                sty     VALTYP
000FB8r 2  86 6E                stx     LASTPT
000FBAr 2  E8                   inx
000FBBr 2  E8                   inx
000FBCr 2  E8                   inx
000FBDr 2  86 6D                stx     TEMPPT
000FBFr 2  60                   rts
000FC0r 2               
000FC0r 2               ; ----------------------------------------------------------------------------
000FC0r 2               ; MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
000FC0r 2               ; (A)=# BYTES SPACE TO MAKE
000FC0r 2               ;
000FC0r 2               ; RETURN WITH (A) SAME,
000FC0r 2               ;	AND Y,X = ADDRESS OF SPACE ALLOCATED
000FC0r 2               ; ----------------------------------------------------------------------------
000FC0r 2               GETSPA:
000FC0r 2  46 68                lsr     DATAFLG
000FC2r 2               L32F1:
000FC2r 2  48                   pha
000FC3r 2  49 FF                eor     #$FF
000FC5r 2  38                   sec
000FC6r 2  65 8A                adc     FRETOP
000FC8r 2  A4 8B                ldy     FRETOP+1
000FCAr 2  B0 01                bcs     L32FC
000FCCr 2  88                   dey
000FCDr 2               L32FC:
000FCDr 2  C4 89                cpy     STREND+1
000FCFr 2  90 11                bcc     L3311
000FD1r 2  D0 04                bne     L3306
000FD3r 2  C5 88                cmp     STREND
000FD5r 2  90 0B                bcc     L3311
000FD7r 2               L3306:
000FD7r 2  85 8A                sta     FRETOP
000FD9r 2  84 8B                sty     FRETOP+1
000FDBr 2  85 8C                sta     FRESPC
000FDDr 2  84 8D                sty     FRESPC+1
000FDFr 2  AA                   tax
000FE0r 2  68                   pla
000FE1r 2  60                   rts
000FE2r 2               L3311:
000FE2r 2  A2 4D                ldx     #ERR_MEMFULL
000FE4r 2  A5 68                lda     DATAFLG
000FE6r 2  30 B6                bmi     JERR
000FE8r 2  20 rr rr             jsr     GARBAG
000FEBr 2  A9 80                lda     #$80
000FEDr 2  85 68                sta     DATAFLG
000FEFr 2  68                   pla
000FF0r 2  D0 D0                bne     L32F1
000FF2r 2               
000FF2r 2               ; ----------------------------------------------------------------------------
000FF2r 2               ; SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
000FF2r 2               ; IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
000FF2r 2               ; BELOW STRING AREA DOWN TO STREND.
000FF2r 2               ; ----------------------------------------------------------------------------
000FF2r 2               GARBAG:
000FF2r 2               
000FF2r 2               .ifdef CONST_MEMSIZ
000FF2r 2                       ldx     #<CONST_MEMSIZ
000FF2r 2                       lda     #>CONST_MEMSIZ
000FF2r 2               .else
000FF2r 2  A6 8E                ldx     MEMSIZ
000FF4r 2  A5 8F                lda     MEMSIZ+1
000FF6r 2               .endif
000FF6r 2               FINDHIGHESTSTRING:
000FF6r 2  86 8A                stx     FRETOP
000FF8r 2  85 8B                sta     FRETOP+1
000FFAr 2  A0 00                ldy     #$00
000FFCr 2  84 A6                sty     FNCNAM+1
000FFEr 2  84 A5                sty     FNCNAM	; GC bugfix!
001000r 2  A5 88                lda     STREND
001002r 2  A6 89                ldx     STREND+1
001004r 2  85 B6                sta     LOWTR
001006r 2  86 B7                stx     LOWTR+1
001008r 2  A9 70                lda     #TEMPST
00100Ar 2  A2 00                ldx     #$00
00100Cr 2  85 79                sta     INDEX
00100Er 2  86 7A                stx     INDEX+1
001010r 2               L333D:
001010r 2  C5 6D                cmp     TEMPPT
001012r 2  F0 05                beq     L3346
001014r 2  20 rr rr             jsr     CHECK_VARIABLE
001017r 2  F0 F7                beq     L333D
001019r 2               L3346:
001019r 2  A9 07                lda     #BYTES_PER_VARIABLE
00101Br 2  85 AA                sta     DSCLEN
00101Dr 2  A5 84                lda     VARTAB
00101Fr 2  A6 85                ldx     VARTAB+1
001021r 2  85 79                sta     INDEX
001023r 2  86 7A                stx     INDEX+1
001025r 2               L3352:
001025r 2  E4 87                cpx     ARYTAB+1
001027r 2  D0 04                bne     L335A
001029r 2  C5 86                cmp     ARYTAB
00102Br 2  F0 05                beq     L335F
00102Dr 2               L335A:
00102Dr 2  20 rr rr             jsr     CHECK_SIMPLE_VARIABLE
001030r 2  F0 F3                beq     L3352
001032r 2               L335F:
001032r 2  85 AF                sta     HIGHDS
001034r 2  86 B0                stx     HIGHDS+1
001036r 2  A9 03                lda     #$03	; OSI GC bugfix -> $04 ???
001038r 2  85 AA                sta     DSCLEN
00103Ar 2               L3367:
00103Ar 2  A5 AF                lda     HIGHDS
00103Cr 2  A6 B0                ldx     HIGHDS+1
00103Er 2               L336B:
00103Er 2  E4 89                cpx     STREND+1
001040r 2  D0 07                bne     L3376
001042r 2  C5 88                cmp     STREND
001044r 2  D0 03                bne     L3376
001046r 2  4C rr rr             jmp     MOVE_HIGHEST_STRING_TO_TOP
001049r 2               L3376:
001049r 2  85 79                sta     INDEX
00104Br 2  86 7A                stx     INDEX+1
00104Dr 2  A0 00                ldy     #$00
00104Fr 2  B1 79                lda     (INDEX),y
001051r 2  AA                   tax
001052r 2  C8                   iny
001053r 2  B1 79                lda     (INDEX),y
001055r 2  08                   php
001056r 2  C8                   iny
001057r 2  B1 79                lda     (INDEX),y
001059r 2  65 AF                adc     HIGHDS
00105Br 2  85 AF                sta     HIGHDS
00105Dr 2  C8                   iny
00105Er 2  B1 79                lda     (INDEX),y
001060r 2  65 B0                adc     HIGHDS+1
001062r 2  85 B0                sta     HIGHDS+1
001064r 2  28                   plp
001065r 2  10 D3                bpl     L3367
001067r 2  8A                   txa
001068r 2  30 D0                bmi     L3367
00106Ar 2  C8                   iny
00106Br 2  B1 79                lda     (INDEX),y
00106Dr 2               .ifdef CONFIG_CBM1_PATCHES
00106Dr 2                       jsr     LE7F3 ; XXX patch, call into screen editor
00106Dr 2               .else
00106Dr 2  A0 00                ldy     #$00	; GC bugfix
00106Fr 2  0A                   asl     a
001070r 2  69 05                adc     #$05
001072r 2               .endif
001072r 2  65 79                adc     INDEX
001074r 2  85 79                sta     INDEX
001076r 2  90 02                bcc     L33A7
001078r 2  E6 7A                inc     INDEX+1
00107Ar 2               L33A7:
00107Ar 2  A6 7A                ldx     INDEX+1
00107Cr 2               L33A9:
00107Cr 2  E4 B0                cpx     HIGHDS+1
00107Er 2  D0 04                bne     L33B1
001080r 2  C5 AF                cmp     HIGHDS
001082r 2  F0 BA                beq     L336B
001084r 2               L33B1:
001084r 2  20 rr rr             jsr     CHECK_VARIABLE
001087r 2  F0 F3                beq     L33A9
001089r 2               
001089r 2               ; ----------------------------------------------------------------------------
001089r 2               ; PROCESS A SIMPLE VARIABLE
001089r 2               ; ----------------------------------------------------------------------------
001089r 2               CHECK_SIMPLE_VARIABLE:
001089r 2  B1 79                lda     (INDEX),y
00108Br 2  30 35                bmi     CHECK_BUMP
00108Dr 2  C8                   iny
00108Er 2  B1 79                lda     (INDEX),y
001090r 2  10 30                bpl     CHECK_BUMP
001092r 2  C8                   iny
001093r 2               
001093r 2               ; ----------------------------------------------------------------------------
001093r 2               ; IF STRING IS NOT EMPTY, CHECK IF IT IS HIGHEST
001093r 2               ; ----------------------------------------------------------------------------
001093r 2               CHECK_VARIABLE:
001093r 2  B1 79                lda     (INDEX),y
001095r 2  F0 2B                beq     CHECK_BUMP
001097r 2  C8                   iny
001098r 2  B1 79                lda     (INDEX),y
00109Ar 2  AA                   tax
00109Br 2  C8                   iny
00109Cr 2  B1 79                lda     (INDEX),y
00109Er 2  C5 8B                cmp     FRETOP+1
0010A0r 2  90 06                bcc     L33D5
0010A2r 2  D0 1E                bne     CHECK_BUMP
0010A4r 2  E4 8A                cpx     FRETOP
0010A6r 2  B0 1A                bcs     CHECK_BUMP
0010A8r 2               L33D5:
0010A8r 2  C5 B7                cmp     LOWTR+1
0010AAr 2  90 16                bcc     CHECK_BUMP
0010ACr 2  D0 04                bne     L33DF
0010AEr 2  E4 B6                cpx     LOWTR
0010B0r 2  90 10                bcc     CHECK_BUMP
0010B2r 2               L33DF:
0010B2r 2  86 B6                stx     LOWTR
0010B4r 2  85 B7                sta     LOWTR+1
0010B6r 2  A5 79                lda     INDEX
0010B8r 2  A6 7A                ldx     INDEX+1
0010BAr 2  85 A5                sta     FNCNAM
0010BCr 2  86 A6                stx     FNCNAM+1
0010BEr 2  A5 AA                lda     DSCLEN
0010C0r 2  85 AC                sta     Z52
0010C2r 2               
0010C2r 2               ; ----------------------------------------------------------------------------
0010C2r 2               ; ADD (DSCLEN) TO PNTR IN INDEX
0010C2r 2               ; RETURN WITH Y=0, PNTR ALSO IN X,A
0010C2r 2               ; ----------------------------------------------------------------------------
0010C2r 2               CHECK_BUMP:
0010C2r 2  A5 AA                lda     DSCLEN
0010C4r 2  18                   clc
0010C5r 2  65 79                adc     INDEX
0010C7r 2  85 79                sta     INDEX
0010C9r 2  90 02                bcc     L33FA
0010CBr 2  E6 7A                inc     INDEX+1
0010CDr 2               L33FA:
0010CDr 2  A6 7A                ldx     INDEX+1
0010CFr 2  A0 00                ldy     #$00
0010D1r 2  60                   rts
0010D2r 2               
0010D2r 2               ; ----------------------------------------------------------------------------
0010D2r 2               ; FOUND HIGHEST NON-EMPTY STRING, SO MOVE IT
0010D2r 2               ; TO TOP AND GO BACK FOR ANOTHER
0010D2r 2               ; ----------------------------------------------------------------------------
0010D2r 2               MOVE_HIGHEST_STRING_TO_TOP:
0010D2r 2  A5 A6                lda     FNCNAM+1	; GC bugfix
0010D4r 2  05 A5                ora     FNCNAM
0010D6r 2  F0 F5                beq     L33FA
0010D8r 2  A5 AC                lda     Z52
0010DAr 2  29 04                and     #$04
0010DCr 2  4A                   lsr     a
0010DDr 2  A8                   tay
0010DEr 2  85 AC                sta     Z52
0010E0r 2  B1 A5                lda     (FNCNAM),y
0010E2r 2  65 B6                adc     LOWTR
0010E4r 2  85 B1                sta     HIGHTR
0010E6r 2  A5 B7                lda     LOWTR+1
0010E8r 2  69 00                adc     #$00
0010EAr 2  85 B2                sta     HIGHTR+1
0010ECr 2  A5 8A                lda     FRETOP
0010EEr 2  A6 8B                ldx     FRETOP+1
0010F0r 2  85 AF                sta     HIGHDS
0010F2r 2  86 B0                stx     HIGHDS+1
0010F4r 2  20 rr rr             jsr     BLTU2
0010F7r 2  A4 AC                ldy     Z52
0010F9r 2  C8                   iny
0010FAr 2  A5 AF                lda     HIGHDS
0010FCr 2  91 A5                sta     (FNCNAM),y
0010FEr 2  AA                   tax
0010FFr 2  E6 B0                inc     HIGHDS+1
001101r 2  A5 B0                lda     HIGHDS+1
001103r 2  C8                   iny
001104r 2  91 A5                sta     (FNCNAM),y
001106r 2  4C rr rr             jmp     FINDHIGHESTSTRING
001109r 2               
001109r 2               ; ----------------------------------------------------------------------------
001109r 2               ; CONCATENATE TWO STRINGS
001109r 2               ; ----------------------------------------------------------------------------
001109r 2               CAT:
001109r 2  A5 BC                lda     FAC_LAST
00110Br 2  48                   pha
00110Cr 2  A5 BB                lda     FAC_LAST-1
00110Er 2  48                   pha
00110Fr 2  20 rr rr             jsr     FRM_ELEMENT
001112r 2  20 rr rr             jsr     CHKSTR
001115r 2  68                   pla
001116r 2  85 C6                sta     STRNG1
001118r 2  68                   pla
001119r 2  85 C7                sta     STRNG1+1
00111Br 2  A0 00                ldy     #$00
00111Dr 2  B1 C6                lda     (STRNG1),y
00111Fr 2  18                   clc
001120r 2  71 BB                adc     (FAC_LAST-1),y
001122r 2  90 05                bcc     L3454
001124r 2  A2 B0                ldx     #ERR_STRLONG
001126r 2  4C rr rr             jmp     ERROR
001129r 2               L3454:
001129r 2  20 rr rr             jsr     STRINI
00112Cr 2  20 rr rr             jsr     MOVINS
00112Fr 2  A5 A7                lda     DSCPTR
001131r 2  A4 A8                ldy     DSCPTR+1
001133r 2  20 rr rr             jsr     FRETMP
001136r 2  20 rr rr             jsr     MOVSTR1
001139r 2  A5 C6                lda     STRNG1
00113Br 2  A4 C7                ldy     STRNG1+1
00113Dr 2  20 rr rr             jsr     FRETMP
001140r 2  20 rr rr             jsr     PUTNEW
001143r 2  4C rr rr             jmp     FRMEVL2
001146r 2               
001146r 2               ; ----------------------------------------------------------------------------
001146r 2               ; GET STRING DESCRIPTOR POINTED AT BY (STRNG1)
001146r 2               ; AND MOVE DESCRIBED STRING TO (FRESPC)
001146r 2               ; ----------------------------------------------------------------------------
001146r 2               MOVINS:
001146r 2  A0 00                ldy     #$00
001148r 2  B1 C6                lda     (STRNG1),y
00114Ar 2  48                   pha
00114Br 2  C8                   iny
00114Cr 2  B1 C6                lda     (STRNG1),y
00114Er 2  AA                   tax
00114Fr 2  C8                   iny
001150r 2  B1 C6                lda     (STRNG1),y
001152r 2  A8                   tay
001153r 2  68                   pla
001154r 2               
001154r 2               ; ----------------------------------------------------------------------------
001154r 2               ; MOVE STRING AT (Y,X) WITH LENGTH (A)
001154r 2               ; TO DESTINATION WHOSE ADDRESS IS IN FRESPC,FRESPC+1
001154r 2               ; ----------------------------------------------------------------------------
001154r 2               MOVSTR:
001154r 2  86 79                stx     INDEX
001156r 2  84 7A                sty     INDEX+1
001158r 2               MOVSTR1:
001158r 2  A8                   tay
001159r 2  F0 0A                beq     L3490
00115Br 2  48                   pha
00115Cr 2               L3487:
00115Cr 2  88                   dey
00115Dr 2  B1 79                lda     (INDEX),y
00115Fr 2  91 8C                sta     (FRESPC),y
001161r 2  98                   tya
001162r 2  D0 F8                bne     L3487
001164r 2  68                   pla
001165r 2               L3490:
001165r 2  18                   clc
001166r 2  65 8C                adc     FRESPC
001168r 2  85 8C                sta     FRESPC
00116Ar 2  90 02                bcc     L3499
00116Cr 2  E6 8D                inc     FRESPC+1
00116Er 2               L3499:
00116Er 2  60                   rts
00116Fr 2               
00116Fr 2               ; ----------------------------------------------------------------------------
00116Fr 2               ; IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
00116Fr 2               ; ----------------------------------------------------------------------------
00116Fr 2               FRESTR:
00116Fr 2  20 rr rr             jsr     CHKSTR
001172r 2               
001172r 2               ; ----------------------------------------------------------------------------
001172r 2               ; IF STRING DESCRIPTOR POINTED TO BY FAC+3,4 IS
001172r 2               ; A TEMPORARY STRING, RELEASE IT.
001172r 2               ; ----------------------------------------------------------------------------
001172r 2               FREFAC:
001172r 2  A5 BB                lda     FAC_LAST-1
001174r 2  A4 BC                ldy     FAC_LAST
001176r 2               
001176r 2               ; ----------------------------------------------------------------------------
001176r 2               ; IF STRING DESCRIPTOR WHOSE ADDRESS IS IN Y,A IS
001176r 2               ; A TEMPORARY STRING, RELEASE IT.
001176r 2               ; ----------------------------------------------------------------------------
001176r 2               FRETMP:
001176r 2  85 79                sta     INDEX
001178r 2  84 7A                sty     INDEX+1
00117Ar 2  20 rr rr             jsr     FRETMS
00117Dr 2  08                   php
00117Er 2  A0 00                ldy     #$00
001180r 2  B1 79                lda     (INDEX),y
001182r 2  48                   pha
001183r 2  C8                   iny
001184r 2  B1 79                lda     (INDEX),y
001186r 2  AA                   tax
001187r 2  C8                   iny
001188r 2  B1 79                lda     (INDEX),y
00118Ar 2  A8                   tay
00118Br 2  68                   pla
00118Cr 2  28                   plp
00118Dr 2  D0 13                bne     L34CD
00118Fr 2  C4 8B                cpy     FRETOP+1
001191r 2  D0 0F                bne     L34CD
001193r 2  E4 8A                cpx     FRETOP
001195r 2  D0 0B                bne     L34CD
001197r 2  48                   pha
001198r 2  18                   clc
001199r 2  65 8A                adc     FRETOP
00119Br 2  85 8A                sta     FRETOP
00119Dr 2  90 02                bcc     L34CC
00119Fr 2  E6 8B                inc     FRETOP+1
0011A1r 2               L34CC:
0011A1r 2  68                   pla
0011A2r 2               L34CD:
0011A2r 2  86 79                stx     INDEX
0011A4r 2  84 7A                sty     INDEX+1
0011A6r 2  60                   rts
0011A7r 2               
0011A7r 2               ; ----------------------------------------------------------------------------
0011A7r 2               ; RELEASE TEMPORARY DESCRIPTOR IF Y,A = LASTPT
0011A7r 2               ; ----------------------------------------------------------------------------
0011A7r 2               FRETMS:
0011A7r 2  C4 6F                cpy     LASTPT+1
0011A9r 2  D0 0C                bne     L34E2
0011ABr 2  C5 6E                cmp     LASTPT
0011ADr 2  D0 08                bne     L34E2
0011AFr 2  85 6D                sta     TEMPPT
0011B1r 2  E9 03                sbc     #$03
0011B3r 2  85 6E                sta     LASTPT
0011B5r 2  A0 00                ldy     #$00
0011B7r 2               L34E2:
0011B7r 2  60                   rts
0011B8r 2               
0011B8r 2               ; ----------------------------------------------------------------------------
0011B8r 2               ; "CHR$" FUNCTION
0011B8r 2               ; ----------------------------------------------------------------------------
0011B8r 2               CHRSTR:
0011B8r 2  20 rr rr             jsr     CONINT
0011BBr 2  8A                   txa
0011BCr 2  48                   pha
0011BDr 2  A9 01                lda     #$01
0011BFr 2  20 rr rr             jsr     STRSPA
0011C2r 2  68                   pla
0011C3r 2  A0 00                ldy     #$00
0011C5r 2  91 B9                sta     (FAC+1),y
0011C7r 2  68                   pla
0011C8r 2  68                   pla
0011C9r 2  4C rr rr             jmp     PUTNEW
0011CCr 2               
0011CCr 2               ; ----------------------------------------------------------------------------
0011CCr 2               ; "LEFT$" FUNCTION
0011CCr 2               ; ----------------------------------------------------------------------------
0011CCr 2               LEFTSTR:
0011CCr 2  20 rr rr             jsr     SUBSTRING_SETUP
0011CFr 2  D1 A7                cmp     (DSCPTR),y
0011D1r 2  98                   tya
0011D2r 2               SUBSTRING1:
0011D2r 2  90 04                bcc     L3503
0011D4r 2  B1 A7                lda     (DSCPTR),y
0011D6r 2  AA                   tax
0011D7r 2  98                   tya
0011D8r 2               L3503:
0011D8r 2  48                   pha
0011D9r 2               SUBSTRING2:
0011D9r 2  8A                   txa
0011DAr 2               SUBSTRING3:
0011DAr 2  48                   pha
0011DBr 2  20 rr rr             jsr     STRSPA
0011DEr 2  A5 A7                lda     DSCPTR
0011E0r 2  A4 A8                ldy     DSCPTR+1
0011E2r 2  20 rr rr             jsr     FRETMP
0011E5r 2  68                   pla
0011E6r 2  A8                   tay
0011E7r 2  68                   pla
0011E8r 2  18                   clc
0011E9r 2  65 79                adc     INDEX
0011EBr 2  85 79                sta     INDEX
0011EDr 2  90 02                bcc     L351C
0011EFr 2  E6 7A                inc     INDEX+1
0011F1r 2               L351C:
0011F1r 2  98                   tya
0011F2r 2  20 rr rr             jsr     MOVSTR1
0011F5r 2  4C rr rr             jmp     PUTNEW
0011F8r 2               
0011F8r 2               ; ----------------------------------------------------------------------------
0011F8r 2               ; "RIGHT$" FUNCTION
0011F8r 2               ; ----------------------------------------------------------------------------
0011F8r 2               RIGHTSTR:
0011F8r 2  20 rr rr             jsr     SUBSTRING_SETUP
0011FBr 2  18                   clc
0011FCr 2  F1 A7                sbc     (DSCPTR),y
0011FEr 2  49 FF                eor     #$FF
001200r 2  4C rr rr             jmp     SUBSTRING1
001203r 2               
001203r 2               ; ----------------------------------------------------------------------------
001203r 2               ; "MID$" FUNCTION
001203r 2               ; ----------------------------------------------------------------------------
001203r 2               MIDSTR:
001203r 2  A9 FF                lda     #$FF
001205r 2  85 BC                sta     FAC_LAST
001207r 2  20 D0 00             jsr     CHRGOT
00120Ar 2  C9 29                cmp     #$29
00120Cr 2  F0 06                beq     L353F
00120Er 2  20 rr rr             jsr     CHKCOM
001211r 2  20 rr rr             jsr     GETBYT
001214r 2               L353F:
001214r 2  20 rr rr             jsr     SUBSTRING_SETUP
001217r 2  F0 4B                beq     GOIQ
001219r 2  CA                   dex
00121Ar 2  8A                   txa
00121Br 2  48                   pha
00121Cr 2  18                   clc
00121Dr 2  A2 00                ldx     #$00
00121Fr 2  F1 A7                sbc     (DSCPTR),y
001221r 2  B0 B6                bcs     SUBSTRING2
001223r 2  49 FF                eor     #$FF
001225r 2  C5 BC                cmp     FAC_LAST
001227r 2  90 B1                bcc     SUBSTRING3
001229r 2  A5 BC                lda     FAC_LAST
00122Br 2  B0 AD                bcs     SUBSTRING3
00122Dr 2               
00122Dr 2               ; ----------------------------------------------------------------------------
00122Dr 2               ; COMMON SETUP ROUTINE FOR LEFT$, RIGHT$, MID$:
00122Dr 2               ; REQUIRE ")"; POP RETURN ADRS, GET DESCRIPTOR
00122Dr 2               ; ADDRESS, GET 1ST PARAMETER OF COMMAND
00122Dr 2               ; ----------------------------------------------------------------------------
00122Dr 2               SUBSTRING_SETUP:
00122Dr 2  20 rr rr             jsr     CHKCLS
001230r 2  68                   pla
001231r 2  A8                   tay
001232r 2  68                   pla
001233r 2  85 AC                sta     Z52
001235r 2  68                   pla
001236r 2  68                   pla
001237r 2  68                   pla
001238r 2  AA                   tax
001239r 2  68                   pla
00123Ar 2  85 A7                sta     DSCPTR
00123Cr 2  68                   pla
00123Dr 2  85 A8                sta     DSCPTR+1
00123Fr 2  A5 AC                lda     Z52
001241r 2  48                   pha
001242r 2  98                   tya
001243r 2  48                   pha
001244r 2  A0 00                ldy     #$00
001246r 2  8A                   txa
001247r 2  60                   rts
001248r 2               
001248r 2               ; ----------------------------------------------------------------------------
001248r 2               ; "LEN" FUNCTION
001248r 2               ; ----------------------------------------------------------------------------
001248r 2               LEN:
001248r 2  20 rr rr             jsr     GETSTR
00124Br 2               SNGFLT1:
00124Br 2  4C rr rr             jmp     SNGFLT
00124Er 2               
00124Er 2               ; ----------------------------------------------------------------------------
00124Er 2               ; IF LAST RESULT IS A TEMPORARY STRING, FREE IT
00124Er 2               ; MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
00124Er 2               ; ----------------------------------------------------------------------------
00124Er 2               GETSTR:
00124Er 2  20 rr rr             jsr     FRESTR
001251r 2  A2 00                ldx     #$00
001253r 2  86 66                stx     VALTYP
001255r 2  A8                   tay
001256r 2  60                   rts
001257r 2               
001257r 2               ; ----------------------------------------------------------------------------
001257r 2               ; "ASC" FUNCTION
001257r 2               ; ----------------------------------------------------------------------------
001257r 2               ASC:
001257r 2  20 rr rr             jsr     GETSTR
00125Ar 2  F0 08                beq     GOIQ
00125Cr 2  A0 00                ldy     #$00
00125Er 2  B1 79                lda     (INDEX),y
001260r 2  A8                   tay
001261r 2  4C rr rr             jmp     SNGFLT
001264r 2               ; ----------------------------------------------------------------------------
001264r 2               GOIQ:
001264r 2  4C rr rr             jmp     IQERR
001267r 2               
001267r 2               ; ----------------------------------------------------------------------------
001267r 2               ; SCAN TO NEXT CHARACTER AND CONVERT EXPRESSION
001267r 2               ; TO SINGLE BYTE IN X-REG
001267r 2               ; ----------------------------------------------------------------------------
001267r 2               GTBYTC:
001267r 2  20 CA 00             jsr     CHRGET
00126Ar 2               
00126Ar 2               ; ----------------------------------------------------------------------------
00126Ar 2               ; EVALUATE EXPRESSION AT TXTPTR, AND
00126Ar 2               ; CONVERT IT TO SINGLE BYTE IN X-REG
00126Ar 2               ; ----------------------------------------------------------------------------
00126Ar 2               GETBYT:
00126Ar 2  20 rr rr             jsr     FRMNUM
00126Dr 2               
00126Dr 2               ; ----------------------------------------------------------------------------
00126Dr 2               ; CONVERT (FAC) TO SINGLE BYTE INTEGER IN X-REG
00126Dr 2               ; ----------------------------------------------------------------------------
00126Dr 2               CONINT:
00126Dr 2  20 rr rr             jsr     MKINT
001270r 2  A6 BB                ldx     FAC_LAST-1
001272r 2  D0 F0                bne     GOIQ
001274r 2  A6 BC                ldx     FAC_LAST
001276r 2  4C D0 00             jmp     CHRGOT
001279r 2               
001279r 2               ; ----------------------------------------------------------------------------
001279r 2               ; "VAL" FUNCTION
001279r 2               ; ----------------------------------------------------------------------------
001279r 2               VAL:
001279r 2  20 rr rr             jsr     GETSTR
00127Cr 2  D0 03                bne     L35AC
00127Er 2  4C rr rr             jmp     ZERO_FAC
001281r 2               L35AC:
001281r 2  A6 D1                ldx     TXTPTR
001283r 2  A4 D2                ldy     TXTPTR+1
001285r 2  86 C8                stx     STRNG2
001287r 2  84 C9                sty     STRNG2+1
001289r 2  A6 79                ldx     INDEX
00128Br 2  86 D1                stx     TXTPTR
00128Dr 2  18                   clc
00128Er 2  65 79                adc     INDEX
001290r 2  85 7B                sta     DEST
001292r 2  A6 7A                ldx     INDEX+1
001294r 2  86 D2                stx     TXTPTR+1
001296r 2  90 01                bcc     L35C4
001298r 2  E8                   inx
001299r 2               L35C4:
001299r 2  86 7C                stx     DEST+1
00129Br 2  A0 00                ldy     #$00
00129Dr 2  B1 7B                lda     (DEST),y
00129Fr 2  48                   pha
0012A0r 2  A9 00                lda     #$00
0012A2r 2  91 7B                sta     (DEST),y
0012A4r 2  20 D0 00             jsr     CHRGOT
0012A7r 2  20 rr rr             jsr     FIN
0012AAr 2  68                   pla
0012ABr 2  A0 00                ldy     #$00
0012ADr 2  91 7B                sta     (DEST),y
0012AFr 2               
0012AFr 2               ; ----------------------------------------------------------------------------
0012AFr 2               ; COPY STRNG2 INTO TXTPTR
0012AFr 2               ; ----------------------------------------------------------------------------
0012AFr 2               POINT:
0012AFr 2  A6 C8                ldx     STRNG2
0012B1r 2  A4 C9                ldy     STRNG2+1
0012B3r 2  86 D1                stx     TXTPTR
0012B5r 2  84 D2                sty     TXTPTR+1
0012B7r 2  60                   rts
0012B8r 2               
0012B8r 2               ;.include "poke.s"
0012B8r 2               
0012B8r 2               .segment "MSBCODE"
0012B8r 2               
0012B8r 2               .ifndef CONFIG_NO_POKE
0012B8r 2               ; ----------------------------------------------------------------------------
0012B8r 2               ; EVALUATE "EXP1,EXP2"
0012B8r 2               ;
0012B8r 2               ; CONVERT EXP1 TO 16-BIT NUMBER IN LINNUM
0012B8r 2               ; CONVERT EXP2 TO 8-BIT NUMBER IN X-REG
0012B8r 2               ; ----------------------------------------------------------------------------
0012B8r 2               GTNUM:
0012B8r 2  20 rr rr             jsr     FRMNUM
0012BBr 2  20 rr rr             jsr     GETADR
0012BEr 2               
0012BEr 2               ; ----------------------------------------------------------------------------
0012BEr 2               ; EVALUATE ",EXPRESSION"
0012BEr 2               ; CONVERT EXPRESSION TO SINGLE BYTE IN X-REG
0012BEr 2               ; ----------------------------------------------------------------------------
0012BEr 2               COMBYTE:
0012BEr 2  20 rr rr             jsr     CHKCOM
0012C1r 2  4C rr rr             jmp     GETBYT
0012C4r 2               
0012C4r 2               ; ----------------------------------------------------------------------------
0012C4r 2               ; CONVERT (FAC) TO A 16-BIT VALUE IN LINNUM
0012C4r 2               ; ----------------------------------------------------------------------------
0012C4r 2               GETADR:
0012C4r 2  A5 BD                lda     FACSIGN
0012C6r 2  30 9C                bmi     GOIQ
0012C8r 2  A5 B8                lda     FAC
0012CAr 2  C9 91                cmp     #$91
0012CCr 2  B0 96                bcs     GOIQ
0012CEr 2  20 rr rr             jsr     QINT
0012D1r 2  A5 BB                lda     FAC_LAST-1
0012D3r 2  A4 BC                ldy     FAC_LAST
0012D5r 2  84 10                sty     LINNUM
0012D7r 2  85 11                sta     LINNUM+1
0012D9r 2  60                   rts
0012DAr 2               
0012DAr 2               ; ----------------------------------------------------------------------------
0012DAr 2               ; "PEEK" FUNCTION
0012DAr 2               ; ----------------------------------------------------------------------------
0012DAr 2               PEEK:
0012DAr 2               .ifdef CONFIG_PEEK_SAVE_LINNUM
0012DAr 2                       lda     LINNUM+1
0012DAr 2                       pha
0012DAr 2                       lda     LINNUM
0012DAr 2                       pha
0012DAr 2               .endif
0012DAr 2  20 rr rr             jsr     GETADR
0012DDr 2  A0 00                ldy     #$00
0012DFr 2               .ifdef CBM1
0012DFr 2               ; disallow PEEK between $C000 and $DFFF
0012DFr 2                       cmp     #$C0
0012DFr 2                       bcc     LD6F3
0012DFr 2                       cmp     #$E1
0012DFr 2                       bcc     LD6F6
0012DFr 2               LD6F3:
0012DFr 2               .endif
0012DFr 2               .ifdef CBM2
0012DFr 2               		nop ; patch that disables the compares above
0012DFr 2               		nop
0012DFr 2               		nop
0012DFr 2               		nop
0012DFr 2               		nop
0012DFr 2               		nop
0012DFr 2               		nop
0012DFr 2               		nop
0012DFr 2               .endif
0012DFr 2  B1 10                lda     (LINNUM),y
0012E1r 2  A8                   tay
0012E2r 2               .ifdef CONFIG_PEEK_SAVE_LINNUM
0012E2r 2                       pla
0012E2r 2                       sta     LINNUM
0012E2r 2                       pla
0012E2r 2                       sta     LINNUM+1
0012E2r 2               .endif
0012E2r 2               LD6F6:
0012E2r 2  4C rr rr             jmp     SNGFLT
0012E5r 2               
0012E5r 2               ; ----------------------------------------------------------------------------
0012E5r 2               ; "POKE" STATEMENT
0012E5r 2               ; ----------------------------------------------------------------------------
0012E5r 2               POKE:
0012E5r 2  20 rr rr             jsr     GTNUM
0012E8r 2  8A                   txa
0012E9r 2  A0 00                ldy     #$00
0012EBr 2  91 10                sta     (LINNUM),y
0012EDr 2  60                   rts
0012EEr 2               
0012EEr 2               ; ----------------------------------------------------------------------------
0012EEr 2               ; "WAIT" STATEMENT
0012EEr 2               ; ----------------------------------------------------------------------------
0012EEr 2               WAIT:
0012EEr 2  20 rr rr             jsr     GTNUM
0012F1r 2  86 A0                stx     FORPNT
0012F3r 2  A2 00                ldx     #$00
0012F5r 2  20 D0 00             jsr     CHRGOT
0012F8r 2               .ifdef CONFIG_EASTER_EGG
0012F8r 2  F0 29                beq     EASTER_EGG
0012FAr 2               .else
0012FAr 2                       beq     L3628
0012FAr 2               .endif
0012FAr 2  20 rr rr             jsr     COMBYTE
0012FDr 2               L3628:
0012FDr 2  86 A1                stx     FORPNT+1
0012FFr 2  A0 00                ldy     #$00
001301r 2               L362C:
001301r 2  B1 10                lda     (LINNUM),y
001303r 2  45 A1                eor     FORPNT+1
001305r 2  25 A0                and     FORPNT
001307r 2  F0 F8                beq     L362C
001309r 2               RTS3:
001309r 2  60                   rts
00130Ar 2               .endif
00130Ar 2               
00130Ar 2               ;.include "float.s"
00130Ar 2               
00130Ar 2               .segment "MSBCODE"
00130Ar 2               
00130Ar 2               TEMP1X = TEMP1+(5-BYTES_FP)
00130Ar 2               
00130Ar 2               ; ----------------------------------------------------------------------------
00130Ar 2               ; ADD 0.5 TO FAC
00130Ar 2               ; ----------------------------------------------------------------------------
00130Ar 2               FADDH:
00130Ar 2  A9 rr                lda     #<CON_HALF
00130Cr 2  A0 rr                ldy     #>CON_HALF
00130Er 2  4C rr rr             jmp     FADD
001311r 2               
001311r 2               ; ----------------------------------------------------------------------------
001311r 2               ; FAC = (Y,A) - FAC
001311r 2               ; ----------------------------------------------------------------------------
001311r 2               FSUB:
001311r 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
001314r 2               
001314r 2               ; ----------------------------------------------------------------------------
001314r 2               ; FAC = ARG - FAC
001314r 2               ; ----------------------------------------------------------------------------
001314r 2               FSUBT:
001314r 2  A5 BD                lda     FACSIGN
001316r 2  49 FF                eor     #$FF
001318r 2  85 BD                sta     FACSIGN
00131Ar 2  45 C5                eor     ARGSIGN
00131Cr 2  85 C6                sta     SGNCPR
00131Er 2  A5 B8                lda     FAC
001320r 2  4C rr rr             jmp     FADDT
001323r 2               
001323r 2               ; ----------------------------------------------------------------------------
001323r 2               ; Commodore BASIC V2 Easter Egg
001323r 2               ; ----------------------------------------------------------------------------
001323r 2               .ifdef CONFIG_EASTER_EGG
001323r 2               EASTER_EGG:
001323r 2  A5 10                lda     LINNUM
001325r 2  C9 66                cmp     #<6502
001327r 2  D0 D4                bne     L3628
001329r 2  A5 11                lda     LINNUM+1
00132Br 2  E9 19                sbc     #>6502
00132Dr 2  D0 CE                bne     L3628
00132Fr 2  85 10                sta     LINNUM
001331r 2  A8                   tay
001332r 2  A9 80                lda     #$80
001334r 2  85 11                sta     LINNUM+1
001336r 2               LD758:
001336r 2  A2 0A                ldx     #$0A
001338r 2               LD75A:
001338r 2  BD rr rr             lda     MICROSOFT-1,x
00133Br 2  29 3F                and     #$3F
00133Dr 2  91 10                sta     (LINNUM),y
00133Fr 2  C8                   iny
001340r 2  D0 02                bne     LD766
001342r 2  E6 11                inc     LINNUM+1
001344r 2               LD766:
001344r 2  CA                   dex
001345r 2  D0 F1                bne     LD75A
001347r 2  C6 A0                dec     FORPNT
001349r 2  D0 EB                bne     LD758
00134Br 2  60                   rts
00134Cr 2               .endif
00134Cr 2               
00134Cr 2               ; ----------------------------------------------------------------------------
00134Cr 2               ; SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
00134Cr 2               ; ----------------------------------------------------------------------------
00134Cr 2               FADD1:
00134Cr 2  20 rr rr             jsr     SHIFT_RIGHT
00134Fr 2  90 3C                bcc     FADD3
001351r 2               
001351r 2               ; ----------------------------------------------------------------------------
001351r 2               ; FAC = (Y,A) + FAC
001351r 2               ; ----------------------------------------------------------------------------
001351r 2               FADD:
001351r 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
001354r 2               
001354r 2               ; ----------------------------------------------------------------------------
001354r 2               ; FAC = ARG + FAC
001354r 2               ; ----------------------------------------------------------------------------
001354r 2               FADDT:
001354r 2  D0 03                bne     L365B
001356r 2  4C rr rr             jmp     COPY_ARG_TO_FAC
001359r 2               L365B:
001359r 2  A6 C7                ldx     FACEXTENSION
00135Br 2  86 AD                stx     ARGEXTENSION
00135Dr 2  A2 C0                ldx     #ARG
00135Fr 2  A5 C0                lda     ARG
001361r 2               FADD2:
001361r 2  A8                   tay
001362r 2  F0 A5                beq     RTS3
001364r 2  38                   sec
001365r 2  E5 B8                sbc     FAC
001367r 2  F0 24                beq     FADD3
001369r 2  90 12                bcc     L367F
00136Br 2  84 B8                sty     FAC
00136Dr 2  A4 C5                ldy     ARGSIGN
00136Fr 2  84 BD                sty     FACSIGN
001371r 2  49 FF                eor     #$FF
001373r 2  69 00                adc     #$00
001375r 2  A0 00                ldy     #$00
001377r 2  84 AD                sty     ARGEXTENSION
001379r 2  A2 B8                ldx     #FAC
00137Br 2  D0 04                bne     L3683
00137Dr 2               L367F:
00137Dr 2  A0 00                ldy     #$00
00137Fr 2  84 C7                sty     FACEXTENSION
001381r 2               L3683:
001381r 2  C9 F9                cmp     #$F9
001383r 2  30 C7                bmi     FADD1
001385r 2  A8                   tay
001386r 2  A5 C7                lda     FACEXTENSION
001388r 2  56 01                lsr     1,x
00138Ar 2  20 rr rr             jsr     SHIFT_RIGHT4
00138Dr 2               FADD3:
00138Dr 2  24 C6                bit     SGNCPR
00138Fr 2  10 57                bpl     FADD4
001391r 2  A0 B8                ldy     #FAC
001393r 2  E0 C0                cpx     #ARG
001395r 2  F0 02                beq     L369B
001397r 2  A0 C0                ldy     #ARG
001399r 2               L369B:
001399r 2  38                   sec
00139Ar 2  49 FF                eor     #$FF
00139Cr 2  65 AD                adc     ARGEXTENSION
00139Er 2  85 C7                sta     FACEXTENSION
0013A0r 2  B9 04 00             lda     4,y
0013A3r 2  F5 04                sbc     4,x
0013A5r 2  85 BC                sta     FAC+4
0013A7r 2  B9 03 00             lda     3,y
0013AAr 2  F5 03                sbc     3,x
0013ACr 2  85 BB                sta     FAC+3
0013AEr 2  B9 02 00             lda     2,y
0013B1r 2  F5 02                sbc     2,x
0013B3r 2  85 BA                sta     FAC+2
0013B5r 2  B9 01 00             lda     1,y
0013B8r 2  F5 01                sbc     1,x
0013BAr 2  85 B9                sta     FAC+1
0013BCr 2               
0013BCr 2               ; ----------------------------------------------------------------------------
0013BCr 2               ; NORMALIZE VALUE IN FAC
0013BCr 2               ; ----------------------------------------------------------------------------
0013BCr 2               NORMALIZE_FAC1:
0013BCr 2  B0 03                bcs     NORMALIZE_FAC2
0013BEr 2  20 rr rr             jsr     COMPLEMENT_FAC
0013C1r 2               NORMALIZE_FAC2:
0013C1r 2  A0 00                ldy     #$00
0013C3r 2  98                   tya
0013C4r 2  18                   clc
0013C5r 2               L36C7:
0013C5r 2  A6 B9                ldx     FAC+1
0013C7r 2  D0 4A                bne     NORMALIZE_FAC4
0013C9r 2  A6 BA                ldx     FAC+2
0013CBr 2  86 B9                stx     FAC+1
0013CDr 2  A6 BB                ldx     FAC+3
0013CFr 2  86 BA                stx     FAC+2
0013D1r 2  A6 BC                ldx     FAC+4
0013D3r 2  86 BB                stx     FAC+3
0013D5r 2  A6 C7                ldx     FACEXTENSION
0013D7r 2  86 BC                stx     FAC+4
0013D9r 2  84 C7                sty     FACEXTENSION
0013DBr 2  69 08                adc     #$08
0013DDr 2               ; bugfix?
0013DDr 2               ; fix does not exist on AppleSoft 2
0013DDr 2  C9 28                cmp     #(MANTISSA_BYTES+1)*8
0013DFr 2  D0 E4                bne     L36C7
0013E1r 2               
0013E1r 2               ; ----------------------------------------------------------------------------
0013E1r 2               ; SET FAC = 0
0013E1r 2               ; (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
0013E1r 2               ; ----------------------------------------------------------------------------
0013E1r 2               ZERO_FAC:
0013E1r 2  A9 00                lda     #$00
0013E3r 2               STA_IN_FAC_SIGN_AND_EXP:
0013E3r 2  85 B8                sta     FAC
0013E5r 2               STA_IN_FAC_SIGN:
0013E5r 2  85 BD                sta     FACSIGN
0013E7r 2  60                   rts
0013E8r 2               
0013E8r 2               ; ----------------------------------------------------------------------------
0013E8r 2               ; ADD MANTISSAS OF FAC AND ARG INTO FAC
0013E8r 2               ; ----------------------------------------------------------------------------
0013E8r 2               FADD4:
0013E8r 2  65 AD                adc     ARGEXTENSION
0013EAr 2  85 C7                sta     FACEXTENSION
0013ECr 2  A5 BC                lda     FAC+4
0013EEr 2  65 C4                adc     ARG+4
0013F0r 2  85 BC                sta     FAC+4
0013F2r 2  A5 BB                lda     FAC+3
0013F4r 2  65 C3                adc     ARG+3
0013F6r 2  85 BB                sta     FAC+3
0013F8r 2  A5 BA                lda     FAC+2
0013FAr 2  65 C2                adc     ARG+2
0013FCr 2  85 BA                sta     FAC+2
0013FEr 2  A5 B9                lda     FAC+1
001400r 2  65 C1                adc     ARG+1
001402r 2  85 B9                sta     FAC+1
001404r 2  4C rr rr             jmp     NORMALIZE_FAC5
001407r 2               
001407r 2               ; ----------------------------------------------------------------------------
001407r 2               ; FINISH NORMALIZING FAC
001407r 2               ; ----------------------------------------------------------------------------
001407r 2               NORMALIZE_FAC3:
001407r 2  69 01                adc     #$01
001409r 2  06 C7                asl     FACEXTENSION
00140Br 2  26 BC                rol     FAC+4
00140Dr 2  26 BB                rol     FAC+3
00140Fr 2  26 BA                rol     FAC+2
001411r 2  26 B9                rol     FAC+1
001413r 2               NORMALIZE_FAC4:
001413r 2  10 F2                bpl     NORMALIZE_FAC3
001415r 2  38                   sec
001416r 2  E5 B8                sbc     FAC
001418r 2  B0 C7                bcs     ZERO_FAC
00141Ar 2  49 FF                eor     #$FF
00141Cr 2  69 01                adc     #$01
00141Er 2  85 B8                sta     FAC
001420r 2               NORMALIZE_FAC5:
001420r 2  90 0E                bcc     L3764
001422r 2               NORMALIZE_FAC6:
001422r 2  E6 B8                inc     FAC
001424r 2  F0 42                beq     OVERFLOW
001426r 2  66 B9                ror     FAC+1
001428r 2  66 BA                ror     FAC+2
00142Ar 2  66 BB                ror     FAC+3
00142Cr 2  66 BC                ror     FAC+4
00142Er 2  66 C7                ror     FACEXTENSION
001430r 2               L3764:
001430r 2  60                   rts
001431r 2               
001431r 2               ; ----------------------------------------------------------------------------
001431r 2               ; 2'S COMPLEMENT OF FAC
001431r 2               ; ----------------------------------------------------------------------------
001431r 2               COMPLEMENT_FAC:
001431r 2  A5 BD                lda     FACSIGN
001433r 2  49 FF                eor     #$FF
001435r 2  85 BD                sta     FACSIGN
001437r 2               
001437r 2               ; ----------------------------------------------------------------------------
001437r 2               ; 2'S COMPLEMENT OF FAC MANTISSA ONLY
001437r 2               ; ----------------------------------------------------------------------------
001437r 2               COMPLEMENT_FAC_MANTISSA:
001437r 2  A5 B9                lda     FAC+1
001439r 2  49 FF                eor     #$FF
00143Br 2  85 B9                sta     FAC+1
00143Dr 2  A5 BA                lda     FAC+2
00143Fr 2  49 FF                eor     #$FF
001441r 2  85 BA                sta     FAC+2
001443r 2  A5 BB                lda     FAC+3
001445r 2  49 FF                eor     #$FF
001447r 2  85 BB                sta     FAC+3
001449r 2  A5 BC                lda     FAC+4
00144Br 2  49 FF                eor     #$FF
00144Dr 2  85 BC                sta     FAC+4
00144Fr 2  A5 C7                lda     FACEXTENSION
001451r 2  49 FF                eor     #$FF
001453r 2  85 C7                sta     FACEXTENSION
001455r 2  E6 C7                inc     FACEXTENSION
001457r 2  D0 0E                bne     RTS12
001459r 2               
001459r 2               ; ----------------------------------------------------------------------------
001459r 2               ; INCREMENT FAC MANTISSA
001459r 2               ; ----------------------------------------------------------------------------
001459r 2               INCREMENT_FAC_MANTISSA:
001459r 2  E6 BC                inc     FAC+4
00145Br 2  D0 0A                bne     RTS12
00145Dr 2  E6 BB                inc     FAC+3
00145Fr 2  D0 06                bne     RTS12
001461r 2  E6 BA                inc     FAC+2
001463r 2  D0 02                bne     RTS12
001465r 2  E6 B9                inc     FAC+1
001467r 2               RTS12:
001467r 2  60                   rts
001468r 2               OVERFLOW:
001468r 2  A2 45                ldx     #ERR_OVERFLOW
00146Ar 2  4C rr rr             jmp     ERROR
00146Dr 2               
00146Dr 2               ; ----------------------------------------------------------------------------
00146Dr 2               ; SHIFT 1,X THRU 5,X RIGHT
00146Dr 2               ; (A) = NEGATIVE OF SHIFT COUNT
00146Dr 2               ; (X) = POINTER TO BYTES TO BE SHIFTED
00146Dr 2               ;
00146Dr 2               ; RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
00146Dr 2               ; ----------------------------------------------------------------------------
00146Dr 2               SHIFT_RIGHT1:
00146Dr 2  A2 7C                ldx     #RESULT-1
00146Fr 2               SHIFT_RIGHT2:
00146Fr 2  B4 04                ldy     4,x
001471r 2  84 C7                sty     FACEXTENSION
001473r 2  B4 03                ldy     3,x
001475r 2  94 04                sty     4,x
001477r 2  B4 02                ldy     2,x
001479r 2  94 03                sty     3,x
00147Br 2  B4 01                ldy     1,x
00147Dr 2  94 02                sty     2,x
00147Fr 2  A4 BF                ldy     SHIFTSIGNEXT
001481r 2  94 01                sty     1,x
001483r 2               
001483r 2               ; ----------------------------------------------------------------------------
001483r 2               ; MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
001483r 2               ; ----------------------------------------------------------------------------
001483r 2               SHIFT_RIGHT:
001483r 2  69 08                adc     #$08
001485r 2  30 E8                bmi     SHIFT_RIGHT2
001487r 2  F0 E6                beq     SHIFT_RIGHT2
001489r 2  E9 08                sbc     #$08
00148Br 2  A8                   tay
00148Cr 2  A5 C7                lda     FACEXTENSION
00148Er 2  B0 14                bcs     SHIFT_RIGHT5
001490r 2               LB588:
001490r 2  16 01                asl     1,x
001492r 2  90 02                bcc     LB58E
001494r 2  F6 01                inc     1,x
001496r 2               LB58E:
001496r 2  76 01                ror     1,x
001498r 2  76 01                ror     1,x
00149Ar 2               
00149Ar 2               ; ----------------------------------------------------------------------------
00149Ar 2               ; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
00149Ar 2               ; ----------------------------------------------------------------------------
00149Ar 2               SHIFT_RIGHT4:
00149Ar 2  76 02                ror     2,x
00149Cr 2  76 03                ror     3,x
00149Er 2  76 04                ror     4,x
0014A0r 2  6A                   ror     a
0014A1r 2  C8                   iny
0014A2r 2  D0 EC                bne     LB588
0014A4r 2               SHIFT_RIGHT5:
0014A4r 2  18                   clc
0014A5r 2  60                   rts
0014A6r 2               
0014A6r 2               ; ----------------------------------------------------------------------------
0014A6r 2               
0014A6r 2               CON_ONE:
0014A6r 2  81 00 00 00          .byte   $81,$00,$00,$00,$00
0014AAr 2  00           
0014ABr 2               POLY_LOG:
0014ABr 2  03                   .byte   $03
0014ACr 2  7F 5E 56 CB  		.byte   $7F,$5E,$56,$CB,$79
0014B0r 2  79           
0014B1r 2  80 13 9B 0B  		.byte   $80,$13,$9B,$0B,$64
0014B5r 2  64           
0014B6r 2  80 76 38 93  		.byte   $80,$76,$38,$93,$16
0014BAr 2  16           
0014BBr 2  82 38 AA 3B          .byte   $82,$38,$AA,$3B,$20
0014BFr 2  20           
0014C0r 2               CON_SQR_HALF:
0014C0r 2  80 35 04 F3          .byte   $80,$35,$04,$F3,$34
0014C4r 2  34           
0014C5r 2               CON_SQR_TWO:
0014C5r 2  81 35 04 F3          .byte   $81,$35,$04,$F3,$34
0014C9r 2  34           
0014CAr 2               CON_NEG_HALF:
0014CAr 2  80 80 00 00          .byte   $80,$80,$00,$00,$00
0014CEr 2  00           
0014CFr 2               CON_LOG_TWO:
0014CFr 2  80 31 72 17          .byte   $80,$31,$72,$17,$F8
0014D3r 2  F8           
0014D4r 2               
0014D4r 2               ; ----------------------------------------------------------------------------
0014D4r 2               ; "LOG" FUNCTION
0014D4r 2               ; ----------------------------------------------------------------------------
0014D4r 2               LOG:
0014D4r 2  20 rr rr             jsr     SIGN
0014D7r 2  F0 02                beq     GIQ
0014D9r 2  10 03                bpl     LOG2
0014DBr 2               GIQ:
0014DBr 2  4C rr rr             jmp     IQERR
0014DEr 2               LOG2:
0014DEr 2  A5 B8                lda     FAC
0014E0r 2  E9 7F                sbc     #$7F
0014E2r 2  48                   pha
0014E3r 2  A9 80                lda     #$80
0014E5r 2  85 B8                sta     FAC
0014E7r 2  A9 rr                lda     #<CON_SQR_HALF
0014E9r 2  A0 rr                ldy     #>CON_SQR_HALF
0014EBr 2  20 rr rr             jsr     FADD
0014EEr 2  A9 rr                lda     #<CON_SQR_TWO
0014F0r 2  A0 rr                ldy     #>CON_SQR_TWO
0014F2r 2  20 rr rr             jsr     FDIV
0014F5r 2  A9 rr                lda     #<CON_ONE
0014F7r 2  A0 rr                ldy     #>CON_ONE
0014F9r 2  20 rr rr             jsr     FSUB
0014FCr 2  A9 rr                lda     #<POLY_LOG
0014FEr 2  A0 rr                ldy     #>POLY_LOG
001500r 2  20 rr rr             jsr     POLYNOMIAL_ODD
001503r 2  A9 rr                lda     #<CON_NEG_HALF
001505r 2  A0 rr                ldy     #>CON_NEG_HALF
001507r 2  20 rr rr             jsr     FADD
00150Ar 2  68                   pla
00150Br 2  20 rr rr             jsr     ADDACC
00150Er 2  A9 rr                lda     #<CON_LOG_TWO
001510r 2  A0 rr                ldy     #>CON_LOG_TWO
001512r 2               
001512r 2               ; ----------------------------------------------------------------------------
001512r 2               ; FAC = (Y,A) * FAC
001512r 2               ; ----------------------------------------------------------------------------
001512r 2               FMULT:
001512r 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
001515r 2               
001515r 2               ; ----------------------------------------------------------------------------
001515r 2               ; FAC = ARG * FAC
001515r 2               ; ----------------------------------------------------------------------------
001515r 2               FMULTT:
001515r 2  D0 03 4C rr          jeq     L3903
001519r 2  rr           
00151Ar 2  20 rr rr             jsr     ADD_EXPONENTS
00151Dr 2  A9 00                lda     #$00
00151Fr 2  85 7D                sta     RESULT
001521r 2  85 7E                sta     RESULT+1
001523r 2  85 7F                sta     RESULT+2
001525r 2  85 80                sta     RESULT+3
001527r 2  A5 C7                lda     FACEXTENSION
001529r 2  20 rr rr             jsr     MULTIPLY1
00152Cr 2  A5 BC                lda     FAC+4
00152Er 2  20 rr rr             jsr     MULTIPLY1
001531r 2  A5 BB                lda     FAC+3
001533r 2  20 rr rr             jsr     MULTIPLY1
001536r 2  A5 BA                lda     FAC+2
001538r 2  20 rr rr             jsr     MULTIPLY1
00153Br 2  A5 B9                lda     FAC+1
00153Dr 2  20 rr rr             jsr     MULTIPLY2
001540r 2  4C rr rr             jmp     COPY_RESULT_INTO_FAC
001543r 2               
001543r 2               ; ----------------------------------------------------------------------------
001543r 2               ; MULTIPLY ARG BY (A) INTO RESULT
001543r 2               ; ----------------------------------------------------------------------------
001543r 2               MULTIPLY1:
001543r 2  D0 03                bne     MULTIPLY2
001545r 2  4C rr rr             jmp     SHIFT_RIGHT1
001548r 2               MULTIPLY2:
001548r 2  4A                   lsr     a
001549r 2  09 80                ora     #$80
00154Br 2               L38A7:
00154Br 2  A8                   tay
00154Cr 2  90 19                bcc     L38C3
00154Er 2  18                   clc
00154Fr 2  A5 80                lda     RESULT+3
001551r 2  65 C4                adc     ARG+4
001553r 2  85 80                sta     RESULT+3
001555r 2  A5 7F                lda     RESULT+2
001557r 2  65 C3                adc     ARG+3
001559r 2  85 7F                sta     RESULT+2
00155Br 2  A5 7E                lda     RESULT+1
00155Dr 2  65 C2                adc     ARG+2
00155Fr 2  85 7E                sta     RESULT+1
001561r 2  A5 7D                lda     RESULT
001563r 2  65 C1                adc     ARG+1
001565r 2  85 7D                sta     RESULT
001567r 2               L38C3:
001567r 2  66 7D                ror     RESULT
001569r 2  66 7E                ror     RESULT+1
00156Br 2  66 7F                ror     RESULT+2
00156Dr 2  66 80                ror     RESULT+3
00156Fr 2  66 C7                ror     FACEXTENSION
001571r 2  98                   tya
001572r 2  4A                   lsr     a
001573r 2  D0 D6                bne     L38A7
001575r 2               L3903:
001575r 2  60                   rts
001576r 2               
001576r 2               ; ----------------------------------------------------------------------------
001576r 2               ; UNPACK NUMBER AT (Y,A) INTO ARG
001576r 2               ; ----------------------------------------------------------------------------
001576r 2               LOAD_ARG_FROM_YA:
001576r 2  85 79                sta     INDEX
001578r 2  84 7A                sty     INDEX+1
00157Ar 2  A0 04                ldy     #BYTES_FP-1
00157Cr 2  B1 79                lda     (INDEX),y
00157Er 2  85 C4                sta     ARG+4
001580r 2  88                   dey
001581r 2  B1 79                lda     (INDEX),y
001583r 2  85 C3                sta     ARG+3
001585r 2  88                   dey
001586r 2  B1 79                lda     (INDEX),y
001588r 2  85 C2                sta     ARG+2
00158Ar 2  88                   dey
00158Br 2  B1 79                lda     (INDEX),y
00158Dr 2  85 C5                sta     ARGSIGN
00158Fr 2  45 BD                eor     FACSIGN
001591r 2  85 C6                sta     SGNCPR
001593r 2  A5 C5                lda     ARGSIGN
001595r 2  09 80                ora     #$80
001597r 2  85 C1                sta     ARG+1
001599r 2  88                   dey
00159Ar 2  B1 79                lda     (INDEX),y
00159Cr 2  85 C0                sta     ARG
00159Er 2  A5 B8                lda     FAC
0015A0r 2  60                   rts
0015A1r 2               
0015A1r 2               ; ----------------------------------------------------------------------------
0015A1r 2               ; ADD EXPONENTS OF ARG AND FAC
0015A1r 2               ; (CALLED BY FMULT AND FDIV)
0015A1r 2               ;
0015A1r 2               ; ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
0015A1r 2               ; ----------------------------------------------------------------------------
0015A1r 2               ADD_EXPONENTS:
0015A1r 2  A5 C0                lda     ARG
0015A3r 2               ADD_EXPONENTS1:
0015A3r 2  F0 1F                beq     ZERO
0015A5r 2  18                   clc
0015A6r 2  65 B8                adc     FAC
0015A8r 2  90 04                bcc     L393C
0015AAr 2  30 1D                bmi     JOV
0015ACr 2  18                   clc
0015ADr 2  2C                   .byte   $2C
0015AEr 2               L393C:
0015AEr 2  10 14                bpl     ZERO
0015B0r 2  69 80                adc     #$80
0015B2r 2  85 B8                sta     FAC
0015B4r 2  D0 03                bne     L3947
0015B6r 2  4C rr rr             jmp     STA_IN_FAC_SIGN
0015B9r 2               L3947:
0015B9r 2  A5 C6                lda     SGNCPR
0015BBr 2  85 BD                sta     FACSIGN
0015BDr 2  60                   rts
0015BEr 2               
0015BEr 2               ; ----------------------------------------------------------------------------
0015BEr 2               ; IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
0015BEr 2               ; IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
0015BEr 2               ; CALLED FROM "EXP" FUNCTION
0015BEr 2               ; ----------------------------------------------------------------------------
0015BEr 2               OUTOFRNG:
0015BEr 2  A5 BD                lda     FACSIGN
0015C0r 2  49 FF                eor     #$FF
0015C2r 2  30 05                bmi     JOV
0015C4r 2               
0015C4r 2               ; ----------------------------------------------------------------------------
0015C4r 2               ; POP RETURN ADDRESS AND SET FAC=0
0015C4r 2               ; ----------------------------------------------------------------------------
0015C4r 2               ZERO:
0015C4r 2  68                   pla
0015C5r 2  68                   pla
0015C6r 2  4C rr rr             jmp     ZERO_FAC
0015C9r 2               JOV:
0015C9r 2  4C rr rr             jmp     OVERFLOW
0015CCr 2               
0015CCr 2               ; ----------------------------------------------------------------------------
0015CCr 2               ; MULTIPLY FAC BY 10
0015CCr 2               ; ----------------------------------------------------------------------------
0015CCr 2               MUL10:
0015CCr 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
0015CFr 2  AA                   tax
0015D0r 2  F0 10                beq     L3970
0015D2r 2  18                   clc
0015D3r 2  69 02                adc     #$02
0015D5r 2  B0 F2                bcs     JOV
0015D7r 2               LD9BF:
0015D7r 2  A2 00                ldx     #$00
0015D9r 2  86 C6                stx     SGNCPR
0015DBr 2  20 rr rr             jsr     FADD2
0015DEr 2  E6 B8                inc     FAC
0015E0r 2  F0 E7                beq     JOV
0015E2r 2               L3970:
0015E2r 2  60                   rts
0015E3r 2               
0015E3r 2               ; ----------------------------------------------------------------------------
0015E3r 2               CONTEN:
0015E3r 2  84 20 00 00          .byte   $84,$20,$00,$00,$00
0015E7r 2  00           
0015E8r 2               
0015E8r 2               ; ----------------------------------------------------------------------------
0015E8r 2               ; DIVIDE FAC BY 10
0015E8r 2               ; ----------------------------------------------------------------------------
0015E8r 2               DIV10:
0015E8r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
0015EBr 2  A9 rr                lda     #<CONTEN
0015EDr 2  A0 rr                ldy     #>CONTEN
0015EFr 2  A2 00                ldx     #$00
0015F1r 2               
0015F1r 2               ; ----------------------------------------------------------------------------
0015F1r 2               ; FAC = ARG / (Y,A)
0015F1r 2               ; ----------------------------------------------------------------------------
0015F1r 2               DIV:
0015F1r 2  86 C6                stx     SGNCPR
0015F3r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
0015F6r 2  4C rr rr             jmp     FDIVT
0015F9r 2               
0015F9r 2               ; ----------------------------------------------------------------------------
0015F9r 2               ; FAC = (Y,A) / FAC
0015F9r 2               ; ----------------------------------------------------------------------------
0015F9r 2               FDIV:
0015F9r 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
0015FCr 2               
0015FCr 2               ; ----------------------------------------------------------------------------
0015FCr 2               ; FAC = ARG / FAC
0015FCr 2               ; ----------------------------------------------------------------------------
0015FCr 2               FDIVT:
0015FCr 2  F0 76                beq     L3A02
0015FEr 2  20 rr rr             jsr     ROUND_FAC
001601r 2  A9 00                lda     #$00
001603r 2  38                   sec
001604r 2  E5 B8                sbc     FAC
001606r 2  85 B8                sta     FAC
001608r 2  20 rr rr             jsr     ADD_EXPONENTS
00160Br 2  E6 B8                inc     FAC
00160Dr 2  F0 BA                beq     JOV
00160Fr 2  A2 FC                ldx     #-MANTISSA_BYTES
001611r 2  A9 01                lda     #$01
001613r 2               L39A1:
001613r 2  A4 C1                ldy     ARG+1
001615r 2  C4 B9                cpy     FAC+1
001617r 2  D0 10                bne     L39B7
001619r 2  A4 C2                ldy     ARG+2
00161Br 2  C4 BA                cpy     FAC+2
00161Dr 2  D0 0A                bne     L39B7
00161Fr 2  A4 C3                ldy     ARG+3
001621r 2  C4 BB                cpy     FAC+3
001623r 2  D0 04                bne     L39B7
001625r 2  A4 C4                ldy     ARG+4
001627r 2  C4 BC                cpy     FAC+4
001629r 2               L39B7:
001629r 2  08                   php
00162Ar 2  2A                   rol     a
00162Br 2  90 09                bcc     L39C4
00162Dr 2  E8                   inx
00162Er 2  95 80                sta     RESULT_LAST-1,x
001630r 2  F0 32                beq     L39F2
001632r 2  10 34                bpl     L39F6
001634r 2  A9 01                lda     #$01
001636r 2               L39C4:
001636r 2  28                   plp
001637r 2  B0 0E                bcs     L39D5
001639r 2               L39C7:
001639r 2  06 C4                asl     ARG_LAST
00163Br 2  26 C3                rol     ARG+3
00163Dr 2  26 C2                rol     ARG+2
00163Fr 2  26 C1                rol     ARG+1
001641r 2  B0 E6                bcs     L39B7
001643r 2  30 CE                bmi     L39A1
001645r 2  10 E2                bpl     L39B7
001647r 2               L39D5:
001647r 2  A8                   tay
001648r 2  A5 C4                lda     ARG+4
00164Ar 2  E5 BC                sbc     FAC+4
00164Cr 2  85 C4                sta     ARG+4
00164Er 2  A5 C3                lda     ARG+3
001650r 2  E5 BB                sbc     FAC+3
001652r 2  85 C3                sta     ARG+3
001654r 2  A5 C2                lda     ARG+2
001656r 2  E5 BA                sbc     FAC+2
001658r 2  85 C2                sta     ARG+2
00165Ar 2  A5 C1                lda     ARG+1
00165Cr 2  E5 B9                sbc     FAC+1
00165Er 2  85 C1                sta     ARG+1
001660r 2  98                   tya
001661r 2  4C rr rr             jmp     L39C7
001664r 2               L39F2:
001664r 2  A9 40                lda     #$40
001666r 2  D0 CE                bne     L39C4
001668r 2               L39F6:
001668r 2  0A                   asl     a
001669r 2  0A                   asl     a
00166Ar 2  0A                   asl     a
00166Br 2  0A                   asl     a
00166Cr 2  0A                   asl     a
00166Dr 2  0A                   asl     a
00166Er 2  85 C7                sta     FACEXTENSION
001670r 2  28                   plp
001671r 2  4C rr rr             jmp     COPY_RESULT_INTO_FAC
001674r 2               L3A02:
001674r 2  A2 85                ldx     #ERR_ZERODIV
001676r 2  4C rr rr             jmp     ERROR
001679r 2               
001679r 2               ; ----------------------------------------------------------------------------
001679r 2               ; COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
001679r 2               ; ----------------------------------------------------------------------------
001679r 2               COPY_RESULT_INTO_FAC:
001679r 2  A5 7D                lda     RESULT
00167Br 2  85 B9                sta     FAC+1
00167Dr 2  A5 7E                lda     RESULT+1
00167Fr 2  85 BA                sta     FAC+2
001681r 2  A5 7F                lda     RESULT+2
001683r 2  85 BB                sta     FAC+3
001685r 2  A5 80                lda     RESULT+3
001687r 2  85 BC                sta     FAC+4
001689r 2  4C rr rr             jmp     NORMALIZE_FAC2
00168Cr 2               
00168Cr 2               ; ----------------------------------------------------------------------------
00168Cr 2               ; UNPACK (Y,A) INTO FAC
00168Cr 2               ; ----------------------------------------------------------------------------
00168Cr 2               LOAD_FAC_FROM_YA:
00168Cr 2  85 79                sta     INDEX
00168Er 2  84 7A                sty     INDEX+1
001690r 2  A0 04                ldy     #MANTISSA_BYTES
001692r 2  B1 79                lda     (INDEX),y
001694r 2  85 BC                sta     FAC+4
001696r 2  88                   dey
001697r 2  B1 79                lda     (INDEX),y
001699r 2  85 BB                sta     FAC+3
00169Br 2  88                   dey
00169Cr 2  B1 79                lda     (INDEX),y
00169Er 2  85 BA                sta     FAC+2
0016A0r 2  88                   dey
0016A1r 2  B1 79                lda     (INDEX),y
0016A3r 2  85 BD                sta     FACSIGN
0016A5r 2  09 80                ora     #$80
0016A7r 2  85 B9                sta     FAC+1
0016A9r 2  88                   dey
0016AAr 2  B1 79                lda     (INDEX),y
0016ACr 2  85 B8                sta     FAC
0016AEr 2  84 C7                sty     FACEXTENSION
0016B0r 2  60                   rts
0016B1r 2               
0016B1r 2               ; ----------------------------------------------------------------------------
0016B1r 2               ; ROUND FAC, STORE IN TEMP2
0016B1r 2               ; ----------------------------------------------------------------------------
0016B1r 2               STORE_FAC_IN_TEMP2_ROUNDED:
0016B1r 2  A2 B3                ldx     #TEMP2
0016B3r 2  2C                   .byte   $2C
0016B4r 2               
0016B4r 2               ; ----------------------------------------------------------------------------
0016B4r 2               ; ROUND FAC, STORE IN TEMP1
0016B4r 2               ; ----------------------------------------------------------------------------
0016B4r 2               STORE_FAC_IN_TEMP1_ROUNDED:
0016B4r 2  A2 AE                ldx     #TEMP1X
0016B6r 2  A0 00                ldy     #$00
0016B8r 2  F0 04                beq     STORE_FAC_AT_YX_ROUNDED
0016BAr 2               
0016BAr 2               ; ----------------------------------------------------------------------------
0016BAr 2               ; ROUND FAC, AND STORE WHERE FORPNT POINTS
0016BAr 2               ; ----------------------------------------------------------------------------
0016BAr 2               SETFOR:
0016BAr 2  A6 A0                ldx     FORPNT
0016BCr 2  A4 A1                ldy     FORPNT+1
0016BEr 2               
0016BEr 2               ; ----------------------------------------------------------------------------
0016BEr 2               ; ROUND FAC, AND STORE AT (Y,X)
0016BEr 2               ; ----------------------------------------------------------------------------
0016BEr 2               STORE_FAC_AT_YX_ROUNDED:
0016BEr 2  20 rr rr             jsr     ROUND_FAC
0016C1r 2  86 79                stx     INDEX
0016C3r 2  84 7A                sty     INDEX+1
0016C5r 2  A0 04                ldy     #MANTISSA_BYTES
0016C7r 2  A5 BC                lda     FAC+4
0016C9r 2  91 79                sta     (INDEX),y
0016CBr 2  88                   dey
0016CCr 2  A5 BB                lda     FAC+3
0016CEr 2  91 79                sta     (INDEX),y
0016D0r 2  88                   dey
0016D1r 2  A5 BA                lda     FAC+2
0016D3r 2  91 79                sta     (INDEX),y
0016D5r 2  88                   dey
0016D6r 2  A5 BD                lda     FACSIGN
0016D8r 2  09 7F                ora     #$7F
0016DAr 2  25 B9                and     FAC+1
0016DCr 2  91 79                sta     (INDEX),y
0016DEr 2  88                   dey
0016DFr 2  A5 B8                lda     FAC
0016E1r 2  91 79                sta     (INDEX),y
0016E3r 2  84 C7                sty     FACEXTENSION
0016E5r 2  60                   rts
0016E6r 2               
0016E6r 2               ; ----------------------------------------------------------------------------
0016E6r 2               ; COPY ARG INTO FAC
0016E6r 2               ; ----------------------------------------------------------------------------
0016E6r 2               COPY_ARG_TO_FAC:
0016E6r 2  A5 C5                lda     ARGSIGN
0016E8r 2               MFA:
0016E8r 2  85 BD                sta     FACSIGN
0016EAr 2  A2 05                ldx     #BYTES_FP
0016ECr 2               L3A7A:
0016ECr 2  B5 BF                lda     SHIFTSIGNEXT,x
0016EEr 2  95 B7                sta     EXPSGN,x
0016F0r 2  CA                   dex
0016F1r 2  D0 F9                bne     L3A7A
0016F3r 2  86 C7                stx     FACEXTENSION
0016F5r 2  60                   rts
0016F6r 2               
0016F6r 2               ; ----------------------------------------------------------------------------
0016F6r 2               ; ROUND FAC AND COPY TO ARG
0016F6r 2               ; ----------------------------------------------------------------------------
0016F6r 2               COPY_FAC_TO_ARG_ROUNDED:
0016F6r 2  20 rr rr             jsr     ROUND_FAC
0016F9r 2               MAF:
0016F9r 2  A2 06                ldx     #BYTES_FP+1
0016FBr 2               L3A89:
0016FBr 2  B5 B7                lda     EXPSGN,x
0016FDr 2  95 BF                sta     SHIFTSIGNEXT,x
0016FFr 2  CA                   dex
001700r 2  D0 F9                bne     L3A89
001702r 2  86 C7                stx     FACEXTENSION
001704r 2               RTS14:
001704r 2  60                   rts
001705r 2               
001705r 2               ; ----------------------------------------------------------------------------
001705r 2               ; ROUND FAC USING EXTENSION BYTE
001705r 2               ; ----------------------------------------------------------------------------
001705r 2               ROUND_FAC:
001705r 2  A5 B8                lda     FAC
001707r 2  F0 FB                beq     RTS14
001709r 2  06 C7                asl     FACEXTENSION
00170Br 2  90 F7                bcc     RTS14
00170Dr 2               
00170Dr 2               ; ----------------------------------------------------------------------------
00170Dr 2               ; INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
00170Dr 2               ; ----------------------------------------------------------------------------
00170Dr 2               INCREMENT_MANTISSA:
00170Dr 2  20 rr rr             jsr     INCREMENT_FAC_MANTISSA
001710r 2  D0 F2                bne     RTS14
001712r 2  4C rr rr             jmp     NORMALIZE_FAC6
001715r 2               
001715r 2               ; ----------------------------------------------------------------------------
001715r 2               ; TEST FAC FOR ZERO AND SIGN
001715r 2               ;
001715r 2               ; FAC > 0, RETURN +1
001715r 2               ; FAC = 0, RETURN  0
001715r 2               ; FAC < 0, RETURN -1
001715r 2               ; ----------------------------------------------------------------------------
001715r 2               SIGN:
001715r 2  A5 B8                lda     FAC
001717r 2  F0 09                beq     RTS15
001719r 2               L3AA7:
001719r 2  A5 BD                lda     FACSIGN
00171Br 2               SIGN2:
00171Br 2  2A                   rol     a
00171Cr 2  A9 FF                lda     #$FF
00171Er 2  B0 02                bcs     RTS15
001720r 2  A9 01                lda     #$01
001722r 2               RTS15:
001722r 2  60                   rts
001723r 2               
001723r 2               ; ----------------------------------------------------------------------------
001723r 2               ; "SGN" FUNCTION
001723r 2               ; ----------------------------------------------------------------------------
001723r 2               SGN:
001723r 2  20 rr rr             jsr     SIGN
001726r 2               
001726r 2               ; ----------------------------------------------------------------------------
001726r 2               ; CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
001726r 2               ; ----------------------------------------------------------------------------
001726r 2               FLOAT:
001726r 2  85 B9                sta     FAC+1
001728r 2  A9 00                lda     #$00
00172Ar 2  85 BA                sta     FAC+2
00172Cr 2  A2 88                ldx     #$88
00172Er 2               
00172Er 2               ; ----------------------------------------------------------------------------
00172Er 2               ; FLOAT UNSIGNED VALUE IN FAC+1,2
00172Er 2               ; (X) = EXPONENT
00172Er 2               ; ----------------------------------------------------------------------------
00172Er 2               FLOAT1:
00172Er 2  A5 B9                lda     FAC+1
001730r 2  49 FF                eor     #$FF
001732r 2  2A                   rol     a
001733r 2               
001733r 2               ; ----------------------------------------------------------------------------
001733r 2               ; FLOAT UNSIGNED VALUE IN FAC+1,2
001733r 2               ; (X) = EXPONENT
001733r 2               ; C=0 TO MAKE VALUE NEGATIVE
001733r 2               ; C=1 TO MAKE VALUE POSITIVE
001733r 2               ; ----------------------------------------------------------------------------
001733r 2               FLOAT2:
001733r 2  A9 00                lda     #$00
001735r 2  85 BC                sta     FAC+4
001737r 2  85 BB                sta     FAC+3
001739r 2               LDB21:
001739r 2  86 B8                stx     FAC
00173Br 2  85 C7                sta     FACEXTENSION
00173Dr 2  85 BD                sta     FACSIGN
00173Fr 2  4C rr rr             jmp     NORMALIZE_FAC1
001742r 2               
001742r 2               ; ----------------------------------------------------------------------------
001742r 2               ; "ABS" FUNCTION
001742r 2               ; ----------------------------------------------------------------------------
001742r 2               ABS:
001742r 2  46 BD                lsr     FACSIGN
001744r 2  60                   rts
001745r 2               
001745r 2               ; ----------------------------------------------------------------------------
001745r 2               ; COMPARE FAC WITH PACKED # AT (Y,A)
001745r 2               ; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
001745r 2               ; ----------------------------------------------------------------------------
001745r 2               FCOMP:
001745r 2  85 7B                sta     DEST
001747r 2               
001747r 2               ; ----------------------------------------------------------------------------
001747r 2               ; SPECIAL ENTRY FROM "NEXT" PROCESSOR
001747r 2               ; "DEST" ALREADY SET UP
001747r 2               ; ----------------------------------------------------------------------------
001747r 2               FCOMP2:
001747r 2  84 7C                sty     DEST+1
001749r 2  A0 00                ldy     #$00
00174Br 2  B1 7B                lda     (DEST),y
00174Dr 2  C8                   iny
00174Er 2  AA                   tax
00174Fr 2  F0 C4                beq     SIGN
001751r 2  B1 7B                lda     (DEST),y
001753r 2  45 BD                eor     FACSIGN
001755r 2  30 C2                bmi     L3AA7
001757r 2  E4 B8                cpx     FAC
001759r 2  D0 21                bne     L3B0A
00175Br 2  B1 7B                lda     (DEST),y
00175Dr 2  09 80                ora     #$80
00175Fr 2  C5 B9                cmp     FAC+1
001761r 2  D0 19                bne     L3B0A
001763r 2  C8                   iny
001764r 2  B1 7B                lda     (DEST),y
001766r 2  C5 BA                cmp     FAC+2
001768r 2  D0 12                bne     L3B0A
00176Ar 2  C8                   iny
00176Br 2  B1 7B                lda     (DEST),y
00176Dr 2  C5 BB                cmp     FAC+3
00176Fr 2  D0 0B                bne     L3B0A
001771r 2  C8                   iny
001772r 2  A9 7F                lda     #$7F
001774r 2  C5 C7                cmp     FACEXTENSION
001776r 2  B1 7B                lda     (DEST),y
001778r 2  E5 BC                sbc     FAC_LAST
00177Ar 2  F0 28                beq     L3B32
00177Cr 2               L3B0A:
00177Cr 2  A5 BD                lda     FACSIGN
00177Er 2  90 02                bcc     L3B10
001780r 2  49 FF                eor     #$FF
001782r 2               L3B10:
001782r 2  4C rr rr             jmp     SIGN2
001785r 2               
001785r 2               ; ----------------------------------------------------------------------------
001785r 2               ; QUICK INTEGER FUNCTION
001785r 2               ;
001785r 2               ; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
001785r 2               ; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
001785r 2               ; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
001785r 2               ;
001785r 2               ; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
001785r 2               ; ----------------------------------------------------------------------------
001785r 2               QINT:
001785r 2  A5 B8                lda     FAC
001787r 2  F0 4A                beq     QINT3
001789r 2  38                   sec
00178Ar 2  E9 A0                sbc     #120+8*BYTES_FP
00178Cr 2  24 BD                bit     FACSIGN
00178Er 2  10 09                bpl     L3B27
001790r 2  AA                   tax
001791r 2  A9 FF                lda     #$FF
001793r 2  85 BF                sta     SHIFTSIGNEXT
001795r 2  20 rr rr             jsr     COMPLEMENT_FAC_MANTISSA
001798r 2  8A                   txa
001799r 2               L3B27:
001799r 2  A2 B8                ldx     #FAC
00179Br 2  C9 F9                cmp     #$F9
00179Dr 2  10 06                bpl     QINT2
00179Fr 2  20 rr rr             jsr     SHIFT_RIGHT
0017A2r 2  84 BF                sty     SHIFTSIGNEXT
0017A4r 2               L3B32:
0017A4r 2  60                   rts
0017A5r 2               QINT2:
0017A5r 2  A8                   tay
0017A6r 2  A5 BD                lda     FACSIGN
0017A8r 2  29 80                and     #$80
0017AAr 2  46 B9                lsr     FAC+1
0017ACr 2  05 B9                ora     FAC+1
0017AEr 2  85 B9                sta     FAC+1
0017B0r 2  20 rr rr             jsr     SHIFT_RIGHT4
0017B3r 2  84 BF                sty     SHIFTSIGNEXT
0017B5r 2  60                   rts
0017B6r 2               
0017B6r 2               ; ----------------------------------------------------------------------------
0017B6r 2               ; "INT" FUNCTION
0017B6r 2               ;
0017B6r 2               ; USES QINT TO CONVERT (FAC) TO INTEGER FORM,
0017B6r 2               ; AND THEN REFLOATS THE INTEGER.
0017B6r 2               ; ----------------------------------------------------------------------------
0017B6r 2               INT:
0017B6r 2  A5 B8                lda     FAC
0017B8r 2  C9 A0                cmp     #120+8*BYTES_FP
0017BAr 2  B0 20                bcs     RTS17
0017BCr 2  20 rr rr             jsr     QINT
0017BFr 2  84 C7                sty     FACEXTENSION
0017C1r 2  A5 BD                lda     FACSIGN
0017C3r 2  84 BD                sty     FACSIGN
0017C5r 2  49 80                eor     #$80
0017C7r 2  2A                   rol     a
0017C8r 2  A9 A0                lda     #120+8*BYTES_FP
0017CAr 2  85 B8                sta     FAC
0017CCr 2  A5 BC                lda     FAC_LAST
0017CEr 2  85 62                sta     CHARAC
0017D0r 2  4C rr rr             jmp     NORMALIZE_FAC1
0017D3r 2               QINT3:
0017D3r 2  85 B9                sta     FAC+1
0017D5r 2  85 BA                sta     FAC+2
0017D7r 2  85 BB                sta     FAC+3
0017D9r 2  85 BC                sta     FAC+4
0017DBr 2  A8                   tay
0017DCr 2               RTS17:
0017DCr 2  60                   rts
0017DDr 2               
0017DDr 2               ; ----------------------------------------------------------------------------
0017DDr 2               ; CONVERT STRING TO FP VALUE IN FAC
0017DDr 2               ;
0017DDr 2               ; STRING POINTED TO BY TXTPTR
0017DDr 2               ; FIRST CHAR ALREADY SCANNED BY CHRGET
0017DDr 2               ; (A) = FIRST CHAR, C=0 IF DIGIT.
0017DDr 2               ; ----------------------------------------------------------------------------
0017DDr 2               FIN:
0017DDr 2  A0 00                ldy     #$00
0017DFr 2  A2 0A                ldx     #SERLEN-TMPEXP
0017E1r 2               L3B6F:
0017E1r 2  94 B4                sty     TMPEXP,x
0017E3r 2  CA                   dex
0017E4r 2  10 FB                bpl     L3B6F
0017E6r 2  90 0F                bcc     FIN2
0017E8r 2  C9 2D                cmp     #$2D
0017EAr 2  D0 04                bne     L3B7E
0017ECr 2  86 BE                stx     SERLEN
0017EEr 2  F0 04                beq     FIN1
0017F0r 2               L3B7E:
0017F0r 2  C9 2B                cmp     #$2B
0017F2r 2  D0 05                bne     FIN3
0017F4r 2               FIN1:
0017F4r 2  20 CA 00             jsr     CHRGET
0017F7r 2               FIN2:
0017F7r 2  90 5B                bcc     FIN9
0017F9r 2               FIN3:
0017F9r 2  C9 2E                cmp     #$2E
0017FBr 2  F0 2E                beq     FIN10
0017FDr 2  C9 45                cmp     #$45
0017FFr 2  D0 30                bne     FIN7
001801r 2  20 CA 00             jsr     CHRGET
001804r 2  90 17                bcc     FIN5
001806r 2  C9 A4                cmp     #TOKEN_MINUS
001808r 2  F0 0E                beq     L3BA6
00180Ar 2  C9 2D                cmp     #$2D
00180Cr 2  F0 0A                beq     L3BA6
00180Er 2  C9 A3                cmp     #TOKEN_PLUS
001810r 2  F0 08                beq     FIN4
001812r 2  C9 2B                cmp     #$2B
001814r 2  F0 04                beq     FIN4
001816r 2  D0 07                bne     FIN6
001818r 2               L3BA6:
001818r 2  66 B7                ror     EXPSGN
00181Ar 2               FIN4:
00181Ar 2  20 CA 00             jsr     CHRGET
00181Dr 2               FIN5:
00181Dr 2  90 5C                bcc     GETEXP
00181Fr 2               FIN6:
00181Fr 2  24 B7                bit     EXPSGN
001821r 2  10 0E                bpl     FIN7
001823r 2  A9 00                lda     #$00
001825r 2  38                   sec
001826r 2  E5 B5                sbc     EXPON
001828r 2  4C rr rr             jmp     FIN8
00182Br 2               
00182Br 2               ; ----------------------------------------------------------------------------
00182Br 2               ; FOUND A DECIMAL POINT
00182Br 2               ; ----------------------------------------------------------------------------
00182Br 2               FIN10:
00182Br 2  66 B6                ror     LOWTR
00182Dr 2  24 B6                bit     LOWTR
00182Fr 2  50 C3                bvc     FIN1
001831r 2               
001831r 2               ; ----------------------------------------------------------------------------
001831r 2               ; NUMBER TERMINATED, ADJUST EXPONENT NOW
001831r 2               ; ----------------------------------------------------------------------------
001831r 2               FIN7:
001831r 2  A5 B5                lda     EXPON
001833r 2               FIN8:
001833r 2  38                   sec
001834r 2  E5 B4                sbc     INDX
001836r 2  85 B5                sta     EXPON
001838r 2  F0 12                beq     L3BEE
00183Ar 2  10 09                bpl     L3BE7
00183Cr 2               L3BDE:
00183Cr 2  20 rr rr             jsr     DIV10
00183Fr 2  E6 B5                inc     EXPON
001841r 2  D0 F9                bne     L3BDE
001843r 2  F0 07                beq     L3BEE
001845r 2               L3BE7:
001845r 2  20 rr rr             jsr     MUL10
001848r 2  C6 B5                dec     EXPON
00184Ar 2  D0 F9                bne     L3BE7
00184Cr 2               L3BEE:
00184Cr 2  A5 BE                lda     SERLEN
00184Er 2  30 01                bmi     L3BF3
001850r 2  60                   rts
001851r 2               L3BF3:
001851r 2  4C rr rr             jmp     NEGOP
001854r 2               
001854r 2               ; ----------------------------------------------------------------------------
001854r 2               ; ACCUMULATE A DIGIT INTO FAC
001854r 2               ; ----------------------------------------------------------------------------
001854r 2               FIN9:
001854r 2  48                   pha
001855r 2  24 B6                bit     LOWTR
001857r 2  10 02                bpl     L3BFD
001859r 2  E6 B4                inc     INDX
00185Br 2               L3BFD:
00185Br 2  20 rr rr             jsr     MUL10
00185Er 2  68                   pla
00185Fr 2  38                   sec
001860r 2  E9 30                sbc     #$30
001862r 2  20 rr rr             jsr     ADDACC
001865r 2  4C rr rr             jmp     FIN1
001868r 2               
001868r 2               ; ----------------------------------------------------------------------------
001868r 2               ; ADD (A) TO FAC
001868r 2               ; ----------------------------------------------------------------------------
001868r 2               ADDACC:
001868r 2  48                   pha
001869r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
00186Cr 2  68                   pla
00186Dr 2  20 rr rr             jsr     FLOAT
001870r 2  A5 C5                lda     ARGSIGN
001872r 2  45 BD                eor     FACSIGN
001874r 2  85 C6                sta     SGNCPR
001876r 2  A6 B8                ldx     FAC
001878r 2  4C rr rr             jmp     FADDT
00187Br 2               
00187Br 2               ; ----------------------------------------------------------------------------
00187Br 2               ; ACCUMULATE DIGIT OF EXPONENT
00187Br 2               ; ----------------------------------------------------------------------------
00187Br 2               GETEXP:
00187Br 2  A5 B5                lda     EXPON
00187Dr 2  C9 0A                cmp     #MAX_EXPON
00187Fr 2  90 09                bcc     L3C2C
001881r 2  A9 64                lda     #$64
001883r 2  24 B7                bit     EXPSGN
001885r 2  30 11                bmi     L3C3A
001887r 2  4C rr rr             jmp     OVERFLOW
00188Ar 2               LDC70:
00188Ar 2               L3C2C:
00188Ar 2  0A                   asl     a
00188Br 2  0A                   asl     a
00188Cr 2  18                   clc
00188Dr 2  65 B5                adc     EXPON
00188Fr 2  0A                   asl     a
001890r 2  18                   clc
001891r 2  A0 00                ldy     #$00
001893r 2  71 D1                adc     (TXTPTR),y
001895r 2  38                   sec
001896r 2  E9 30                sbc     #$30
001898r 2               L3C3A:
001898r 2  85 B5                sta     EXPON
00189Ar 2  4C rr rr             jmp     FIN4
00189Dr 2               
00189Dr 2               ; ----------------------------------------------------------------------------
00189Dr 2               
00189Dr 2               CON_99999999_9:
00189Dr 2  9B 3E BC 1F          .byte   $9B,$3E,$BC,$1F,$FD
0018A1r 2  FD           
0018A2r 2               CON_999999999:
0018A2r 2  9E 6E 6B 27          .byte   $9E,$6E,$6B,$27,$FD
0018A6r 2  FD           
0018A7r 2               CON_BILLION:
0018A7r 2  9E 6E 6B 28          .byte   $9E,$6E,$6B,$28,$00
0018ABr 2  00           
0018ACr 2               
0018ACr 2               ; ----------------------------------------------------------------------------
0018ACr 2               ; PRINT "IN <LINE #>"
0018ACr 2               ; ----------------------------------------------------------------------------
0018ACr 2               INPRT:
0018ACr 2  A9 rr                lda     #<QT_IN
0018AEr 2  A0 rr                ldy     #>QT_IN
0018B0r 2  20 rr rr             jsr     GOSTROUT2
0018B3r 2  A5 91                lda     CURLIN+1
0018B5r 2  A6 90                ldx     CURLIN
0018B7r 2               
0018B7r 2               ; ----------------------------------------------------------------------------
0018B7r 2               ; PRINT A,X AS DECIMAL INTEGER
0018B7r 2               ; ----------------------------------------------------------------------------
0018B7r 2               LINPRT:
0018B7r 2  85 B9                sta     FAC+1
0018B9r 2  86 BA                stx     FAC+2
0018BBr 2  A2 90                ldx     #$90
0018BDr 2  38                   sec
0018BEr 2  20 rr rr             jsr     FLOAT2
0018C1r 2  20 rr rr             jsr     FOUT
0018C4r 2               GOSTROUT2:
0018C4r 2  4C rr rr             jmp     STROUT
0018C7r 2               
0018C7r 2               ; ----------------------------------------------------------------------------
0018C7r 2               ; CONVERT (FAC) TO STRING STARTING AT STACK
0018C7r 2               ; RETURN WITH (Y,A) POINTING AT STRING
0018C7r 2               ; ----------------------------------------------------------------------------
0018C7r 2               FOUT:
0018C7r 2  A0 01                ldy     #$01
0018C9r 2               
0018C9r 2               ; ----------------------------------------------------------------------------
0018C9r 2               ; "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
0018C9r 2               ; SO THAT RESULT STRING STARTS AT STACK-1
0018C9r 2               ; (THIS IS USED AS A FLAG)
0018C9r 2               ; ----------------------------------------------------------------------------
0018C9r 2               FOUT1:
0018C9r 2  A9 20                lda     #$20
0018CBr 2  24 BD                bit     FACSIGN
0018CDr 2  10 02                bpl     L3C73
0018CFr 2  A9 2D                lda     #$2D
0018D1r 2               L3C73:
0018D1r 2  99 FF 00             sta     STACK2-1,y
0018D4r 2  85 BD                sta     FACSIGN
0018D6r 2  84 C8                sty     STRNG2
0018D8r 2  C8                   iny
0018D9r 2  A9 30                lda     #$30
0018DBr 2  A6 B8                ldx     FAC
0018DDr 2  D0 03                bne     L3C84
0018DFr 2  4C rr rr             jmp     FOUT4
0018E2r 2               L3C84:
0018E2r 2  A9 00                lda     #$00
0018E4r 2  E0 80                cpx     #$80
0018E6r 2  F0 02                beq     L3C8C
0018E8r 2  B0 09                bcs     L3C95
0018EAr 2               L3C8C:
0018EAr 2  A9 rr                lda     #<CON_BILLION
0018ECr 2  A0 rr                ldy     #>CON_BILLION
0018EEr 2  20 rr rr             jsr     FMULT
0018F1r 2               
0018F1r 2  A9 F7                lda     #-9
0018F3r 2               L3C95:
0018F3r 2  85 B4                sta     INDX
0018F5r 2               ; ----------------------------------------------------------------------------
0018F5r 2               ; ADJUST UNTIL 1E8 <= (FAC) <1E9
0018F5r 2               ; ----------------------------------------------------------------------------
0018F5r 2               L3C97:
0018F5r 2  A9 rr                lda     #<CON_999999999
0018F7r 2  A0 rr                ldy     #>CON_999999999
0018F9r 2  20 rr rr             jsr     FCOMP
0018FCr 2  F0 1E                beq     L3CBE
0018FEr 2  10 12                bpl     L3CB4
001900r 2               L3CA2:
001900r 2  A9 rr                lda     #<CON_99999999_9
001902r 2  A0 rr                ldy     #>CON_99999999_9
001904r 2  20 rr rr             jsr     FCOMP
001907r 2  F0 02                beq     L3CAD
001909r 2  10 0E                bpl     L3CBB
00190Br 2               L3CAD:
00190Br 2  20 rr rr             jsr     MUL10
00190Er 2  C6 B4                dec     INDX
001910r 2  D0 EE                bne     L3CA2
001912r 2               L3CB4:
001912r 2  20 rr rr             jsr     DIV10
001915r 2  E6 B4                inc     INDX
001917r 2  D0 DC                bne     L3C97
001919r 2               L3CBB:
001919r 2  20 rr rr             jsr     FADDH
00191Cr 2               L3CBE:
00191Cr 2  20 rr rr             jsr     QINT
00191Fr 2               ; ----------------------------------------------------------------------------
00191Fr 2               ; FAC+1...FAC+4 IS NOW IN INTEGER FORM
00191Fr 2               ; WITH POWER OF TEN ADJUSTMENT IN TMPEXP
00191Fr 2               ;
00191Fr 2               ; IF -10 < TMPEXP > 1, PRINT IN DECIMAL FORM
00191Fr 2               ; OTHERWISE, PRINT IN EXPONENTIAL FORM
00191Fr 2               ; ----------------------------------------------------------------------------
00191Fr 2  A2 01                ldx     #$01
001921r 2  A5 B4                lda     INDX
001923r 2  18                   clc
001924r 2  69 0A                adc     #3*BYTES_FP-5
001926r 2  30 09                bmi     L3CD3
001928r 2  C9 0B                cmp     #3*BYTES_FP-4
00192Ar 2  B0 06                bcs     L3CD4
00192Cr 2  69 FF                adc     #$FF
00192Er 2  AA                   tax
00192Fr 2  A9 02                lda     #$02
001931r 2               L3CD3:
001931r 2  38                   sec
001932r 2               L3CD4:
001932r 2  E9 02                sbc     #$02
001934r 2  85 B5                sta     EXPON
001936r 2  86 B4                stx     INDX
001938r 2  8A                   txa
001939r 2  F0 02                beq     L3CDF
00193Br 2  10 13                bpl     L3CF2
00193Dr 2               L3CDF:
00193Dr 2  A4 C8                ldy     STRNG2
00193Fr 2  A9 2E                lda     #$2E
001941r 2  C8                   iny
001942r 2  99 FF 00             sta     STACK2-1,y
001945r 2  8A                   txa
001946r 2  F0 06                beq     L3CF0
001948r 2  A9 30                lda     #$30
00194Ar 2  C8                   iny
00194Br 2  99 FF 00             sta     STACK2-1,y
00194Er 2               L3CF0:
00194Er 2  84 C8                sty     STRNG2
001950r 2               ; ----------------------------------------------------------------------------
001950r 2               ; NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
001950r 2               ; ----------------------------------------------------------------------------
001950r 2               L3CF2:
001950r 2  A0 00                ldy     #$00
001952r 2               LDD3A:
001952r 2  A2 80                ldx     #$80
001954r 2               L3CF6:
001954r 2  A5 BC                lda     FAC_LAST
001956r 2  18                   clc
001957r 2  79 rr rr             adc     DECTBL+3,y
00195Ar 2  85 BC                sta     FAC+4
00195Cr 2  A5 BB                lda     FAC+3
00195Er 2  79 rr rr             adc     DECTBL+2,y
001961r 2  85 BB                sta     FAC+3
001963r 2  A5 BA                lda     FAC+2
001965r 2  79 rr rr             adc     DECTBL+1,y
001968r 2  85 BA                sta     FAC+2
00196Ar 2  A5 B9                lda     FAC+1
00196Cr 2  79 rr rr             adc     DECTBL,y
00196Fr 2  85 B9                sta     FAC+1
001971r 2  E8                   inx
001972r 2  B0 04                bcs     L3D1A
001974r 2  10 DE                bpl     L3CF6
001976r 2  30 02                bmi     L3D1C
001978r 2               L3D1A:
001978r 2  30 DA                bmi     L3CF6
00197Ar 2               L3D1C:
00197Ar 2  8A                   txa
00197Br 2  90 04                bcc     L3D23
00197Dr 2  49 FF                eor     #$FF
00197Fr 2  69 0A                adc     #$0A
001981r 2               L3D23:
001981r 2  69 2F                adc     #$2F
001983r 2  C8                   iny
001984r 2  C8                   iny
001985r 2  C8                   iny
001986r 2  C8                   iny
001987r 2  84 9E                sty     VARPNT
001989r 2  A4 C8                ldy     STRNG2
00198Br 2  C8                   iny
00198Cr 2  AA                   tax
00198Dr 2  29 7F                and     #$7F
00198Fr 2  99 FF 00             sta     STACK2-1,y
001992r 2  C6 B4                dec     INDX
001994r 2  D0 06                bne     L3D3E
001996r 2  A9 2E                lda     #$2E
001998r 2  C8                   iny
001999r 2  99 FF 00             sta     STACK2-1,y
00199Cr 2               L3D3E:
00199Cr 2  84 C8                sty     STRNG2
00199Er 2  A4 9E                ldy     VARPNT
0019A0r 2  8A                   txa
0019A1r 2  49 FF                eor     #$FF
0019A3r 2  29 80                and     #$80
0019A5r 2  AA                   tax
0019A6r 2  C0 24                cpy     #DECTBL_END-DECTBL
0019A8r 2               .ifdef CONFIG_CBM_ALL
0019A8r 2                       beq     LDD96
0019A8r 2                       cpy     #$3C ; XXX
0019A8r 2               .endif
0019A8r 2  D0 AA                bne     L3CF6
0019AAr 2               ; ----------------------------------------------------------------------------
0019AAr 2               ; NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
0019AAr 2               ; BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
0019AAr 2               ; DECIMAL POINT.
0019AAr 2               ; ----------------------------------------------------------------------------
0019AAr 2               LDD96:
0019AAr 2  A4 C8                ldy     STRNG2
0019ACr 2               L3D4E:
0019ACr 2  B9 FF 00             lda     STACK2-1,y
0019AFr 2  88                   dey
0019B0r 2  C9 30                cmp     #$30
0019B2r 2  F0 F8                beq     L3D4E
0019B4r 2  C9 2E                cmp     #$2E
0019B6r 2  F0 01                beq     L3D5B
0019B8r 2  C8                   iny
0019B9r 2               L3D5B:
0019B9r 2  A9 2B                lda     #$2B
0019BBr 2  A6 B5                ldx     EXPON
0019BDr 2  F0 2E                beq     L3D8F
0019BFr 2  10 08                bpl     L3D6B
0019C1r 2  A9 00                lda     #$00
0019C3r 2  38                   sec
0019C4r 2  E5 B5                sbc     EXPON
0019C6r 2  AA                   tax
0019C7r 2  A9 2D                lda     #$2D
0019C9r 2               L3D6B:
0019C9r 2  99 01 01             sta     STACK2+1,y
0019CCr 2  A9 45                lda     #$45
0019CEr 2  99 00 01             sta     STACK2,y
0019D1r 2  8A                   txa
0019D2r 2  A2 2F                ldx     #$2F
0019D4r 2  38                   sec
0019D5r 2               L3D77:
0019D5r 2  E8                   inx
0019D6r 2  E9 0A                sbc     #$0A
0019D8r 2  B0 FB                bcs     L3D77
0019DAr 2  69 3A                adc     #$3A
0019DCr 2  99 03 01             sta     STACK2+3,y
0019DFr 2  8A                   txa
0019E0r 2  99 02 01             sta     STACK2+2,y
0019E3r 2  A9 00                lda     #$00
0019E5r 2  99 04 01             sta     STACK2+4,y
0019E8r 2  F0 08                beq     L3D94
0019EAr 2               FOUT4:
0019EAr 2  99 FF 00             sta     STACK2-1,y
0019EDr 2               L3D8F:
0019EDr 2  A9 00                lda     #$00
0019EFr 2  99 00 01             sta     STACK2,y
0019F2r 2               L3D94:
0019F2r 2  A9 00                lda     #<STACK2
0019F4r 2  A0 01                ldy     #>STACK2
0019F6r 2  60                   rts
0019F7r 2               
0019F7r 2               ; ----------------------------------------------------------------------------
0019F7r 2               CON_HALF:
0019F7r 2               
0019F7r 2  80 00 00 00          .byte   $80,$00,$00,$00,$00
0019FBr 2  00           
0019FCr 2               ; ----------------------------------------------------------------------------
0019FCr 2               ; POWERS OF 10 FROM 1E8 DOWN TO 1,
0019FCr 2               ; AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
0019FCr 2               ; ----------------------------------------------------------------------------
0019FCr 2               DECTBL:
0019FCr 2  FA 0A 1F 00  		.byte	$FA,$0A,$1F,$00	; -100000000
001A00r 2  00 98 96 80  		.byte	$00,$98,$96,$80	; 10000000
001A04r 2  FF F0 BD C0  		.byte	$FF,$F0,$BD,$C0	; -1000000
001A08r 2  00 01 86 A0  		.byte	$00,$01,$86,$A0	; 100000
001A0Cr 2  FF FF D8 F0  		.byte	$FF,$FF,$D8,$F0	; -10000
001A10r 2  00 00 03 E8  		.byte   $00,$00,$03,$E8	; 1000
001A14r 2  FF FF FF 9C  		.byte	$FF,$FF,$FF,$9C	; -100
001A18r 2  00 00 00 0A  		.byte   $00,$00,$00,$0A	; 10
001A1Cr 2  FF FF FF FF  		.byte	$FF,$FF,$FF,$FF	; -1
001A20r 2               
001A20r 2               DECTBL_END:
001A20r 2               .ifdef CONFIG_CBM_ALL
001A20r 2               		.byte	$FF,$DF,$0A,$80 ; TI$
001A20r 2               		.byte	$00,$03,$4B,$C0
001A20r 2               		.byte	$FF,$FF,$73,$60
001A20r 2               		.byte	$00,$00,$0E,$10
001A20r 2               		.byte	$FF,$FF,$FD,$A8
001A20r 2               		.byte	$00,$00,$00,$3C
001A20r 2               .endif
001A20r 2               C_ZERO = CON_HALF + 2
001A20r 2               
001A20r 2               ; ----------------------------------------------------------------------------
001A20r 2               ; "SQR" FUNCTION
001A20r 2               ; ----------------------------------------------------------------------------
001A20r 2               SQR:
001A20r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001A23r 2  A9 rr                lda     #<CON_HALF
001A25r 2  A0 rr                ldy     #>CON_HALF
001A27r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
001A2Ar 2               
001A2Ar 2               ; ----------------------------------------------------------------------------
001A2Ar 2               ; EXPONENTIATION OPERATION
001A2Ar 2               ;
001A2Ar 2               ; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
001A2Ar 2               ; ----------------------------------------------------------------------------
001A2Ar 2               FPWRT:
001A2Ar 2  F0 70                beq     EXP
001A2Cr 2  A5 C0                lda     ARG
001A2Er 2  D0 03                bne     L3DD5
001A30r 2  4C rr rr             jmp     STA_IN_FAC_SIGN_AND_EXP
001A33r 2               L3DD5:
001A33r 2  A2 A5                ldx     #TEMP3
001A35r 2  A0 00                ldy     #$00
001A37r 2  20 rr rr             jsr     STORE_FAC_AT_YX_ROUNDED
001A3Ar 2  A5 C5                lda     ARGSIGN
001A3Cr 2  10 0F                bpl     L3DEF
001A3Er 2  20 rr rr             jsr     INT
001A41r 2  A9 A5                lda     #TEMP3
001A43r 2  A0 00                ldy     #$00
001A45r 2  20 rr rr             jsr     FCOMP
001A48r 2  D0 03                bne     L3DEF
001A4Ar 2  98                   tya
001A4Br 2  A4 62                ldy     CHARAC
001A4Dr 2               L3DEF:
001A4Dr 2  20 rr rr             jsr     MFA
001A50r 2  98                   tya
001A51r 2  48                   pha
001A52r 2  20 rr rr             jsr     LOG
001A55r 2  A9 A5                lda     #TEMP3
001A57r 2  A0 00                ldy     #$00
001A59r 2  20 rr rr             jsr     FMULT
001A5Cr 2  20 rr rr             jsr     EXP
001A5Fr 2  68                   pla
001A60r 2  4A                   lsr     a
001A61r 2  90 0A                bcc     L3E0F
001A63r 2               
001A63r 2               ; ----------------------------------------------------------------------------
001A63r 2               ; NEGATE VALUE IN FAC
001A63r 2               ; ----------------------------------------------------------------------------
001A63r 2               NEGOP:
001A63r 2  A5 B8                lda     FAC
001A65r 2  F0 06                beq     L3E0F
001A67r 2  A5 BD                lda     FACSIGN
001A69r 2  49 FF                eor     #$FF
001A6Br 2  85 BD                sta     FACSIGN
001A6Dr 2               L3E0F:
001A6Dr 2  60                   rts
001A6Er 2               
001A6Er 2               ; ----------------------------------------------------------------------------
001A6Er 2               
001A6Er 2               CON_LOG_E:
001A6Er 2  81 38 AA 3B          .byte   $81,$38,$AA,$3B,$29
001A72r 2  29           
001A73r 2               POLY_EXP:
001A73r 2  07                   .byte   $07
001A74r 2  71 34 58 3E  		.byte	$71,$34,$58,$3E,$56
001A78r 2  56           
001A79r 2  74 16 7E B3  		.byte	$74,$16,$7E,$B3,$1B
001A7Dr 2  1B           
001A7Er 2  77 2F EE E3  		.byte	$77,$2F,$EE,$E3,$85
001A82r 2  85           
001A83r 2  7A 1D 84 1C          .byte   $7A,$1D,$84,$1C,$2A
001A87r 2  2A           
001A88r 2  7C 63 59 58  		.byte	$7C,$63,$59,$58,$0A
001A8Cr 2  0A           
001A8Dr 2  7E 75 FD E7  		.byte	$7E,$75,$FD,$E7,$C6
001A91r 2  C6           
001A92r 2  80 31 72 18  		.byte	$80,$31,$72,$18,$10
001A96r 2  10           
001A97r 2  81 00 00 00  		.byte	$81,$00,$00,$00,$00
001A9Br 2  00           
001A9Cr 2               
001A9Cr 2               ; ----------------------------------------------------------------------------
001A9Cr 2               ; "EXP" FUNCTION
001A9Cr 2               ;
001A9Cr 2               ; FAC = E ^ FAC
001A9Cr 2               ; ----------------------------------------------------------------------------
001A9Cr 2               EXP:
001A9Cr 2  A9 rr                lda     #<CON_LOG_E
001A9Er 2  A0 rr                ldy     #>CON_LOG_E
001AA0r 2  20 rr rr             jsr     FMULT
001AA3r 2  A5 C7                lda     FACEXTENSION
001AA5r 2  69 50                adc     #$50
001AA7r 2  90 03                bcc     L3E4E
001AA9r 2  20 rr rr             jsr     INCREMENT_MANTISSA
001AACr 2               L3E4E:
001AACr 2  85 AD                sta     ARGEXTENSION
001AAEr 2  20 rr rr             jsr     MAF
001AB1r 2  A5 B8                lda     FAC
001AB3r 2  C9 88                cmp     #$88
001AB5r 2  90 03                bcc     L3E5C
001AB7r 2               L3E59:
001AB7r 2  20 rr rr             jsr     OUTOFRNG
001ABAr 2               L3E5C:
001ABAr 2  20 rr rr             jsr     INT
001ABDr 2  A5 62                lda     CHARAC
001ABFr 2  18                   clc
001AC0r 2  69 81                adc     #$81
001AC2r 2  F0 F3                beq     L3E59
001AC4r 2  38                   sec
001AC5r 2  E9 01                sbc     #$01
001AC7r 2  48                   pha
001AC8r 2  A2 05                ldx     #BYTES_FP
001ACAr 2               L3E6C:
001ACAr 2  B5 C0                lda     ARG,x
001ACCr 2  B4 B8                ldy     FAC,x
001ACEr 2  95 B8                sta     FAC,x
001AD0r 2  94 C0                sty     ARG,x
001AD2r 2  CA                   dex
001AD3r 2  10 F5                bpl     L3E6C
001AD5r 2  A5 AD                lda     ARGEXTENSION
001AD7r 2  85 C7                sta     FACEXTENSION
001AD9r 2  20 rr rr             jsr     FSUBT
001ADCr 2  20 rr rr             jsr     NEGOP
001ADFr 2  A9 rr                lda     #<POLY_EXP
001AE1r 2  A0 rr                ldy     #>POLY_EXP
001AE3r 2  20 rr rr             jsr     POLYNOMIAL
001AE6r 2  A9 00                lda     #$00
001AE8r 2  85 C6                sta     SGNCPR
001AEAr 2  68                   pla
001AEBr 2  20 rr rr             jsr     ADD_EXPONENTS1
001AEEr 2  60                   rts
001AEFr 2               
001AEFr 2               ; ----------------------------------------------------------------------------
001AEFr 2               ; ODD POLYNOMIAL SUBROUTINE
001AEFr 2               ;
001AEFr 2               ; F(X) = X * P(X^2)
001AEFr 2               ;
001AEFr 2               ; WHERE:  X IS VALUE IN FAC
001AEFr 2               ;	Y,A POINTS AT COEFFICIENT TABLE
001AEFr 2               ;	FIRST BYTE OF COEFF. TABLE IS N
001AEFr 2               ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
001AEFr 2               ;
001AEFr 2               ; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
001AEFr 2               ; ----------------------------------------------------------------------------
001AEFr 2               POLYNOMIAL_ODD:
001AEFr 2  85 C8                sta     STRNG2
001AF1r 2  84 C9                sty     STRNG2+1
001AF3r 2  20 rr rr             jsr     STORE_FAC_IN_TEMP1_ROUNDED
001AF6r 2  A9 AE                lda     #TEMP1X
001AF8r 2  20 rr rr             jsr     FMULT
001AFBr 2  20 rr rr             jsr     SERMAIN
001AFEr 2  A9 AE                lda     #TEMP1X
001B00r 2  A0 00                ldy     #$00
001B02r 2  4C rr rr             jmp     FMULT
001B05r 2               
001B05r 2               ; ----------------------------------------------------------------------------
001B05r 2               ; NORMAL POLYNOMIAL SUBROUTINE
001B05r 2               ;
001B05r 2               ; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
001B05r 2               ;
001B05r 2               ; WHERE:  X IS VALUE IN FAC
001B05r 2               ;	Y,A POINTS AT COEFFICIENT TABLE
001B05r 2               ;	FIRST BYTE OF COEFF. TABLE IS N
001B05r 2               ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
001B05r 2               ; ----------------------------------------------------------------------------
001B05r 2               POLYNOMIAL:
001B05r 2  85 C8                sta     STRNG2
001B07r 2  84 C9                sty     STRNG2+1
001B09r 2               SERMAIN:
001B09r 2  20 rr rr             jsr     STORE_FAC_IN_TEMP2_ROUNDED
001B0Cr 2  B1 C8                lda     (STRNG2),y
001B0Er 2  85 BE                sta     SERLEN
001B10r 2  A4 C8                ldy     STRNG2
001B12r 2  C8                   iny
001B13r 2  98                   tya
001B14r 2  D0 02                bne     L3EBA
001B16r 2  E6 C9                inc     STRNG2+1
001B18r 2               L3EBA:
001B18r 2  85 C8                sta     STRNG2
001B1Ar 2  A4 C9                ldy     STRNG2+1
001B1Cr 2               L3EBE:
001B1Cr 2  20 rr rr             jsr     FMULT
001B1Fr 2  A5 C8                lda     STRNG2
001B21r 2  A4 C9                ldy     STRNG2+1
001B23r 2  18                   clc
001B24r 2  69 05                adc     #BYTES_FP
001B26r 2  90 01                bcc     L3ECB
001B28r 2  C8                   iny
001B29r 2               L3ECB:
001B29r 2  85 C8                sta     STRNG2
001B2Br 2  84 C9                sty     STRNG2+1
001B2Dr 2  20 rr rr             jsr     FADD
001B30r 2  A9 B3                lda     #TEMP2
001B32r 2  A0 00                ldy     #$00
001B34r 2  C6 BE                dec     SERLEN
001B36r 2  D0 E4                bne     L3EBE
001B38r 2               RTS19:
001B38r 2  60                   rts
001B39r 2               
001B39r 2               ;.include "chrget.s"
001B39r 2               
001B39r 2               .segment "MSBCHRGET"
000000r 2               RAMSTART1:
000000r 2               GENERIC_CHRGET:
000000r 2  E6 D1                inc     TXTPTR
000002r 2  D0 02                bne     GENERIC_CHRGOT
000004r 2  E6 D2                inc     TXTPTR+1
000006r 2               GENERIC_CHRGOT:
000006r 2               GENERIC_TXTPTR = GENERIC_CHRGOT + 1
000006r 2  AD 60 EA             lda     $EA60
000009r 2  C9 3A                cmp     #$3A
00000Br 2  B0 0A                bcs     L4058
00000Dr 2               GENERIC_CHRGOT2:
00000Dr 2  C9 20                cmp     #$20
00000Fr 2  F0 EF                beq     GENERIC_CHRGET
000011r 2  38                   sec
000012r 2  E9 30                sbc     #$30
000014r 2  38                   sec
000015r 2  E9 D0                sbc     #$D0
000017r 2               L4058:
000017r 2  60                   rts
000018r 2               
000018r 2               ;.include "rnd.s"
000018r 2               
000018r 2               .segment "MSBCODE"
001B39r 2               
001B39r 2               ; ----------------------------------------------------------------------------
001B39r 2               ; "RND" FUNCTION
001B39r 2               ; ----------------------------------------------------------------------------
001B39r 2               ; <<< THESE ARE MISSING ONE BYTE FOR FP VALUES >>>
001B39r 2               ; (non CONFIG_SMALL)
001B39r 2               CONRND1:
001B39r 2  98 35 44 7A          .byte   $98,$35,$44,$7A
001B3Dr 2               CONRND2:
001B3Dr 2  68 28 B1 46          .byte   $68,$28,$B1,$46
001B41r 2               RND:
001B41r 2  20 rr rr             jsr     SIGN
001B44r 2               .ifdef CONFIG_CBM_ALL
001B44r 2                       bmi     L3F01
001B44r 2                       bne     LDF63
001B44r 2                       lda     ENTROPY
001B44r 2                       sta     FAC+1
001B44r 2                       lda     ENTROPY+4
001B44r 2                       sta     FAC+2
001B44r 2                       lda     ENTROPY+1
001B44r 2                       sta     FAC+3
001B44r 2                       lda     ENTROPY+5
001B44r 2                       sta     FAC+4
001B44r 2                       jmp     LDF88
001B44r 2               LDF63:
001B44r 2               .else
001B44r 2  AA                   tax
001B45r 2  30 18                bmi     L3F01
001B47r 2               .endif
001B47r 2  A9 E2                lda     #<RNDSEED
001B49r 2  A0 00                ldy     #>RNDSEED
001B4Br 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
001B4Er 2               .ifndef CONFIG_CBM_ALL
001B4Er 2  8A                   txa
001B4Fr 2  F0 E7                beq     RTS19
001B51r 2               .endif
001B51r 2  A9 rr                lda     #<CONRND1
001B53r 2  A0 rr                ldy     #>CONRND1
001B55r 2  20 rr rr             jsr     FMULT
001B58r 2  A9 rr                lda     #<CONRND2
001B5Ar 2  A0 rr                ldy     #>CONRND2
001B5Cr 2  20 rr rr             jsr     FADD
001B5Fr 2               L3F01:
001B5Fr 2  A6 BC                ldx     FAC_LAST
001B61r 2  A5 B9                lda     FAC+1
001B63r 2  85 BC                sta     FAC_LAST
001B65r 2  86 B9                stx     FAC+1
001B67r 2               .ifdef CONFIG_CBM_ALL
001B67r 2                       ldx     FAC+2
001B67r 2                       lda     FAC+3
001B67r 2                       sta     FAC+2
001B67r 2                       stx     FAC+3
001B67r 2               LDF88:
001B67r 2               .endif
001B67r 2  A9 00                lda     #$00
001B69r 2  85 BD                sta     FACSIGN
001B6Br 2  A5 B8                lda     FAC
001B6Dr 2  85 C7                sta     FACEXTENSION
001B6Fr 2  A9 80                lda     #$80
001B71r 2  85 B8                sta     FAC
001B73r 2  20 rr rr             jsr     NORMALIZE_FAC2
001B76r 2  A2 E2                ldx     #<RNDSEED
001B78r 2  A0 00                ldy     #>RNDSEED
001B7Ar 2               GOMOVMF:
001B7Ar 2  4C rr rr             jmp     STORE_FAC_AT_YX_ROUNDED
001B7Dr 2               
001B7Dr 2               .segment "MSBCHRGET"
000018r 2               ; ----------------------------------------------------------------------------
000018r 2               ; INITIAL VALUE FOR RANDOM NUMBER, ALSO COPIED
000018r 2               ; IN ALONG WITH CHRGET, BUT ERRONEOUSLY:
000018r 2               ; <<< THE LAST BYTE IS NOT COPIED >>>
000018r 2               ; (on all non-CONFIG_SMALL)
000018r 2               ; ----------------------------------------------------------------------------
000018r 2               GENERIC_RNDSEED:
000018r 2               ; random number seed
000018r 2  80 4F C7 52          .byte   $80,$4F,$C7,$52,$58
00001Cr 2  58           
00001Dr 2               GENERIC_CHRGET_END:
00001Dr 2               
00001Dr 2               ;.include "trig.s"
00001Dr 2               
00001Dr 2               .segment "MSBCODE"
001B7Dr 2               
001B7Dr 2               SIN_COS_TAN_ATN:
001B7Dr 2               ; ----------------------------------------------------------------------------
001B7Dr 2               ; "COS" FUNCTION
001B7Dr 2               ; ----------------------------------------------------------------------------
001B7Dr 2               COS:
001B7Dr 2  A9 rr                lda     #<CON_PI_HALF
001B7Fr 2  A0 rr                ldy     #>CON_PI_HALF
001B81r 2  20 rr rr             jsr     FADD
001B84r 2               
001B84r 2               ; ----------------------------------------------------------------------------
001B84r 2               ; "SIN" FUNCTION
001B84r 2               ; ----------------------------------------------------------------------------
001B84r 2               SIN:
001B84r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001B87r 2  A9 rr                lda     #<CON_PI_DOUB
001B89r 2  A0 rr                ldy     #>CON_PI_DOUB
001B8Br 2  A6 C5                ldx     ARGSIGN
001B8Dr 2  20 rr rr             jsr     DIV
001B90r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001B93r 2  20 rr rr             jsr     INT
001B96r 2  A9 00                lda     #$00
001B98r 2  85 C6                sta     STRNG1
001B9Ar 2  20 rr rr             jsr     FSUBT
001B9Dr 2               ; ----------------------------------------------------------------------------
001B9Dr 2               ; (FAC) = ANGLE AS A FRACTION OF A FULL CIRCLE
001B9Dr 2               ;
001B9Dr 2               ; NOW FOLD THE RANGE INTO A QUARTER CIRCLE
001B9Dr 2               ;
001B9Dr 2               ; <<< THERE ARE MUCH SIMPLER WAYS TO DO THIS >>>
001B9Dr 2               ; ----------------------------------------------------------------------------
001B9Dr 2  A9 rr                lda     #<QUARTER
001B9Fr 2  A0 rr                ldy     #>QUARTER
001BA1r 2  20 rr rr             jsr     FSUB
001BA4r 2  A5 BD                lda     FACSIGN
001BA6r 2  48                   pha
001BA7r 2  10 0D                bpl     SIN1
001BA9r 2  20 rr rr             jsr     FADDH
001BACr 2  A5 BD                lda     FACSIGN
001BAEr 2  30 09                bmi     L3F5B
001BB0r 2  A5 6B                lda     CPRMASK
001BB2r 2  49 FF                eor     #$FF
001BB4r 2  85 6B                sta     CPRMASK
001BB6r 2               ; ----------------------------------------------------------------------------
001BB6r 2               ; IF FALL THRU, RANGE IS 0...1/2
001BB6r 2               ; IF BRANCH HERE, RANGE IS 0...1/4
001BB6r 2               ; ----------------------------------------------------------------------------
001BB6r 2               SIN1:
001BB6r 2  20 rr rr             jsr     NEGOP
001BB9r 2               ; ----------------------------------------------------------------------------
001BB9r 2               ; IF FALL THRU, RANGE IS -1/2...0
001BB9r 2               ; IF BRANCH HERE, RANGE IS -1/4...0
001BB9r 2               ; ----------------------------------------------------------------------------
001BB9r 2               L3F5B:
001BB9r 2  A9 rr                lda     #<QUARTER
001BBBr 2  A0 rr                ldy     #>QUARTER
001BBDr 2  20 rr rr             jsr     FADD
001BC0r 2  68                   pla
001BC1r 2  10 03                bpl     L3F68
001BC3r 2  20 rr rr             jsr     NEGOP
001BC6r 2               L3F68:
001BC6r 2  A9 rr                lda     #<POLY_SIN
001BC8r 2  A0 rr                ldy     #>POLY_SIN
001BCAr 2  4C rr rr             jmp     POLYNOMIAL_ODD
001BCDr 2               
001BCDr 2               ; ----------------------------------------------------------------------------
001BCDr 2               ; "TAN" FUNCTION
001BCDr 2               ;
001BCDr 2               ; COMPUTE TAN(X) = SIN(X) / COS(X)
001BCDr 2               ; ----------------------------------------------------------------------------
001BCDr 2               TAN:
001BCDr 2  20 rr rr             jsr     STORE_FAC_IN_TEMP1_ROUNDED
001BD0r 2  A9 00                lda     #$00
001BD2r 2  85 6B                sta     CPRMASK
001BD4r 2  20 rr rr             jsr     SIN
001BD7r 2  A2 A5                ldx     #TEMP3
001BD9r 2  A0 00                ldy     #$00
001BDBr 2  20 rr rr             jsr     GOMOVMF
001BDEr 2  A9 AE                lda     #TEMP1+(5-BYTES_FP)
001BE0r 2  A0 00                ldy     #$00
001BE2r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
001BE5r 2  A9 00                lda     #$00
001BE7r 2  85 BD                sta     FACSIGN
001BE9r 2  A5 6B                lda     CPRMASK
001BEBr 2  20 rr rr             jsr     TAN1
001BEEr 2  A9 A5                lda     #TEMP3
001BF0r 2  A0 00                ldy     #$00
001BF2r 2  4C rr rr             jmp     FDIV
001BF5r 2               TAN1:
001BF5r 2  48                   pha
001BF6r 2  4C rr rr             jmp     SIN1
001BF9r 2               
001BF9r 2               ; ----------------------------------------------------------------------------
001BF9r 2               
001BF9r 2               CON_PI_HALF:
001BF9r 2  81 49 0F DA          .byte   $81,$49,$0F,$DA,$A2
001BFDr 2  A2           
001BFEr 2               CON_PI_DOUB:
001BFEr 2  83 49 0F DA          .byte   $83,$49,$0F,$DA,$A2
001C02r 2  A2           
001C03r 2               QUARTER:
001C03r 2  7F 00 00 00          .byte   $7F,$00,$00,$00,$00
001C07r 2  00           
001C08r 2               POLY_SIN:
001C08r 2  05 84 E6 1A          .byte   $05,$84,$E6,$1A,$2D,$1B,$86,$28
001C0Cr 2  2D 1B 86 28  
001C10r 2  07 FB F8 87          .byte   $07,$FB,$F8,$87,$99,$68,$89,$01
001C14r 2  99 68 89 01  
001C18r 2  87 23 35 DF          .byte   $87,$23,$35,$DF,$E1,$86,$A5,$5D
001C1Cr 2  E1 86 A5 5D  
001C20r 2  E7 28 83 49          .byte   $E7,$28,$83,$49,$0F,$DA,$A2
001C24r 2  0F DA A2     
001C27r 2               
001C27r 2               ;; ASCII encoded easter egg
001C27r 2               MICROSOFT:
001C27r 2  A6 D3 C1 C8          .byte   $A6,$D3,$C1,$C8,$D4,$C8,$D5,$C4
001C2Br 2  D4 C8 D5 C4  
001C2Fr 2  CE CA                .byte   $CE,$CA
001C31r 2               
001C31r 2               ;; PET encoded easter egg text since CBM2
001C31r 2               ;MICROSOFT:
001C31r 2               ;        .byte   $A1,$54,$46,$8F,$13,$8F,$52,$43
001C31r 2               ;        .byte   $89,$CD
001C31r 2               
001C31r 2               ; ----------------------------------------------------------------------------
001C31r 2               ; "ATN" FUNCTION
001C31r 2               ; ----------------------------------------------------------------------------
001C31r 2               ATN:
001C31r 2  A5 BD                lda     FACSIGN
001C33r 2  48                   pha
001C34r 2  10 03                bpl     L3FDB
001C36r 2  20 rr rr             jsr     NEGOP
001C39r 2               L3FDB:
001C39r 2  A5 B8                lda     FAC
001C3Br 2  48                   pha
001C3Cr 2  C9 81                cmp     #$81
001C3Er 2  90 07                bcc     L3FE9
001C40r 2  A9 rr                lda     #<CON_ONE
001C42r 2  A0 rr                ldy     #>CON_ONE
001C44r 2  20 rr rr             jsr     FDIV
001C47r 2               ; ----------------------------------------------------------------------------
001C47r 2               ; 0 <= X <= 1
001C47r 2               ; 0 <= ATN(X) <= PI/8
001C47r 2               ; ----------------------------------------------------------------------------
001C47r 2               L3FE9:
001C47r 2  A9 rr                lda     #<POLY_ATN
001C49r 2  A0 rr                ldy     #>POLY_ATN
001C4Br 2  20 rr rr             jsr     POLYNOMIAL_ODD
001C4Er 2  68                   pla
001C4Fr 2  C9 81                cmp     #$81
001C51r 2  90 07                bcc     L3FFC
001C53r 2  A9 rr                lda     #<CON_PI_HALF
001C55r 2  A0 rr                ldy     #>CON_PI_HALF
001C57r 2  20 rr rr             jsr     FSUB
001C5Ar 2               L3FFC:
001C5Ar 2  68                   pla
001C5Br 2  10 03                bpl     L4002
001C5Dr 2  4C rr rr             jmp     NEGOP
001C60r 2               L4002:
001C60r 2  60                   rts
001C61r 2               
001C61r 2               ; ----------------------------------------------------------------------------
001C61r 2               POLY_ATN:
001C61r 2               
001C61r 2  0B                   .byte   $0B
001C62r 2  76 B3 83 BD  		.byte	$76,$B3,$83,$BD,$D3
001C66r 2  D3           
001C67r 2  79 1E F4 A6  		.byte	$79,$1E,$F4,$A6,$F5
001C6Br 2  F5           
001C6Cr 2  7B 83 FC B0  		.byte	$7B,$83,$FC,$B0,$10
001C70r 2  10           
001C71r 2  7C 0C 1F 67          .byte   $7C,$0C,$1F,$67,$CA
001C75r 2  CA           
001C76r 2  7C DE 53 CB  		.byte	$7C,$DE,$53,$CB,$C1
001C7Ar 2  C1           
001C7Br 2  7D 14 64 70  		.byte	$7D,$14,$64,$70,$4C
001C7Fr 2  4C           
001C80r 2  7D B7 EA 51  		.byte	$7D,$B7,$EA,$51,$7A
001C84r 2  7A           
001C85r 2  7D 63 30 88  		.byte	$7D,$63,$30,$88,$7E
001C89r 2  7E           
001C8Ar 2  7E 92 44 99  		.byte	$7E,$92,$44,$99,$3A
001C8Er 2  3A           
001C8Fr 2  7E 4C CC 91  		.byte	$7E,$4C,$CC,$91,$C7
001C93r 2  C7           
001C94r 2  7F AA AA AA  		.byte	$7F,$AA,$AA,$AA,$13
001C98r 2  13           
001C99r 2  81 00 00 00          .byte   $81,$00,$00,$00,$00
001C9Dr 2  00           
001C9Er 2               
001C9Er 2               ;.endif
001C9Er 2               
001C9Er 2               ;.include "init.s"
001C9Er 2               
001C9Er 2               .segment "MSBINIT"
000000r 2               
000000r 2               ; ----------------------------------------------------------------------------
000000r 2               PR_WRITTEN_BY:
000000r 2               .ifndef CONFIG_CBM_ALL
000000r 2  A9 rr                lda     #<QT_WRITTEN_BY
000002r 2  A0 rr                ldy     #>QT_WRITTEN_BY
000004r 2  20 rr rr             jsr     STROUT
000007r 2               .endif
000007r 2               COLD_START:
000007r 2                 .ifndef CBM2
000007r 2  A2 FF                ldx     #$FF
000009r 2  86 91                stx     CURLIN+1
00000Br 2                 .endif
00000Br 2                 .ifdef CONFIG_NO_INPUTBUFFER_ZP
00000Br 2                       ldx     #$FB
00000Br 2                 .elseif .def(AIM65)
00000Br 2                       ldx     #$FE
00000Br 2                 .endif
00000Br 2  9A                   txs
00000Cr 2                 .ifndef CONFIG_CBM_ALL
00000Cr 2  A9 rr                lda     #<COLD_START
00000Er 2  A0 rr                ldy     #>COLD_START
000010r 2  85 03                sta     GORESTART+1
000012r 2  84 04                sty     GORESTART+2
000014r 2  85 06                sta     GOSTROUT+1
000016r 2  84 07                sty     GOSTROUT+2
000018r 2  A9 rr                lda     #<AYINT
00001Ar 2  A0 rr                ldy     #>AYINT
00001Cr 2  85 08                sta     GOAYINT
00001Er 2  84 09                sty     GOAYINT+1
000020r 2  A9 rr                lda     #<GIVAYF
000022r 2  A0 rr                ldy     #>GIVAYF
000024r 2  85 0A                sta     GOGIVEAYF
000026r 2  84 0B                sty     GOGIVEAYF+1
000028r 2                 .endif
000028r 2  A9 4C                lda     #$4C
00002Ar 2                 .ifdef CONFIG_CBM_ALL
00002Ar 2                       sta     JMPADRS
00002Ar 2                 .endif
00002Ar 2  85 02                sta     GORESTART
00002Cr 2                 .ifndef CONFIG_CBM_ALL
00002Cr 2  85 05                sta     GOSTROUT
00002Er 2  85 AB                sta     JMPADRS
000030r 2                 .endif
000030r 2                 .if (!.def(CONFIG_RAM)) && (!.def(CONFIG_CBM_ALL))
000030r 2  85 02                sta     USR
000032r 2                 .endif
000032r 2               
000032r 2                 .ifndef CONFIG_RAM
000032r 2  A9 rr                  lda     #<IQERR
000034r 2  A0 rr                  ldy     #>IQERR
000036r 2               
000036r 2  85 03                  sta     USR+1
000038r 2  84 04                  sty     USR+2
00003Ar 2                 .endif
00003Ar 2                 .ifndef CBM1
00003Ar 2  A9 28                lda     #WIDTH
00003Cr 2  85 0E                sta     Z17
00003Er 2  A9 1E                lda     #WIDTH2
000040r 2  85 0F                sta     Z18
000042r 2                 .endif
000042r 2               
000042r 2               ; All non-CONFIG_SMALL versions of BASIC have
000042r 2               ; the same bug here: While the number of bytes
000042r 2               ; to be copied is correct for CONFIG_SMALL,
000042r 2               ; it is one byte short on non-CONFIG_SMALL:
000042r 2               ; It seems the "ldx" value below has been
000042r 2               ; hardcoded. So on these configurations,
000042r 2               ; the last byte of GENERIC_RNDSEED, which
000042r 2               ; is 5 bytes instead of 4, does not get copied -
000042r 2               ; which is nothing major, because it is just
000042r 2               ; the least significant 8 bits of the mantissa
000042r 2               ; of the random number seed.
000042r 2               ; KBD added three bytes to CHRGET and removed
000042r 2               ; the random number seed, but only adjusted
000042r 2               ; the number of bytes by adding 3 - this
000042r 2               ; copies four bytes too many, which is no
000042r 2               ; problem.
000042r 2               
000042r 2  A2 1C                ldx     #GENERIC_CHRGET_END-GENERIC_CHRGET-1 ; XXX
000044r 2               L4098:
000044r 2  BD rr rr             lda     GENERIC_CHRGET-1,x
000047r 2  95 C9                sta     CHRGET-1,x
000049r 2  CA                   dex
00004Ar 2  D0 F8                bne     L4098
00004Cr 2  A9 03                lda     #$03
00004Er 2  85 AA                sta     DSCLEN
000050r 2  8A                   txa
000051r 2  85 BF                sta     SHIFTSIGNEXT
000053r 2                 .ifdef CONFIG_CBM_ALL
000053r 2                       sta     CURDVC
000053r 2                 .endif
000053r 2  85 6F                sta     LASTPT+1
000055r 2                 .if .defined(CONFIG_NULL) || .defined(CONFIG_PRINTNULLS)
000055r 2                       sta     Z15
000055r 2                 .endif
000055r 2  48                   pha
000056r 2  85 6C                sta     Z14
000058r 2                 .ifndef CBM2
000058r 2  A9 03                lda     #$03
00005Ar 2  85 AA                sta     DSCLEN
00005Cr 2  20 rr rr             jsr     CRDO
00005Fr 2                 .endif
00005Fr 2                 .ifdef CBM2
00005Fr 2                       inx
00005Fr 2                       stx     INPUTBUFFER-3
00005Fr 2                       stx     INPUTBUFFER-4
00005Fr 2                 .endif
00005Fr 2  A2 70                ldx     #TEMPST
000061r 2  86 6D                stx     TEMPPT
000063r 2                 .ifndef CONFIG_CBM_ALL
000063r 2  A9 rr                lda     #<QT_MEMORY_SIZE
000065r 2  A0 rr                ldy     #>QT_MEMORY_SIZE
000067r 2  20 rr rr             jsr     STROUT
00006Ar 2  20 rr rr             jsr     NXIN
00006Dr 2  86 D1                stx     TXTPTR
00006Fr 2  84 D2                sty     TXTPTR+1
000071r 2  20 CA 00             jsr     CHRGET
000074r 2  C9 41                cmp     #$41
000076r 2  F0 88                beq     PR_WRITTEN_BY
000078r 2  A8                   tay
000079r 2  D0 25                bne     L40EE
00007Br 2               .ifndef CBM2
00007Br 2  A9 00                lda     #<RAMSTART2
00007Dr 2               .endif
00007Dr 2  A0 09                ldy     #>RAMSTART2
00007Fr 2  85 82                sta     TXTTAB
000081r 2  84 83                sty     TXTTAB+1
000083r 2  85 10                sta     LINNUM
000085r 2  84 11                sty     LINNUM+1
000087r 2               .ifdef CBM2
000087r 2               		tay
000087r 2               .else
000087r 2  A0 00                ldy     #$00
000089r 2               .endif
000089r 2               L40D7:
000089r 2  E6 10                inc     LINNUM
00008Br 2  D0 02                bne     L40DD
00008Dr 2  E6 11                inc     LINNUM+1
00008Fr 2               .ifdef CBM1
00008Fr 2               ; CBM: hard RAM top limit is $8000
00008Fr 2                       lda     LINNUM+1
00008Fr 2                       cmp     #$80
00008Fr 2                       beq     L40FA
00008Fr 2               .endif
00008Fr 2               .ifdef CBM2
00008Fr 2               ; optimized version of the CBM1 code
00008Fr 2                       bmi     L40FA
00008Fr 2               .endif
00008Fr 2               .if .def(AIM65)
00008Fr 2               ; AIM65: hard RAM top limit is $A000
00008Fr 2                       lda     LINNUM+1
00008Fr 2                       cmp     #$A0
00008Fr 2                       beq     L40FA
00008Fr 2               .endif
00008Fr 2               L40DD:
00008Fr 2  A9 55                lda     #$55 ; 01010101 / 10101010
000091r 2  91 10                sta     (LINNUM),y
000093r 2  D1 10                cmp     (LINNUM),y
000095r 2  D0 15                bne     L40FA
000097r 2  0A                   asl     a
000098r 2  91 10                sta     (LINNUM),y
00009Ar 2  D1 10                cmp     (LINNUM),y
00009Cr 2               .ifdef CONFIG_CBM_ALL
00009Cr 2                       beq     L40D7
00009Cr 2               .else
00009Cr 2               ;  .ifndef CONFIG_11
00009Cr 2  F0 EB                beq     L40D7; old: faster
00009Er 2  D0 0C                bne     L40FA
0000A0r 2               ;  .else
0000A0r 2               ;        bne     L40FA; new: slower
0000A0r 2               ;        beq     L40D7
0000A0r 2               ;  .endif
0000A0r 2               L40EE:
0000A0r 2  20 D0 00             jsr     CHRGOT
0000A3r 2  20 rr rr             jsr     LINGET
0000A6r 2  A8                   tay
0000A7r 2  F0 03                beq     L40FA
0000A9r 2  4C rr rr             jmp     SYNERR
0000ACr 2               .endif
0000ACr 2               L40FA:
0000ACr 2  A5 10                lda     LINNUM
0000AEr 2  A4 11                ldy     LINNUM+1
0000B0r 2  85 8E                sta     MEMSIZ
0000B2r 2  84 8F                sty     MEMSIZ+1
0000B4r 2               L4106:
0000B4r 2               .ifndef CONFIG_CBM_ALL
0000B4r 2  A9 rr                lda     #<QT_TERMINAL_WIDTH
0000B6r 2  A0 rr                ldy     #>QT_TERMINAL_WIDTH
0000B8r 2  20 rr rr             jsr     STROUT
0000BBr 2  20 rr rr             jsr     NXIN
0000BEr 2  86 D1                stx     TXTPTR
0000C0r 2  84 D2                sty     TXTPTR+1
0000C2r 2  20 CA 00             jsr     CHRGET
0000C5r 2  A8                   tay
0000C6r 2  F0 1C                beq     L4136
0000C8r 2  20 rr rr             jsr     LINGET
0000CBr 2  A5 11                lda     LINNUM+1
0000CDr 2  D0 E5                bne     L4106
0000CFr 2  A5 10                lda     LINNUM
0000D1r 2  C9 10                cmp     #$10
0000D3r 2  90 DF                bcc     L4106
0000D5r 2               L2829:
0000D5r 2  85 0E                sta     Z17
0000D7r 2               L4129:
0000D7r 2  E9 0E                sbc     #$0E
0000D9r 2  B0 FC                bcs     L4129
0000DBr 2  49 FF                eor     #$FF
0000DDr 2  E9 0C                sbc     #$0C
0000DFr 2  18                   clc
0000E0r 2  65 0E                adc     Z17
0000E2r 2  85 0F                sta     Z18
0000E4r 2               .endif
0000E4r 2               L4136:
0000E4r 2               .ifdef CONFIG_RAM
0000E4r 2                       lda     #<QT_WANT
0000E4r 2                       ldy     #>QT_WANT
0000E4r 2                       jsr     STROUT
0000E4r 2                       jsr     NXIN
0000E4r 2                       stx     TXTPTR
0000E4r 2                       sty     TXTPTR+1
0000E4r 2                       jsr     CHRGET
0000E4r 2                       ldx     #<RAMSTART1
0000E4r 2                       ldy     #>RAMSTART1
0000E4r 2                       cmp     #'Y'
0000E4r 2                       beq     L4183
0000E4r 2                       cmp     #'A'
0000E4r 2                       beq     L4157
0000E4r 2                       cmp     #'N'
0000E4r 2                       bne     L4136
0000E4r 2               L4157:
0000E4r 2                       ldx     #<IQERR
0000E4r 2                       ldy     #>IQERR
0000E4r 2                       stx     UNFNC_ATN
0000E4r 2                       sty     UNFNC_ATN+1
0000E4r 2                       ldx     #<ATN	; overwrite starting
0000E4r 2                       ldy     #>ATN	; with ATN
0000E4r 2                       cmp     #'A'
0000E4r 2                       beq     L4183
0000E4r 2                       ldx     #<IQERR
0000E4r 2                       ldy     #>IQERR
0000E4r 2                       stx     UNFNC_COS
0000E4r 2                       sty     UNFNC_COS+1
0000E4r 2                       stx     UNFNC_TAN
0000E4r 2                       sty     UNFNC_TAN+1
0000E4r 2                       stx     UNFNC_SIN
0000E4r 2                       sty     UNFNC_SIN+1
0000E4r 2                       ldx     #<SIN_COS_TAN_ATN	; overwrite
0000E4r 2                       ldy     #>SIN_COS_TAN_ATN	; all of trig.s
0000E4r 2               L4183:
0000E4r 2               .else
0000E4r 2  A2 00                ldx     #<RAMSTART2
0000E6r 2  A0 09                ldy     #>RAMSTART2
0000E8r 2               .endif
0000E8r 2  86 82                stx     TXTTAB
0000EAr 2  84 83                sty     TXTTAB+1
0000ECr 2  A0 00                ldy     #$00
0000EEr 2  98                   tya
0000EFr 2  91 82                sta     (TXTTAB),y
0000F1r 2  E6 82                inc     TXTTAB
0000F3r 2               .ifndef CBM2
0000F3r 2  D0 02                bne     L4192
0000F5r 2  E6 83                inc     TXTTAB+1
0000F7r 2               L4192:
0000F7r 2               .endif
0000F7r 2               .if CONFIG_SCRTCH_ORDER = 1
0000F7r 2                       jsr     SCRTCH
0000F7r 2               .endif
0000F7r 2  A5 82                lda     TXTTAB
0000F9r 2  A4 83                ldy     TXTTAB+1
0000FBr 2  20 rr rr             jsr     REASON
0000FEr 2               .ifdef CBM2
0000FEr 2                       lda     #<QT_BASIC
0000FEr 2                       ldy     #>QT_BASIC
0000FEr 2                       jsr     STROUT
0000FEr 2               .else
0000FEr 2  20 rr rr             jsr     CRDO
000101r 2               .endif
000101r 2  A5 8E                lda     MEMSIZ
000103r 2  38                   sec
000104r 2  E5 82                sbc     TXTTAB
000106r 2  AA                   tax
000107r 2  A5 8F                lda     MEMSIZ+1
000109r 2  E5 83                sbc     TXTTAB+1
00010Br 2  20 rr rr             jsr     LINPRT
00010Er 2  A9 rr                lda     #<QT_BYTES_FREE
000110r 2  A0 rr                ldy     #>QT_BYTES_FREE
000112r 2  20 rr rr             jsr     STROUT
000115r 2               .if CONFIG_SCRTCH_ORDER = 2
000115r 2  20 rr rr             jsr     SCRTCH
000118r 2               .endif
000118r 2               .ifdef CONFIG_CBM_ALL
000118r 2                       jmp     RESTART
000118r 2               .else
000118r 2  A9 rr                lda     #<STROUT
00011Ar 2  A0 rr                ldy     #>STROUT
00011Cr 2  85 06                sta     GOSTROUT+1
00011Er 2  84 07                sty     GOSTROUT+2
000120r 2                 .if CONFIG_SCRTCH_ORDER = 3
000120r 2                        jsr     SCRTCH
000120r 2                 .endif
000120r 2  A9 rr                lda     #<RESTART
000122r 2  A0 rr                ldy     #>RESTART
000124r 2  85 03                sta     GORESTART+1
000126r 2  84 04                sty     GORESTART+2
000128r 2  6C 03 00             jmp     (GORESTART+1)
00012Br 2               .endif
00012Br 2               
00012Br 2                 .if .def(CONFIG_RAM) || .def(OSI)
00012Br 2               ; OSI is compiled for ROM, but includes
00012Br 2               ; this unused string
00012Br 2               QT_WANT:
00012Br 2                       .byte   "WANT SIN-COS-TAN-ATN"
00012Br 2                       .byte   0
00012Br 2                 .endif
00012Br 2               QT_WRITTEN_BY:
00012Br 2                 .ifndef CONFIG_CBM_ALL
00012Br 2  0D 0A 0C             .byte   CR,LF,$0C ; FORM FEED
00012Er 2  57 52 49 54          .byte   "WRITTEN BY WEILAND & GATES"
000132r 2  54 45 4E 20  
000136r 2  42 59 20 57  
000148r 2  0D 0A 00             .byte   CR,LF,0
00014Br 2                  .endif
00014Br 2               QT_MEMORY_SIZE:
00014Br 2  4D 45 4D 4F          .byte   "MEMORY SIZE"
00014Fr 2  52 59 20 53  
000153r 2  49 5A 45     
000156r 2  00                   .byte   0
000157r 2               QT_TERMINAL_WIDTH:
000157r 2                   .if !(.def(AIM65) || .def(SYM1))
000157r 2  54 45 52 4D          .byte   "TERMINAL "
00015Br 2  49 4E 41 4C  
00015Fr 2  20           
000160r 2                   .endif
000160r 2  57 49 44 54          .byte   "WIDTH"
000164r 2  48           
000165r 2  00                   .byte   0
000166r 2                 .endif
000166r 2               QT_BYTES_FREE:
000166r 2  20 42 59 54          .byte   " BYTES FREE"
00016Ar 2  45 53 20 46  
00016Er 2  52 45 45     
000171r 2                 .ifdef CBM1
000171r 2                 .elseif .def(CBM2)
000171r 2                       .byte   CR,0
000171r 2                 .else
000171r 2  0D 0A 0D 0A          .byte   CR,LF,CR,LF
000175r 2                 .endif
000175r 2               QT_BASIC:
000175r 2                 .ifdef CBM1
000175r 2                       .byte   $13 ; HOME
000175r 2                       .byte   "*** COMMODORE BASIC ***"
000175r 2                       .byte   $11,$11,$11,0 ; DOWN/DOWN/DOWN
000175r 2                 .endif
000175r 2                 .ifdef CBM2
000175r 2                       .byte   "### COMMODORE BASIC ###"
000175r 2                       .byte   CR,CR,0
000175r 2                 .endif
000175r 2                 .ifndef CONFIG_CBM_ALL
000175r 2  0D 0A                .byte   CR,LF
000177r 2  43 4F 50 59          .byte   "COPYRIGHT 1977 BY MICROSOFT CO."
00017Br 2  52 49 47 48  
00017Fr 2  54 20 31 39  
000196r 2  0D 0A                .byte   CR,LF
000198r 2  00                   .byte   0
000199r 2                 .endif
000199r 2               
000199r 2               ;.include "extra.s"
000199r 2               
000199r 2               .segment "VEC_MSB"
000000r 2  rr rr        .word NMI
000002r 2  rr rr        .word RESET
000004r 2  rr rr        .word ISR
000006r 2               
000006r 1               
